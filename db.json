{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/favicon.png","path":"favicon.png","modified":1,"renderable":0},{"_id":"source/resume/index.html","path":"resume/index.html","modified":1,"renderable":0},{"_id":"source/resume/index.md","path":"resume/index.md","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style - backup.scss","path":"css/style - backup.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"24dae8cf94a92302544e6688f8117c4bcf7df496","modified":1469789244000},{"_id":"source/favicon.ico","hash":"d3c9929bbbb1278d03e40544b269bea8f542d5a7","modified":1469789244000},{"_id":"source/favicon.png","hash":"4d60b494e58b301abbe639a34e8f0c4f2a70f768","modified":1469789244000},{"_id":"themes/maupassant/.travis.yml","hash":"f8da426b97088e4caa5226cff219a5d95087961f","modified":1469789244000},{"_id":"themes/maupassant/LICENSE","hash":"b7ea1dbb2fed3410d78bc7c125e1d80927b56981","modified":1469789244000},{"_id":"themes/maupassant/README.md","hash":"b3992892d34bc359351b3066070cb5700452ba69","modified":1469789244000},{"_id":"themes/maupassant/_config.yml","hash":"ff9cd15873b0b7541ab51734fc4938e15dcf2745","modified":1469789244000},{"_id":"themes/maupassant/package.json","hash":"04ca87ea475f37841d3610fe5806feb8022416c3","modified":1469789244000},{"_id":"source/_posts/C++中用map模仿反射.md","hash":"8a3e8b94e69ab5fdbdd8206914ac111d34d5d388","modified":1469789244000},{"_id":"source/_posts/CSS零碎笔记.md","hash":"36f9e1730f42ffdb17f04b24c8ae5ec913f4ede1","modified":1469789244000},{"_id":"source/_posts/JS中的Function引用类型.md","hash":"be0d9c73be8355082b5bdc0ade3b535a7976e8f6","modified":1469789244000},{"_id":"source/_posts/JS中的this.md","hash":"baa05a701ad96788b3049f347d9043b00b851dd8","modified":1469789244000},{"_id":"source/_posts/JS中的寄生组合式继承.md","hash":"12271c8ea6a6711390d8f0d36320a5eb8e34c7ae","modified":1469789244000},{"_id":"source/_posts/JS中的零碎知识.md","hash":"608d10ba5d1b0b563a06e6de47a23f2db71953b9","modified":1469789244000},{"_id":"source/_posts/JS事件详解.md","hash":"78b84b10b8c70f93e77dddad13931bfdfc9362ca","modified":1469789244000},{"_id":"source/_posts/JS小实践之项目官网开发.md","hash":"39985c334ce6b611bb3154914a55c4e20086e31e","modified":1469789244000},{"_id":"source/_posts/JavaScript中的函数形参.md","hash":"fd2e6cf78ac357ed1f94a9fdd736f5133f5f2eb8","modified":1469789244000},{"_id":"source/_posts/Vue-js学习笔记-1-绑定.md","hash":"8def126db6d914ae2d7a6a959733f110dcf98425","modified":1469789244000},{"_id":"source/_posts/Vue-js学习笔记-2-指令.md","hash":"71e8a21e9f14ea1223e2fd778bb57d276aef34ba","modified":1469789244000},{"_id":"source/_posts/draft.txt","hash":"ad829c5cbc582b2ab20e5f68a6816b6cf5f99a28","modified":1469789244000},{"_id":"source/_posts/index.txt","hash":"663af566bc77a3e4d5796e35c2663d3619a26349","modified":1469789244000},{"_id":"source/_posts/初次通读代码大全2.md","hash":"fc12dab3ceab130a46e8b9bcd0121d4cb73d56da","modified":1469789244000},{"_id":"source/_posts/作用域链与闭包.docx","hash":"b0d1e260f1187adc0c4d12a7d261be40f4831c55","modified":1469789244000},{"_id":"source/_posts/多说CSS配置.txt","hash":"a8a90116634986be1011a56991c50de8896f845a","modified":1469789244000},{"_id":"source/_posts/如何设计一份令人惊艳的PPT.md","hash":"727092caf7f3d8671e3107e50ca16a66c0a422ab","modified":1469789244000},{"_id":"source/_posts/彻底理解JS闭包.md","hash":"dc356b601ef345b19e16adca42dc14627b82138f","modified":1469789244000},{"_id":"source/_posts/我为什么选择做前端.md","hash":"e638226b8e65404fcf38b139a90e136f9f2908d1","modified":1469789244000},{"_id":"source/_posts/理解JS中的原型.md","hash":"cccfbd746144f4119843015fb7ff5d833658aca0","modified":1469789244000},{"_id":"source/_posts/深刻理解JS的作用域链.md","hash":"5bd89f123e8776a2097e2bf492123a6baad605b6","modified":1469789244000},{"_id":"source/_posts/理解JS的执行环境.md","hash":"db2947ffb2fcc987882daf6941693c23da2061c7","modified":1469789244000},{"_id":"source/_posts/用单例模式来采集GA数据.md","hash":"a916e9b1df9426f3d615129dc0f4d1ecf8a64549","modified":1469789244000},{"_id":"source/_posts/记趋势科技工作一年.md","hash":"6bbccbcaaaae05fefa25688ff6a787af69790083","modified":1469789244000},{"_id":"source/_posts/hello-world.md","hash":"231a61d7644b6fb7a95c4ec3e5965ea7410da2cd","modified":1469789525000},{"_id":"source/categories/index.md","hash":"551977dbcfd34508883621ca9aa3f3f94a25b09b","modified":1469789244000},{"_id":"source/about/index.md","hash":"3b05e4ee1fabf8e4c25dc5c4ed58adefa6650891","modified":1469789244000},{"_id":"source/resume/index.html","hash":"3a9feb7b29185a0c5af7a6db002235f6984060ef","modified":1469789244000},{"_id":"source/resume/index.md","hash":"8b2117dbb1b1de257654e86b70d54ec210d72905","modified":1469789244000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"25d1d8cd8113045a7603c14af1ea1539fc6456ed","modified":1469789244000},{"_id":"themes/maupassant/languages/en.yml","hash":"6c5fc2cec7e44306d97bc7902e9765389d21c363","modified":1469789244000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"3cc9312fbdba4a8f8e8254804121e4724c719bcc","modified":1469789244000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"3a50568f200b9c1258415b53727e42c6b6c7ea0b","modified":1469789244000},{"_id":"themes/maupassant/languages/ko.yml","hash":"a454bcec60113507bc1d593a699849822386c196","modified":1469789244000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"41f7c09365cbd5ba1b8906191ee07bc75094185a","modified":1469789244000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"46659764e31c7866af436d98d4fabb9da122037a","modified":1469789244000},{"_id":"themes/maupassant/layout/archive.jade","hash":"d70d1ed241b1a431a2434768d02bb2de03070f70","modified":1469789244000},{"_id":"themes/maupassant/layout/base.jade","hash":"a647c2cd2a06805e06aa926f3ecd0427d59069c7","modified":1469789244000},{"_id":"themes/maupassant/layout/index.jade","hash":"e06a17f40bfe4d6f3c4cc61a1c1ce986eda30771","modified":1469789244000},{"_id":"themes/maupassant/layout/page.jade","hash":"1e98aa785073dc1bbfe70f2863bc19fe287483b9","modified":1469789244000},{"_id":"themes/maupassant/layout/post.jade","hash":"204815260d88f2cbb5761c083a6dc672129658fb","modified":1469789244000},{"_id":"source/_posts/me.jpg","hash":"efb418c145507a689cd1d07312dc01a508ca9159","modified":1469789244000},{"_id":"themes/maupassant/layout/_partial/comments.jade","hash":"b3a0b0ce0642f2bfe9df94b075c0c2a083871e1b","modified":1469789244000},{"_id":"themes/maupassant/layout/_partial/after_footer.jade","hash":"bec2db90f34a402ed139673b7efc7c8d3b7b0d70","modified":1469789244000},{"_id":"themes/maupassant/layout/_partial/footer.jade","hash":"87e096caac8e780c0894ef1844f59246f861bbe7","modified":1469789244000},{"_id":"themes/maupassant/layout/_partial/helpers.jade","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1469789244000},{"_id":"themes/maupassant/layout/_partial/tag.jade","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1469789244000},{"_id":"themes/maupassant/layout/_partial/post_nav.jade","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1469789244000},{"_id":"themes/maupassant/layout/_partial/paginator.jade","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1469789244000},{"_id":"themes/maupassant/layout/_partial/totop.jade","hash":"eb91a3baf9411188c7c8130f63a674f541ca9c81","modified":1469789244000},{"_id":"themes/maupassant/layout/_widget/links.jade","hash":"2a1dd6a0e2befd073e3347347994d8dcd2047879","modified":1469789244000},{"_id":"themes/maupassant/layout/_widget/category.jade","hash":"80271e02432ab9990c0c07d84aab155f1fb81749","modified":1469789244000},{"_id":"themes/maupassant/layout/_widget/recent_comments.jade","hash":"56a3d6a96e2cccb440ac95d04ee23bb7fb0eccaf","modified":1469789244000},{"_id":"themes/maupassant/layout/_widget/recent_posts.jade","hash":"770b6c41cbf7969ed33adf87eec3be6f50a0911b","modified":1469789244000},{"_id":"themes/maupassant/layout/_widget/search.jade","hash":"c5301ca7f2ec24d790fd7f35f69f8fd8acbdb725","modified":1469789244000},{"_id":"themes/maupassant/layout/_widget/tag.jade","hash":"37f236365b153fc40324391e5a602d6d50014e18","modified":1469789244000},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","hash":"0d142e11e27e9de1a325c32369c42254101ddd34","modified":1469789244000},{"_id":"themes/maupassant/source/css/style - backup.scss","hash":"395b23e26f2b42b8696e321478b60abb5b773a87","modified":1469789244000},{"_id":"themes/maupassant/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1469789244000},{"_id":"themes/maupassant/source/css/style.scss","hash":"13afe34dccdfffb9dae4787a1e80d8272491449e","modified":1469789244000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1469789244000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1469789244000},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1469789244000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1469789244000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1469789244000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"c77270e684a60babc1abb7353e700ecdc5a66d30","modified":1469789244000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"b8564fcf3abbcf43b40752e0636be9596dc50ecc","modified":1469789244000},{"_id":"themes/maupassant/source/js/search.js","hash":"9cf2337fe9af34055782880ac27b93713d74581f","modified":1469789244000},{"_id":"themes/maupassant/source/js/share.js","hash":"bb6880e2e8e187b576daf326476f09b0907fbe14","modified":1469789244000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"150ab1cad40d7ae081b0896b13f7d7cbac4e6338","modified":1469789244000},{"_id":"themes/maupassant/source/js/totop.js","hash":"15de186b089c245fe60766d509b587919f05ff23","modified":1469789244000},{"_id":"public/search.xml","hash":"cbc0d55c6c407d04d1fd5a59c179adf4a293bbe8","modified":1469789543333},{"_id":"public/categories/index.html","hash":"315cfa4fc8881b637a70c6fb7cc9914de8ad5420","modified":1469789543360},{"_id":"public/about/index.html","hash":"908df3bfb39bb60a6bc7bce9cb78310977601551","modified":1469789543360},{"_id":"public/2016/07/28/Vue-js学习笔记-2-指令/index.html","hash":"b64fe2d4cac88b0211ebdea673d4c0f428b294e5","modified":1469789543360},{"_id":"public/2016/07/28/Vue-js学习笔记-1-绑定/index.html","hash":"4c076485eb95692746b08deab509049b0df56247","modified":1469789543360},{"_id":"public/2016/05/28/JS中的this/index.html","hash":"f1240241a14ced37f421c1038f587b7cd71c714f","modified":1469789543360},{"_id":"public/2016/05/25/JavaScript中的函数形参/index.html","hash":"4d093c5207a8dd5fcc9ee9b34bab238b87dfb8ef","modified":1469789543360},{"_id":"public/2016/04/21/hello-world/index.html","hash":"41ec54d971691a7654dbcdf117744adc7440c8d8","modified":1469789543360},{"_id":"public/archives/index.html","hash":"e48172f7a51f2e6512e8857b49550da02be7bedf","modified":1469789543360},{"_id":"public/archives/page/2/index.html","hash":"163e2c094a75a4e5d1861ec9ffc586eec79703df","modified":1469789543360},{"_id":"public/archives/page/3/index.html","hash":"e3999d436b214eccc8cbe90aef7fb3cf2fa8cda7","modified":1469789543360},{"_id":"public/archives/2016/index.html","hash":"9f09534a23c1dda5a7376def5b556bad598e1765","modified":1469789543361},{"_id":"public/archives/2016/page/2/index.html","hash":"18713038342585244260f0c5ebbbd2706f9f7901","modified":1469789543361},{"_id":"public/archives/2016/page/3/index.html","hash":"1f52cd262dec050b5142615b5f62cd1d0d2760eb","modified":1469789543361},{"_id":"public/archives/2016/04/index.html","hash":"3153fd1312cdfc7750408825f85014d167af34e6","modified":1469789543361},{"_id":"public/archives/2016/05/index.html","hash":"288fd209f18c39916dbbcd878006d34febf1af5b","modified":1469789543361},{"_id":"public/archives/2016/05/page/2/index.html","hash":"7a8157bc6b85c25eb33ced034a04fb5c5a482986","modified":1469789543361},{"_id":"public/archives/2016/06/index.html","hash":"97e830a777b5c27bc09eb6c66e1e0159464f0610","modified":1469789543361},{"_id":"public/archives/2016/07/index.html","hash":"f7329d486c4dd39efb71841921d15fe021f4f4c0","modified":1469789543361},{"_id":"public/index.html","hash":"9249da862089c7111c4b73cd4721b9eea3f476ec","modified":1469789543362},{"_id":"public/page/2/index.html","hash":"4060ee3ba8b2ac9be61084a1a6175f34eecd6060","modified":1469789543362},{"_id":"public/page/3/index.html","hash":"fa6dc6a8133d6978e5bce21539f5f644b120c639","modified":1469789543362},{"_id":"public/categories/C/index.html","hash":"5576715af7ea7821538ac45d673a7a10222e9edd","modified":1469789543362},{"_id":"public/categories/CSS/index.html","hash":"fab15f0c61b2a764fe92a12049cee77e51c8565c","modified":1469789543362},{"_id":"public/categories/JavaScript/index.html","hash":"16bdd26a1ce8c5c7868fb01f863bcc335c574b58","modified":1469789543362},{"_id":"public/categories/JavaScript/page/2/index.html","hash":"405ce8e96d9170a351ad5c4300b3d07b54f9a6f9","modified":1469789543362},{"_id":"public/categories/C/设计模式/index.html","hash":"4a3ab99c4f633d46fec70a828aed31f689bb9aed","modified":1469789543362},{"_id":"public/categories/基本功/index.html","hash":"987b55e6b85476e3e0f030ba07c2028d8659f84a","modified":1469789543362},{"_id":"public/categories/不务正业/index.html","hash":"09460bffb9932f4109b0289a2b3f1b8f56067696","modified":1469789543362},{"_id":"public/categories/胡言乱语/index.html","hash":"2a37d422ce8417689002ce309d5948e1d7739945","modified":1469789543362},{"_id":"public/tags/C/index.html","hash":"5576715af7ea7821538ac45d673a7a10222e9edd","modified":1469789543362},{"_id":"public/tags/设计模式/index.html","hash":"4a3ab99c4f633d46fec70a828aed31f689bb9aed","modified":1469789543362},{"_id":"public/tags/CSS/index.html","hash":"fab15f0c61b2a764fe92a12049cee77e51c8565c","modified":1469789543362},{"_id":"public/tags/前端开发/index.html","hash":"f35bfd8819e76e1c8d7ffc4e9349e15e49e457c2","modified":1469789543362},{"_id":"public/tags/前端开发/page/2/index.html","hash":"bd742deefab3e45a3b33505b5a0116f4bd6a14e5","modified":1469789543362},{"_id":"public/tags/JavaScript/index.html","hash":"955435af6831761de9da67be1c4b56c853e21840","modified":1469789543362},{"_id":"public/tags/JavaScript/page/2/index.html","hash":"6f85d009b766352e3dd335c47e9b1f664dd1fc04","modified":1469789543362},{"_id":"public/tags/函数/index.html","hash":"58c071d7316eaf2ec60fd3ca1f71f36fb409b2b1","modified":1469789543362},{"_id":"public/tags/this/index.html","hash":"808895fd4c1e99e4278a458738560ce2b962f7d9","modified":1469789543362},{"_id":"public/tags/Prototype/index.html","hash":"157a7d688f08c5810074a0440a9c8f63a862a4a1","modified":1469789543362},{"_id":"public/tags/前端开发，-事件/index.html","hash":"15728ed3364b0fbf61dc86e8fdc964e2a3648830","modified":1469789543363},{"_id":"public/tags/Vue/index.html","hash":"e58c522940bf7c19fe14a4a158570d8e2b10a6cc","modified":1469789543363},{"_id":"public/tags/代码大全2/index.html","hash":"4dfaf525afb749a42317b4af16f438804e1d6f56","modified":1469789543363},{"_id":"public/tags/编码规范/index.html","hash":"5e3716cfb8c280e545f005afa0b2427814437ab6","modified":1469789543363},{"_id":"public/tags/PPT/index.html","hash":"a626bcf2b017cf6534d1fa576f90e24bf8a8b316","modified":1469789543363},{"_id":"public/tags/闭包/index.html","hash":"330f00545735fc99ff45040f26224cd4a8dbbb3b","modified":1469789543363},{"_id":"public/tags/Scope-chain/index.html","hash":"143f86f03956742db33f58a9b54de6fbe1dcc8e5","modified":1469789543363},{"_id":"public/tags/职业发展/index.html","hash":"c1910b1bf8bae536a5938873992dfb36cacafd8f","modified":1469789543363},{"_id":"public/tags/HTTP/index.html","hash":"52d3d2011a11e752a1fbcc27195e6e89c5150d57","modified":1469789543363},{"_id":"public/tags/趋势科技/index.html","hash":"30f580a68fc6e89e5e600c225f38db1d1d6c7d13","modified":1469789543363},{"_id":"public/tags/工作一年/index.html","hash":"ad60e52f1203901f692ea91d1ddfdba77bbc2b4b","modified":1469789543363},{"_id":"public/tags/感恩/index.html","hash":"46a2e9f08f55b401b2540143a0e56449cd4026a4","modified":1469789543363},{"_id":"public/2016/07/12/记趋势科技工作一年/index.html","hash":"fad02c3687988554f057bb58e2599e9b4ff19fda","modified":1469789543363},{"_id":"public/2016/06/30/初次通读代码大全2/index.html","hash":"bbe63802328e245ce0cab54db89f605bfcb0268f","modified":1469789543364},{"_id":"public/2016/06/04/JS事件详解/index.html","hash":"217502a3348e16d635251a9085032986d4b5328f","modified":1469789543364},{"_id":"public/2016/06/03/JS小实践之项目官网开发/index.html","hash":"03b0c39b2e53f801e4ac76db1d1e25702842f9b6","modified":1469789543364},{"_id":"public/2016/06/03/CSS零碎笔记/index.html","hash":"86b4886ae8ba5e2d264ce3e0eb1076f416f6092b","modified":1469789543364},{"_id":"public/2016/05/29/彻底理解JS闭包/index.html","hash":"d831c25334ecdd3f8660c377b58bc79b21c0102f","modified":1469789543364},{"_id":"public/2016/05/28/深刻理解JS的作用域链/index.html","hash":"4f703436fa2a3ff75f683edd4df65791f093bfa7","modified":1469789543364},{"_id":"public/2016/05/27/JS中的寄生组合式继承/index.html","hash":"8b5e46c5eb48afce17a020f74fe89db595421486","modified":1469789543364},{"_id":"public/2016/05/26/理解JS中的原型/index.html","hash":"8c3c61629348ec53796cb5085e474a75a8ea67bb","modified":1469789543364},{"_id":"public/2016/05/25/JS中的Function引用类型/index.html","hash":"00af6657d1d6aa48c1213805951bd4e112538bea","modified":1469789543364},{"_id":"public/2016/05/25/理解JS的执行环境/index.html","hash":"12f73f30fead8d01ad0e69363de6456251fcaee0","modified":1469789543365},{"_id":"public/2016/05/25/JS中的零碎知识/index.html","hash":"eee609cedc0244baec2d64e54e75505ff9c6111e","modified":1469789543365},{"_id":"public/2016/05/21/如何设计一份令人惊艳的PPT/index.html","hash":"6899fc57ab97c161f703f57952702836de394c09","modified":1469789543365},{"_id":"public/2016/05/19/用单例模式来采集GA数据/index.html","hash":"337ea829859dcb84980ce1865adab79941cfdb4f","modified":1469789543365},{"_id":"public/2016/05/19/C++中用map模仿反射/index.html","hash":"e657272b7dccc8c69ffc25b733b8720cd3a52cff","modified":1469789543365},{"_id":"public/2016/05/19/我为什么选择做前端/index.html","hash":"a92df90711d0ed0e72d9681aab71fe76ddb55bba","modified":1469789543365},{"_id":"public/CNAME","hash":"24dae8cf94a92302544e6688f8117c4bcf7df496","modified":1469789543371},{"_id":"public/favicon.ico","hash":"d3c9929bbbb1278d03e40544b269bea8f542d5a7","modified":1469789543371},{"_id":"public/favicon.png","hash":"4d60b494e58b301abbe639a34e8f0c4f2a70f768","modified":1469789543371},{"_id":"public/resume/index.html","hash":"3a9feb7b29185a0c5af7a6db002235f6984060ef","modified":1469789543371},{"_id":"public/resume/index.md","hash":"8b2117dbb1b1de257654e86b70d54ec210d72905","modified":1469789543371},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1469789543371},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1469789543371},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1469789543371},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1469789543371},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1469789543371},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1469789543371},{"_id":"public/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1469789543427},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1469789543427},{"_id":"public/js/fancybox.js","hash":"92be822124e716a947bae3d676867e702933a93c","modified":1469789543427},{"_id":"public/js/search.js","hash":"53db2eb255dd40a412ed62ea7332ca5a22f7816f","modified":1469789543428},{"_id":"public/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1469789543428},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1469789543428},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1469789543428},{"_id":"public/css/style - backup.css","hash":"f2fa9afef0f5a3a51245b5756b4c23059c1eabbb","modified":1469789543428},{"_id":"public/css/style.css","hash":"62b40503edbcd3cb7142ca62bb6198e895a31cdc","modified":1469789543428}],"Category":[{"name":"C++","_id":"cir7mqrox0005526rjynxs1ll"},{"name":"CSS","_id":"cir7mqrp5000a526r47hi7898"},{"name":"JavaScript","_id":"cir7mqrp8000e526rymqlbluu"},{"name":"设计模式","parent":"cir7mqrox0005526rjynxs1ll","_id":"cir7mqrpi000p526rum6t12e2"},{"name":"基本功","_id":"cir7mqrq5001h526rseio8h32"},{"name":"不务正业","_id":"cir7mqrqb001q526rjxjc0uuu"},{"name":"胡言乱语","_id":"cir7mqrqh0021526ro309kjbt"}],"Data":[],"Page":[{"title":"categories","date":"2016-04-21T05:23:21.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-04-21 13:23:21\n---\n","updated":"2016-07-29T10:47:24.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cir7mqroo0001526ryp7jbj7t","content":"","excerpt":"","more":""},{"title":"远方的我","date":"2016-04-21T04:55:58.000Z","_content":"<img src=\"http://7xtj85.com1.z0.glb.clouddn.com/me.jpg\" alt=\"\">\n<p style=\"white-space:pre-wrap;\">   夜阑人静，万家灯火。此刻的办公室静谧得如同时间已被暂停。你依旧聚精会神地将头埋在电脑前，任指尖在沾满油渍的茶轴键盘间轻快地敲击，疲倦而兴奋的脸颊在一片昏暗中被显示器的光亮映照得轮廓分明。手边是你刚刚焖上的一碗热气腾腾的老坛酸菜方便面，但此刻的你显然无暇顾及。不知过了多久，你突然停止敲击，揉了揉眼望向窗外，旋即深吸一口气，开始屏息凝视屏幕。只见一行行命令忽快忽慢顺次闪现，如同一道道彗星划过夜空。好家伙！这一回该死的IDE居然没有报错，数据加载完毕，程序运行成功，一切都顺利得不可思议，完美到恍然若梦。\n    于是，你不禁开始畅想自己终于可以挥别创业以来无数次没日没夜的加班，产品提交上线，用户鱼贯而入；各大媒体为你辟出头条，评论家们将你捧在掌心；微博转爆，微信塞满，投资人的电话骚扰得你应接不暇；你成功融资，扩大规模，豪聚四方宾朋，招徕各路英才；你一掷千金地烧钱推广，引发用户量的几何级数暴涨，甚至连行业巨头公司都为之震动，一度不得不在自己的产品里封杀你；用户们排队掏钱趋之若鹜，你的营收图表连续拉出几道气势恢宏的阳线，前来拜访取经的团队无不惊呼你的办公环境堪称土豪；你邀请一线国际女星出席发布会，参演微电影，在线下铺天盖地地刷存在感，楼宇、地铁、广场、邮轮上无不是你引以为傲的图标；你的公关团队将你打造成电视广告里的高帅富加励志偶像，还顺便跟网络红人传点绯闻。终于，你递交了上市招股书，在海内外一票分析师对业绩的指指戳戳中，成功站在纳斯达克的顶点，敲响了开市的钟。身旁一众西装革履的幕僚们鼓掌欢呼，开香槟庆祝。而你的脑海霎时间一片空白，只是呆呆地凝望着大屏幕——如同当年在漆黑电脑屏幕前那样。报价终端上实时跳动着最新撮合的交易量，海内外投资者蜂拥而至，股票价格一路水涨船高，连整个华尔街都为之震惊。而你终于从晃神中清醒过来，将思绪重新拉回嘈杂的交易所内，怀揣难以言喻的心情掏出手机，给远在国内的运营总监打了个电话：“嗨，Joey，从明天起给公司全体员工换发新名片。嗯，对，印上我们的股票代码——NIUB。”\n</p>\n<div style=\"text-align:right\"><span>——引自<a href=\"https://jobrest.gitbooks.io/growthhacking/content/\" target=\"_blank\" style=\"color: #3385FF;word-break: break-all;text-decoration: underline;\">增长黑客</a>，和大家共勉</span></div>\n","source":"about/index.md","raw":"---\ntitle: 远方的我\ndate: 2016-04-21 12:55:58\n---\n<img src=\"http://7xtj85.com1.z0.glb.clouddn.com/me.jpg\" alt=\"\">\n<p style=\"white-space:pre-wrap;\">   夜阑人静，万家灯火。此刻的办公室静谧得如同时间已被暂停。你依旧聚精会神地将头埋在电脑前，任指尖在沾满油渍的茶轴键盘间轻快地敲击，疲倦而兴奋的脸颊在一片昏暗中被显示器的光亮映照得轮廓分明。手边是你刚刚焖上的一碗热气腾腾的老坛酸菜方便面，但此刻的你显然无暇顾及。不知过了多久，你突然停止敲击，揉了揉眼望向窗外，旋即深吸一口气，开始屏息凝视屏幕。只见一行行命令忽快忽慢顺次闪现，如同一道道彗星划过夜空。好家伙！这一回该死的IDE居然没有报错，数据加载完毕，程序运行成功，一切都顺利得不可思议，完美到恍然若梦。\n    于是，你不禁开始畅想自己终于可以挥别创业以来无数次没日没夜的加班，产品提交上线，用户鱼贯而入；各大媒体为你辟出头条，评论家们将你捧在掌心；微博转爆，微信塞满，投资人的电话骚扰得你应接不暇；你成功融资，扩大规模，豪聚四方宾朋，招徕各路英才；你一掷千金地烧钱推广，引发用户量的几何级数暴涨，甚至连行业巨头公司都为之震动，一度不得不在自己的产品里封杀你；用户们排队掏钱趋之若鹜，你的营收图表连续拉出几道气势恢宏的阳线，前来拜访取经的团队无不惊呼你的办公环境堪称土豪；你邀请一线国际女星出席发布会，参演微电影，在线下铺天盖地地刷存在感，楼宇、地铁、广场、邮轮上无不是你引以为傲的图标；你的公关团队将你打造成电视广告里的高帅富加励志偶像，还顺便跟网络红人传点绯闻。终于，你递交了上市招股书，在海内外一票分析师对业绩的指指戳戳中，成功站在纳斯达克的顶点，敲响了开市的钟。身旁一众西装革履的幕僚们鼓掌欢呼，开香槟庆祝。而你的脑海霎时间一片空白，只是呆呆地凝望着大屏幕——如同当年在漆黑电脑屏幕前那样。报价终端上实时跳动着最新撮合的交易量，海内外投资者蜂拥而至，股票价格一路水涨船高，连整个华尔街都为之震惊。而你终于从晃神中清醒过来，将思绪重新拉回嘈杂的交易所内，怀揣难以言喻的心情掏出手机，给远在国内的运营总监打了个电话：“嗨，Joey，从明天起给公司全体员工换发新名片。嗯，对，印上我们的股票代码——NIUB。”\n</p>\n<div style=\"text-align:right\"><span>——引自<a href=\"https://jobrest.gitbooks.io/growthhacking/content/\" target=\"_blank\" style=\"color: #3385FF;word-break: break-all;text-decoration: underline;\">增长黑客</a>，和大家共勉</span></div>\n","updated":"2016-07-29T10:47:24.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cir7mqros0003526rs168eror","content":"<p><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/me.jpg\" alt=\"\"></p>\n<p></p><p style=\"white-space:pre-wrap;\">   夜阑人静，万家灯火。此刻的办公室静谧得如同时间已被暂停。你依旧聚精会神地将头埋在电脑前，任指尖在沾满油渍的茶轴键盘间轻快地敲击，疲倦而兴奋的脸颊在一片昏暗中被显示器的光亮映照得轮廓分明。手边是你刚刚焖上的一碗热气腾腾的老坛酸菜方便面，但此刻的你显然无暇顾及。不知过了多久，你突然停止敲击，揉了揉眼望向窗外，旋即深吸一口气，开始屏息凝视屏幕。只见一行行命令忽快忽慢顺次闪现，如同一道道彗星划过夜空。好家伙！这一回该死的IDE居然没有报错，数据加载完毕，程序运行成功，一切都顺利得不可思议，完美到恍然若梦。<br>    于是，你不禁开始畅想自己终于可以挥别创业以来无数次没日没夜的加班，产品提交上线，用户鱼贯而入；各大媒体为你辟出头条，评论家们将你捧在掌心；微博转爆，微信塞满，投资人的电话骚扰得你应接不暇；你成功融资，扩大规模，豪聚四方宾朋，招徕各路英才；你一掷千金地烧钱推广，引发用户量的几何级数暴涨，甚至连行业巨头公司都为之震动，一度不得不在自己的产品里封杀你；用户们排队掏钱趋之若鹜，你的营收图表连续拉出几道气势恢宏的阳线，前来拜访取经的团队无不惊呼你的办公环境堪称土豪；你邀请一线国际女星出席发布会，参演微电影，在线下铺天盖地地刷存在感，楼宇、地铁、广场、邮轮上无不是你引以为傲的图标；你的公关团队将你打造成电视广告里的高帅富加励志偶像，还顺便跟网络红人传点绯闻。终于，你递交了上市招股书，在海内外一票分析师对业绩的指指戳戳中，成功站在纳斯达克的顶点，敲响了开市的钟。身旁一众西装革履的幕僚们鼓掌欢呼，开香槟庆祝。而你的脑海霎时间一片空白，只是呆呆地凝望着大屏幕——如同当年在漆黑电脑屏幕前那样。报价终端上实时跳动着最新撮合的交易量，海内外投资者蜂拥而至，股票价格一路水涨船高，连整个华尔街都为之震惊。而你终于从晃神中清醒过来，将思绪重新拉回嘈杂的交易所内，怀揣难以言喻的心情掏出手机，给远在国内的运营总监打了个电话：“嗨，Joey，从明天起给公司全体员工换发新名片。嗯，对，印上我们的股票代码——NIUB。”<br></p><p></p>\n<div style=\"text-align:right\"><span>——引自<a href=\"https://jobrest.gitbooks.io/growthhacking/content/\" target=\"_blank\" style=\"color: #3385FF;word-break: break-all;text-decoration: underline;\">增长黑客</a>，和大家共勉</span></div>\n","excerpt":"","more":"<p><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/me.jpg\" alt=\"\"></p>\n<p><p style=\"white-space:pre-wrap;\">   夜阑人静，万家灯火。此刻的办公室静谧得如同时间已被暂停。你依旧聚精会神地将头埋在电脑前，任指尖在沾满油渍的茶轴键盘间轻快地敲击，疲倦而兴奋的脸颊在一片昏暗中被显示器的光亮映照得轮廓分明。手边是你刚刚焖上的一碗热气腾腾的老坛酸菜方便面，但此刻的你显然无暇顾及。不知过了多久，你突然停止敲击，揉了揉眼望向窗外，旋即深吸一口气，开始屏息凝视屏幕。只见一行行命令忽快忽慢顺次闪现，如同一道道彗星划过夜空。好家伙！这一回该死的IDE居然没有报错，数据加载完毕，程序运行成功，一切都顺利得不可思议，完美到恍然若梦。<br>    于是，你不禁开始畅想自己终于可以挥别创业以来无数次没日没夜的加班，产品提交上线，用户鱼贯而入；各大媒体为你辟出头条，评论家们将你捧在掌心；微博转爆，微信塞满，投资人的电话骚扰得你应接不暇；你成功融资，扩大规模，豪聚四方宾朋，招徕各路英才；你一掷千金地烧钱推广，引发用户量的几何级数暴涨，甚至连行业巨头公司都为之震动，一度不得不在自己的产品里封杀你；用户们排队掏钱趋之若鹜，你的营收图表连续拉出几道气势恢宏的阳线，前来拜访取经的团队无不惊呼你的办公环境堪称土豪；你邀请一线国际女星出席发布会，参演微电影，在线下铺天盖地地刷存在感，楼宇、地铁、广场、邮轮上无不是你引以为傲的图标；你的公关团队将你打造成电视广告里的高帅富加励志偶像，还顺便跟网络红人传点绯闻。终于，你递交了上市招股书，在海内外一票分析师对业绩的指指戳戳中，成功站在纳斯达克的顶点，敲响了开市的钟。身旁一众西装革履的幕僚们鼓掌欢呼，开香槟庆祝。而你的脑海霎时间一片空白，只是呆呆地凝望着大屏幕——如同当年在漆黑电脑屏幕前那样。报价终端上实时跳动着最新撮合的交易量，海内外投资者蜂拥而至，股票价格一路水涨船高，连整个华尔街都为之震惊。而你终于从晃神中清醒过来，将思绪重新拉回嘈杂的交易所内，怀揣难以言喻的心情掏出手机，给远在国内的运营总监打了个电话：“嗨，Joey，从明天起给公司全体员工换发新名片。嗯，对，印上我们的股票代码——NIUB。”<br></p></p>\n<div style=\"text-align:right\"><span>——引自<a href=\"https://jobrest.gitbooks.io/growthhacking/content/\" target=\"_blank\" style=\"color: #3385FF;word-break: break-all;text-decoration: underline;\">增长黑客</a>，和大家共勉</span></div>\n"}],"Post":[{"title":"C++中用map模仿反射","toc":true,"date":"2016-05-19T03:24:49.000Z","description":["反射反射，程序员的快乐"],"_content":"反射反射，程序员的快乐\n<!--more-->\n## 前言 ##\n从去年7月份进入公司来，一直负责一款局域网设备扫描检测客户端的前端开发工作，技术解决方案是采用轻量级的HTML渲染引擎HTMLayout，并在其的基础上用C++开发了一套类似jQuery的前端框架，用来支持DOM操作，主要功能是将服务器的返回数据和Nmap的扫描结果展现出来，并做好Google Analytics数据采集。\n这个库是公司一个前辈开发的，前阵子刚好有时间，周末抽了两天研究了一下，真的是写的太好了，尤其是那个创建不同CHlWindow对象的map，从来没有看过这么好的code啊，我们在学校写的都是垃圾啊\n**注：**HTMLayout是一个免费的开源界面库，以DLL方式运行，并提供一些API，其相当于一个轻量级的HTML渲染引擎，可以高效快速的解析和渲染HTML文档。\n\n## UML类图 ## \n这个库的核心思想是采用**策略模式**，首先我们有很多张UI（比如Eula、Homepage等等），从概念上看这些UI具有相同的操作，比如Open、Close、Reload、EventHandle等等，不同的是这些操作对于不同的UI实现起来是不一样的。然后对这些UI抽象出一个**接口**，在窗口管理类CWindowMgrImpl中通过这个接口可以很方便的操作这些UI。\n**策略模式**\n- 概念：策略模式是一种定义一系列算法的模式，所有这些算法完成的都是相同的工作，只是实现不同，比如打折、返利都是一种收费方式。\n- 应用场景：策略模式就是用来封装算法的，但在实践我们发现可以用它来封装几乎**任何类型的规则**，只要在分析过程中听到需要在不同时间运用不同的业务规则，就可以考虑用策略模式来处理这种变化。\n\n这个库的UML类图如下： \n\n![UML类图][1]\n\n## 核心代码 ##\n\n- 问题的关键是如何在窗口管理类CWindowMgrImpl中创建不同的UI对象（比如HomepageUI对象），用case条件语句来判断似乎不是一个很好的办法，C#中有**反射**的概念，在这里我们借助map来模仿反射，关键代码如下：\n```C++\ntypedef TmCommon::wstring WindowType;\n\nclass CWindowMgrImpl\n{\npublic:\n    std::map<WindowType, std::shared_ptr<IHlWindowCtrller>> m_mapWndCtrl;\n}\ntemplate <typename T>\nstatic std::shared_ptr<IHlWindowCtrller> CreateHlWindow\n(const TmCommon::wstring& wstrId)\n{\n    return std::shared_ptr<IHlWindowCtrller>(std::make_shared<T>(wstrId));\n    /*std::shared_ptr称为智能指针，其采用引用计数，是防止内存泄露的神器。\n     *std::make_shared用于创建一个对象。\n     *所以上面这个表达式的意思是创建一个对象，并返回一个指向这个对象的智能指针。\n     */\n}\n\ntypedef std::shared_ptr<IHlWindowCtrller> (*FP_CreateHlWindow)\n(const TmCommon::wstring& wstrId);\n/*定义一个函数指针*/\ntypedef std::map<WindowType, FP_CreateHlWindow> HlWindowCreatorMap;\n\nclass CHlWindowFactory\n{\nfriend class CWindowMgrImpl;\nprivate:\n    static HlWindowCreatorMap s_mapCreator;\npublic:\n    CHlWindowFactory(const WindowType& type, FP_CreateHlWindow)\n    {\n        s_mapCreator[type] = fp;\n    }\n};\n\n#define ADD_HLWINDOW_CREATOR(windowType)\\\n    CHlWindowFactory temp##windowType(L#windowType, CreateHlWindow<windowType>)\n\nbool CWindowMgrImpl::OpenHlWindow\n(const WindowType& type, const WindowId& id, void* pParam)\n{\n    boost::lock_guard<boost::mutex> lock(m_mutex);\n    // already exist this window id \n    if (m_mapWndCtrl.find(id) != m_mapWndCtrl.end())\n    {  \n        ::ShowWindow(m_mapWndCtrl[id]->GetHWnd(), SW_SHOWNORMAL);\n        SetForegroundWindow(m_mapWndCtrl[id]->GetHWnd());   \n        return true;\n    }\n\n    auto itr = CHlWindowFactory::s_mapCreator.find(type);\n    if (itr == CHlWindowFactory::s_mapCreator.end())\n    {\n        // the type does not exist\n        return false;\n    }\n\n    std::shared_ptr<IHlWindowCtrller> pCtrler = itr->second(id);\n    /*创建这个UI对象.*/\n    pCtrler->SetWindowMgr(this);\n    HWND hWnd = pCtrler->Open(pParam);\n    if (NULL != hWnd)\n    {\n        m_mapWndCtrl[id] = pCtrler;\n    }\n\n    return true;\n}\n\n/*1.这样在HomepageUI中就可以用上面这个宏，比如ADD_HLWINDOW_CREATOR(HomepageUI);\n *2.调用mgr.OpenHlWindow(L\"HomepageUI\", L\"HomepageUI\");\n *  mgr是CWindowMgrImpl的实例\n *  就可以成功创建并打开一个窗口了.*/\n```\n\n\n[1]:http://7xtj85.com1.z0.glb.clouddn.com/image/jpg/TmHtmlayout_UML.png\n\n\n\n","source":"_posts/C++中用map模仿反射.md","raw":"---\ntitle: C++中用map模仿反射\ntoc: true\ndate: 2016-05-19 11:24:49\ncategories: [C++, 设计模式]\ntags: [C++, 设计模式]\ndescription: [反射反射，程序员的快乐]\n---\n反射反射，程序员的快乐\n<!--more-->\n## 前言 ##\n从去年7月份进入公司来，一直负责一款局域网设备扫描检测客户端的前端开发工作，技术解决方案是采用轻量级的HTML渲染引擎HTMLayout，并在其的基础上用C++开发了一套类似jQuery的前端框架，用来支持DOM操作，主要功能是将服务器的返回数据和Nmap的扫描结果展现出来，并做好Google Analytics数据采集。\n这个库是公司一个前辈开发的，前阵子刚好有时间，周末抽了两天研究了一下，真的是写的太好了，尤其是那个创建不同CHlWindow对象的map，从来没有看过这么好的code啊，我们在学校写的都是垃圾啊\n**注：**HTMLayout是一个免费的开源界面库，以DLL方式运行，并提供一些API，其相当于一个轻量级的HTML渲染引擎，可以高效快速的解析和渲染HTML文档。\n\n## UML类图 ## \n这个库的核心思想是采用**策略模式**，首先我们有很多张UI（比如Eula、Homepage等等），从概念上看这些UI具有相同的操作，比如Open、Close、Reload、EventHandle等等，不同的是这些操作对于不同的UI实现起来是不一样的。然后对这些UI抽象出一个**接口**，在窗口管理类CWindowMgrImpl中通过这个接口可以很方便的操作这些UI。\n**策略模式**\n- 概念：策略模式是一种定义一系列算法的模式，所有这些算法完成的都是相同的工作，只是实现不同，比如打折、返利都是一种收费方式。\n- 应用场景：策略模式就是用来封装算法的，但在实践我们发现可以用它来封装几乎**任何类型的规则**，只要在分析过程中听到需要在不同时间运用不同的业务规则，就可以考虑用策略模式来处理这种变化。\n\n这个库的UML类图如下： \n\n![UML类图][1]\n\n## 核心代码 ##\n\n- 问题的关键是如何在窗口管理类CWindowMgrImpl中创建不同的UI对象（比如HomepageUI对象），用case条件语句来判断似乎不是一个很好的办法，C#中有**反射**的概念，在这里我们借助map来模仿反射，关键代码如下：\n```C++\ntypedef TmCommon::wstring WindowType;\n\nclass CWindowMgrImpl\n{\npublic:\n    std::map<WindowType, std::shared_ptr<IHlWindowCtrller>> m_mapWndCtrl;\n}\ntemplate <typename T>\nstatic std::shared_ptr<IHlWindowCtrller> CreateHlWindow\n(const TmCommon::wstring& wstrId)\n{\n    return std::shared_ptr<IHlWindowCtrller>(std::make_shared<T>(wstrId));\n    /*std::shared_ptr称为智能指针，其采用引用计数，是防止内存泄露的神器。\n     *std::make_shared用于创建一个对象。\n     *所以上面这个表达式的意思是创建一个对象，并返回一个指向这个对象的智能指针。\n     */\n}\n\ntypedef std::shared_ptr<IHlWindowCtrller> (*FP_CreateHlWindow)\n(const TmCommon::wstring& wstrId);\n/*定义一个函数指针*/\ntypedef std::map<WindowType, FP_CreateHlWindow> HlWindowCreatorMap;\n\nclass CHlWindowFactory\n{\nfriend class CWindowMgrImpl;\nprivate:\n    static HlWindowCreatorMap s_mapCreator;\npublic:\n    CHlWindowFactory(const WindowType& type, FP_CreateHlWindow)\n    {\n        s_mapCreator[type] = fp;\n    }\n};\n\n#define ADD_HLWINDOW_CREATOR(windowType)\\\n    CHlWindowFactory temp##windowType(L#windowType, CreateHlWindow<windowType>)\n\nbool CWindowMgrImpl::OpenHlWindow\n(const WindowType& type, const WindowId& id, void* pParam)\n{\n    boost::lock_guard<boost::mutex> lock(m_mutex);\n    // already exist this window id \n    if (m_mapWndCtrl.find(id) != m_mapWndCtrl.end())\n    {  \n        ::ShowWindow(m_mapWndCtrl[id]->GetHWnd(), SW_SHOWNORMAL);\n        SetForegroundWindow(m_mapWndCtrl[id]->GetHWnd());   \n        return true;\n    }\n\n    auto itr = CHlWindowFactory::s_mapCreator.find(type);\n    if (itr == CHlWindowFactory::s_mapCreator.end())\n    {\n        // the type does not exist\n        return false;\n    }\n\n    std::shared_ptr<IHlWindowCtrller> pCtrler = itr->second(id);\n    /*创建这个UI对象.*/\n    pCtrler->SetWindowMgr(this);\n    HWND hWnd = pCtrler->Open(pParam);\n    if (NULL != hWnd)\n    {\n        m_mapWndCtrl[id] = pCtrler;\n    }\n\n    return true;\n}\n\n/*1.这样在HomepageUI中就可以用上面这个宏，比如ADD_HLWINDOW_CREATOR(HomepageUI);\n *2.调用mgr.OpenHlWindow(L\"HomepageUI\", L\"HomepageUI\");\n *  mgr是CWindowMgrImpl的实例\n *  就可以成功创建并打开一个窗口了.*/\n```\n\n\n[1]:http://7xtj85.com1.z0.glb.clouddn.com/image/jpg/TmHtmlayout_UML.png\n\n\n\n","slug":"C++中用map模仿反射","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqroj0000526r9joaqe8x","content":"<p>反射反射，程序员的快乐<br><a id=\"more\"></a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>从去年7月份进入公司来，一直负责一款局域网设备扫描检测客户端的前端开发工作，技术解决方案是采用轻量级的HTML渲染引擎HTMLayout，并在其的基础上用C++开发了一套类似jQuery的前端框架，用来支持DOM操作，主要功能是将服务器的返回数据和Nmap的扫描结果展现出来，并做好Google Analytics数据采集。<br>这个库是公司一个前辈开发的，前阵子刚好有时间，周末抽了两天研究了一下，真的是写的太好了，尤其是那个创建不同CHlWindow对象的map，从来没有看过这么好的code啊，我们在学校写的都是垃圾啊<br><strong>注：</strong>HTMLayout是一个免费的开源界面库，以DLL方式运行，并提供一些API，其相当于一个轻量级的HTML渲染引擎，可以高效快速的解析和渲染HTML文档。</p>\n<h2 id=\"UML类图\"><a href=\"#UML类图\" class=\"headerlink\" title=\"UML类图\"></a>UML类图</h2><p>这个库的核心思想是采用<strong>策略模式</strong>，首先我们有很多张UI（比如Eula、Homepage等等），从概念上看这些UI具有相同的操作，比如Open、Close、Reload、EventHandle等等，不同的是这些操作对于不同的UI实现起来是不一样的。然后对这些UI抽象出一个<strong>接口</strong>，在窗口管理类CWindowMgrImpl中通过这个接口可以很方便的操作这些UI。<br><strong>策略模式</strong></p>\n<ul>\n<li>概念：策略模式是一种定义一系列算法的模式，所有这些算法完成的都是相同的工作，只是实现不同，比如打折、返利都是一种收费方式。</li>\n<li>应用场景：策略模式就是用来封装算法的，但在实践我们发现可以用它来封装几乎<strong>任何类型的规则</strong>，只要在分析过程中听到需要在不同时间运用不同的业务规则，就可以考虑用策略模式来处理这种变化。</li>\n</ul>\n<p>这个库的UML类图如下： </p>\n<p><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/image/jpg/TmHtmlayout_UML.png\" alt=\"UML类图\"></p>\n<h2 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h2><ul>\n<li>问题的关键是如何在窗口管理类CWindowMgrImpl中创建不同的UI对象（比如HomepageUI对象），用case条件语句来判断似乎不是一个很好的办法，C#中有<strong>反射</strong>的概念，在这里我们借助map来模仿反射，关键代码如下：<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> TmCommon::wstring WindowType;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> CWindowMgrImpl</div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;WindowType, <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;IHlWindowCtrller&gt;&gt; m_mapWndCtrl;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;IHlWindowCtrller&gt; CreateHlWindow</div><div class=\"line\">(<span class=\"keyword\">const</span> TmCommon::wstring&amp; wstrId)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;IHlWindowCtrller&gt;(<span class=\"built_in\">std</span>::make_shared&lt;T&gt;(wstrId));</div><div class=\"line\">    <span class=\"comment\">/*std::shared_ptr称为智能指针，其采用引用计数，是防止内存泄露的神器。</span></div><div class=\"line\">     *std::make_shared用于创建一个对象。</div><div class=\"line\">     *所以上面这个表达式的意思是创建一个对象，并返回一个指向这个对象的智能指针。</div><div class=\"line\">     */</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;IHlWindowCtrller&gt; (*FP_CreateHlWindow)</div><div class=\"line\">(<span class=\"keyword\">const</span> TmCommon::wstring&amp; wstrId);</div><div class=\"line\"><span class=\"comment\">/*定义一个函数指针*/</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;WindowType, FP_CreateHlWindow&gt; HlWindowCreatorMap;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> CHlWindowFactory</div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> CWindowMgrImpl;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">static</span> HlWindowCreatorMap s_mapCreator;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    CHlWindowFactory(<span class=\"keyword\">const</span> WindowType&amp; type, FP_CreateHlWindow)</div><div class=\"line\">    &#123;</div><div class=\"line\">        s_mapCreator[type] = fp;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ADD_HLWINDOW_CREATOR(windowType)\\</span></div><div class=\"line\">    CHlWindowFactory temp##windowType(L#windowType, CreateHlWindow<span class=\"meta-string\">&lt;windowType&gt;</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">bool</span> CWindowMgrImpl::OpenHlWindow</div><div class=\"line\">(<span class=\"keyword\">const</span> WindowType&amp; type, <span class=\"keyword\">const</span> WindowId&amp; id, <span class=\"keyword\">void</span>* pParam)</div><div class=\"line\">&#123;</div><div class=\"line\">    boost::lock_guard&lt;boost::mutex&gt; lock(m_mutex);</div><div class=\"line\">    <span class=\"comment\">// already exist this window id </span></div><div class=\"line\">    <span class=\"keyword\">if</span> (m_mapWndCtrl.find(id) != m_mapWndCtrl.end())</div><div class=\"line\">    &#123;  </div><div class=\"line\">        ::ShowWindow(m_mapWndCtrl[id]-&gt;GetHWnd(), SW_SHOWNORMAL);</div><div class=\"line\">        SetForegroundWindow(m_mapWndCtrl[id]-&gt;GetHWnd());   </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">auto</span> itr = CHlWindowFactory::s_mapCreator.find(type);</div><div class=\"line\">    <span class=\"keyword\">if</span> (itr == CHlWindowFactory::s_mapCreator.end())</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// the type does not exist</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;IHlWindowCtrller&gt; pCtrler = itr-&gt;second(id);</div><div class=\"line\">    <span class=\"comment\">/*创建这个UI对象.*/</span></div><div class=\"line\">    pCtrler-&gt;SetWindowMgr(<span class=\"keyword\">this</span>);</div><div class=\"line\">    HWND hWnd = pCtrler-&gt;Open(pParam);</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> != hWnd)</div><div class=\"line\">    &#123;</div><div class=\"line\">        m_mapWndCtrl[id] = pCtrler;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*1.这样在HomepageUI中就可以用上面这个宏，比如ADD_HLWINDOW_CREATOR(HomepageUI);</span></div><div class=\"line\"> *2.调用mgr.OpenHlWindow(L\"HomepageUI\", L\"HomepageUI\");</div><div class=\"line\"> *  mgr是CWindowMgrImpl的实例</div><div class=\"line\"> *  就可以成功创建并打开一个窗口了.*/</div></pre></td></tr></table></figure>\n</li>\n</ul>\n","excerpt":"<p>反射反射，程序员的快乐<br>","more":"</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>从去年7月份进入公司来，一直负责一款局域网设备扫描检测客户端的前端开发工作，技术解决方案是采用轻量级的HTML渲染引擎HTMLayout，并在其的基础上用C++开发了一套类似jQuery的前端框架，用来支持DOM操作，主要功能是将服务器的返回数据和Nmap的扫描结果展现出来，并做好Google Analytics数据采集。<br>这个库是公司一个前辈开发的，前阵子刚好有时间，周末抽了两天研究了一下，真的是写的太好了，尤其是那个创建不同CHlWindow对象的map，从来没有看过这么好的code啊，我们在学校写的都是垃圾啊<br><strong>注：</strong>HTMLayout是一个免费的开源界面库，以DLL方式运行，并提供一些API，其相当于一个轻量级的HTML渲染引擎，可以高效快速的解析和渲染HTML文档。</p>\n<h2 id=\"UML类图\"><a href=\"#UML类图\" class=\"headerlink\" title=\"UML类图\"></a>UML类图</h2><p>这个库的核心思想是采用<strong>策略模式</strong>，首先我们有很多张UI（比如Eula、Homepage等等），从概念上看这些UI具有相同的操作，比如Open、Close、Reload、EventHandle等等，不同的是这些操作对于不同的UI实现起来是不一样的。然后对这些UI抽象出一个<strong>接口</strong>，在窗口管理类CWindowMgrImpl中通过这个接口可以很方便的操作这些UI。<br><strong>策略模式</strong></p>\n<ul>\n<li>概念：策略模式是一种定义一系列算法的模式，所有这些算法完成的都是相同的工作，只是实现不同，比如打折、返利都是一种收费方式。</li>\n<li>应用场景：策略模式就是用来封装算法的，但在实践我们发现可以用它来封装几乎<strong>任何类型的规则</strong>，只要在分析过程中听到需要在不同时间运用不同的业务规则，就可以考虑用策略模式来处理这种变化。</li>\n</ul>\n<p>这个库的UML类图如下： </p>\n<p><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/image/jpg/TmHtmlayout_UML.png\" alt=\"UML类图\"></p>\n<h2 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h2><ul>\n<li>问题的关键是如何在窗口管理类CWindowMgrImpl中创建不同的UI对象（比如HomepageUI对象），用case条件语句来判断似乎不是一个很好的办法，C#中有<strong>反射</strong>的概念，在这里我们借助map来模仿反射，关键代码如下：<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> TmCommon::wstring WindowType;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> CWindowMgrImpl</div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;WindowType, <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;IHlWindowCtrller&gt;&gt; m_mapWndCtrl;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;IHlWindowCtrller&gt; CreateHlWindow</div><div class=\"line\">(<span class=\"keyword\">const</span> TmCommon::wstring&amp; wstrId)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;IHlWindowCtrller&gt;(<span class=\"built_in\">std</span>::make_shared&lt;T&gt;(wstrId));</div><div class=\"line\">    <span class=\"comment\">/*std::shared_ptr称为智能指针，其采用引用计数，是防止内存泄露的神器。</div><div class=\"line\">     *std::make_shared用于创建一个对象。</div><div class=\"line\">     *所以上面这个表达式的意思是创建一个对象，并返回一个指向这个对象的智能指针。</div><div class=\"line\">     */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;IHlWindowCtrller&gt; (*FP_CreateHlWindow)</div><div class=\"line\">(<span class=\"keyword\">const</span> TmCommon::wstring&amp; wstrId);</div><div class=\"line\"><span class=\"comment\">/*定义一个函数指针*/</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;WindowType, FP_CreateHlWindow&gt; HlWindowCreatorMap;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> CHlWindowFactory</div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> CWindowMgrImpl;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">static</span> HlWindowCreatorMap s_mapCreator;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    CHlWindowFactory(<span class=\"keyword\">const</span> WindowType&amp; type, FP_CreateHlWindow)</div><div class=\"line\">    &#123;</div><div class=\"line\">        s_mapCreator[type] = fp;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ADD_HLWINDOW_CREATOR(windowType)\\</div><div class=\"line\">    CHlWindowFactory temp##windowType(L#windowType, CreateHlWindow<span class=\"meta-string\">&lt;windowType&gt;</span>)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">bool</span> CWindowMgrImpl::OpenHlWindow</div><div class=\"line\">(<span class=\"keyword\">const</span> WindowType&amp; type, <span class=\"keyword\">const</span> WindowId&amp; id, <span class=\"keyword\">void</span>* pParam)</div><div class=\"line\">&#123;</div><div class=\"line\">    boost::lock_guard&lt;boost::mutex&gt; lock(m_mutex);</div><div class=\"line\">    <span class=\"comment\">// already exist this window id </span></div><div class=\"line\">    <span class=\"keyword\">if</span> (m_mapWndCtrl.find(id) != m_mapWndCtrl.end())</div><div class=\"line\">    &#123;  </div><div class=\"line\">        ::ShowWindow(m_mapWndCtrl[id]-&gt;GetHWnd(), SW_SHOWNORMAL);</div><div class=\"line\">        SetForegroundWindow(m_mapWndCtrl[id]-&gt;GetHWnd());   </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">auto</span> itr = CHlWindowFactory::s_mapCreator.find(type);</div><div class=\"line\">    <span class=\"keyword\">if</span> (itr == CHlWindowFactory::s_mapCreator.end())</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// the type does not exist</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;IHlWindowCtrller&gt; pCtrler = itr-&gt;second(id);</div><div class=\"line\">    <span class=\"comment\">/*创建这个UI对象.*/</span></div><div class=\"line\">    pCtrler-&gt;SetWindowMgr(<span class=\"keyword\">this</span>);</div><div class=\"line\">    HWND hWnd = pCtrler-&gt;Open(pParam);</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> != hWnd)</div><div class=\"line\">    &#123;</div><div class=\"line\">        m_mapWndCtrl[id] = pCtrler;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*1.这样在HomepageUI中就可以用上面这个宏，比如ADD_HLWINDOW_CREATOR(HomepageUI);</div><div class=\"line\"> *2.调用mgr.OpenHlWindow(L\"HomepageUI\", L\"HomepageUI\");</div><div class=\"line\"> *  mgr是CWindowMgrImpl的实例</div><div class=\"line\"> *  就可以成功创建并打开一个窗口了.*/</span></div></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"CSS零碎笔记","description":"CSS的知识总的来说比较杂，这里记录一下工作用到的东西，方便以后查看，将持续更新...","toc":true,"date":"2016-06-03T02:36:28.000Z","_content":"CSS的知识总的来说比较杂，这里记录一下工作用到的东西，方便以后查看，将持续更新...\n<!--more-->\n### 四个伪类选择符\n - E:link，设置超链接a在**未被访问前**的样式。 \n - E:visited，设置超链接a在其链接地址**已被访问过**时的样式。 \n - E:hover，设置鼠标**悬停在**元素上时的样式。 \n - E:active，设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式。 \n这四个伪类的前后顺序在某些情况下是很重要的。\n\n### 盒模型\n![](http://7xtj85.com1.z0.glb.clouddn.com/%E7%9B%92%E6%A8%A1%E5%9E%8B.png)\n - Content(内容)： 盒子的内容，显示文本和图像，CSS内定义的`width`和`height`属性，只是设置内容区域的宽度和高度。。\n - Margin(外边距)： 外边距是透明的，其决定着不同盒子之间的距离，而两个元素之间间距到底为多少，取两者中**最大的**margin。\n - **实际高度** = 元素的内容高度 + `padding-top` + `padding-bottom` + `border-top` + `border-bottom`，margin是不算在内的。\n元素的实际宽度计算方法同上。\n\n### CSS布局模型\n - 流动模型：Flow，是默认的网页布局模式。\n块状元素独占一行，宽度为100%；内联元素在所处的包含元素内从左到右显示。\n - 浮动模型：Float，不让块级元素独占一行。\n - 层模型：Layer，CSS定义了一组定位（position）属性来支持层布局模型。\n\n### position定位属性\n - 默认值`position：static`\n**没有定位**，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。\n - 绝对定位`position:absolute`\n相对于其**最接近**的一个**具有定位属性**的父包含块进行定位。如果不存在这样的包含块，则相对于`body`元素。\n - 相对定位`position：relative`\n相对于元素**本身正常位置**进行定位，其偏移前后，父包含块内其他元素的位置保持不变。（正常位置即按static方式确定的位置）\n - 固定定位`position：fixed`\n位置固定不变，其是绝对定位的特殊情况，其相对于浏览器窗口定位，它的位置不会随浏览器窗口的滚动条滚动而变化。\n\n### 隐性改变display类型\n有一个有趣的现象就是当为元素（不论之前是什么类型元素，display:none 除外）设置以下 3 个句之一：\n1. position : absolute \n2. float : left 或 float:right \n3. overflow:hidden/scroll/auto\n简单来说，只要html代码中出现以上三句之一，元素的display显示类型就会自动变为以 display:inline-block（内联块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。\n另外说到包裹性，在这里面的鼻祖应该算是diaplay:inline-block;其他的像overflow，position:absolute,float这几个产生包裹性的原因，本质应该都是因为他们使Dom元素具有了类似inline-block的性质，所以，凡是设置了像display:inline-block或者overflow:hidden/scroll/auto或者position:absolute或者float:left/right这几个属性时，他们`具有的包裹性都可以清除他们子元素浮动造成的影响`。\n\n### 居中\n- 水平居中：定宽+左右margin为auto\n- 垂直居中：height和line-height相等\n- text-align：center，设置文本水平居中\n\n### 参考资料\n[CSS参考手册](http://7xtj85.com1.z0.glb.clouddn.com/CSS%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.chm)\n\n","source":"_posts/CSS零碎笔记.md","raw":"---\ntitle: CSS零碎笔记\ncategories: CSS\ntags: [CSS, 前端开发]\ndescription: CSS的知识总的来说比较杂，这里记录一下工作用到的东西，方便以后查看，将持续更新...\ntoc: true\ndate: 2016-06-03 10:36:28\n---\nCSS的知识总的来说比较杂，这里记录一下工作用到的东西，方便以后查看，将持续更新...\n<!--more-->\n### 四个伪类选择符\n - E:link，设置超链接a在**未被访问前**的样式。 \n - E:visited，设置超链接a在其链接地址**已被访问过**时的样式。 \n - E:hover，设置鼠标**悬停在**元素上时的样式。 \n - E:active，设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式。 \n这四个伪类的前后顺序在某些情况下是很重要的。\n\n### 盒模型\n![](http://7xtj85.com1.z0.glb.clouddn.com/%E7%9B%92%E6%A8%A1%E5%9E%8B.png)\n - Content(内容)： 盒子的内容，显示文本和图像，CSS内定义的`width`和`height`属性，只是设置内容区域的宽度和高度。。\n - Margin(外边距)： 外边距是透明的，其决定着不同盒子之间的距离，而两个元素之间间距到底为多少，取两者中**最大的**margin。\n - **实际高度** = 元素的内容高度 + `padding-top` + `padding-bottom` + `border-top` + `border-bottom`，margin是不算在内的。\n元素的实际宽度计算方法同上。\n\n### CSS布局模型\n - 流动模型：Flow，是默认的网页布局模式。\n块状元素独占一行，宽度为100%；内联元素在所处的包含元素内从左到右显示。\n - 浮动模型：Float，不让块级元素独占一行。\n - 层模型：Layer，CSS定义了一组定位（position）属性来支持层布局模型。\n\n### position定位属性\n - 默认值`position：static`\n**没有定位**，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。\n - 绝对定位`position:absolute`\n相对于其**最接近**的一个**具有定位属性**的父包含块进行定位。如果不存在这样的包含块，则相对于`body`元素。\n - 相对定位`position：relative`\n相对于元素**本身正常位置**进行定位，其偏移前后，父包含块内其他元素的位置保持不变。（正常位置即按static方式确定的位置）\n - 固定定位`position：fixed`\n位置固定不变，其是绝对定位的特殊情况，其相对于浏览器窗口定位，它的位置不会随浏览器窗口的滚动条滚动而变化。\n\n### 隐性改变display类型\n有一个有趣的现象就是当为元素（不论之前是什么类型元素，display:none 除外）设置以下 3 个句之一：\n1. position : absolute \n2. float : left 或 float:right \n3. overflow:hidden/scroll/auto\n简单来说，只要html代码中出现以上三句之一，元素的display显示类型就会自动变为以 display:inline-block（内联块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。\n另外说到包裹性，在这里面的鼻祖应该算是diaplay:inline-block;其他的像overflow，position:absolute,float这几个产生包裹性的原因，本质应该都是因为他们使Dom元素具有了类似inline-block的性质，所以，凡是设置了像display:inline-block或者overflow:hidden/scroll/auto或者position:absolute或者float:left/right这几个属性时，他们`具有的包裹性都可以清除他们子元素浮动造成的影响`。\n\n### 居中\n- 水平居中：定宽+左右margin为auto\n- 垂直居中：height和line-height相等\n- text-align：center，设置文本水平居中\n\n### 参考资料\n[CSS参考手册](http://7xtj85.com1.z0.glb.clouddn.com/CSS%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.chm)\n\n","slug":"CSS零碎笔记","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrop0002526rq7jjrgb0","content":"<p>CSS的知识总的来说比较杂，这里记录一下工作用到的东西，方便以后查看，将持续更新…<br><a id=\"more\"></a></p>\n<h3 id=\"四个伪类选择符\"><a href=\"#四个伪类选择符\" class=\"headerlink\" title=\"四个伪类选择符\"></a>四个伪类选择符</h3><ul>\n<li>E:link，设置超链接a在<strong>未被访问前</strong>的样式。 </li>\n<li>E:visited，设置超链接a在其链接地址<strong>已被访问过</strong>时的样式。 </li>\n<li>E:hover，设置鼠标<strong>悬停在</strong>元素上时的样式。 </li>\n<li>E:active，设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式。<br>这四个伪类的前后顺序在某些情况下是很重要的。</li>\n</ul>\n<h3 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a>盒模型</h3><p><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/%E7%9B%92%E6%A8%A1%E5%9E%8B.png\" alt=\"\"></p>\n<ul>\n<li>Content(内容)： 盒子的内容，显示文本和图像，CSS内定义的<code>width</code>和<code>height</code>属性，只是设置内容区域的宽度和高度。。</li>\n<li>Margin(外边距)： 外边距是透明的，其决定着不同盒子之间的距离，而两个元素之间间距到底为多少，取两者中<strong>最大的</strong>margin。</li>\n<li><strong>实际高度</strong> = 元素的内容高度 + <code>padding-top</code> + <code>padding-bottom</code> + <code>border-top</code> + <code>border-bottom</code>，margin是不算在内的。<br>元素的实际宽度计算方法同上。</li>\n</ul>\n<h3 id=\"CSS布局模型\"><a href=\"#CSS布局模型\" class=\"headerlink\" title=\"CSS布局模型\"></a>CSS布局模型</h3><ul>\n<li>流动模型：Flow，是默认的网页布局模式。<br>块状元素独占一行，宽度为100%；内联元素在所处的包含元素内从左到右显示。</li>\n<li>浮动模型：Float，不让块级元素独占一行。</li>\n<li>层模型：Layer，CSS定义了一组定位（position）属性来支持层布局模型。</li>\n</ul>\n<h3 id=\"position定位属性\"><a href=\"#position定位属性\" class=\"headerlink\" title=\"position定位属性\"></a>position定位属性</h3><ul>\n<li>默认值<code>position：static</code><br><strong>没有定位</strong>，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</li>\n<li>绝对定位<code>position:absolute</code><br>相对于其<strong>最接近</strong>的一个<strong>具有定位属性</strong>的父包含块进行定位。如果不存在这样的包含块，则相对于<code>body</code>元素。</li>\n<li>相对定位<code>position：relative</code><br>相对于元素<strong>本身正常位置</strong>进行定位，其偏移前后，父包含块内其他元素的位置保持不变。（正常位置即按static方式确定的位置）</li>\n<li>固定定位<code>position：fixed</code><br>位置固定不变，其是绝对定位的特殊情况，其相对于浏览器窗口定位，它的位置不会随浏览器窗口的滚动条滚动而变化。</li>\n</ul>\n<h3 id=\"隐性改变display类型\"><a href=\"#隐性改变display类型\" class=\"headerlink\" title=\"隐性改变display类型\"></a>隐性改变display类型</h3><p>有一个有趣的现象就是当为元素（不论之前是什么类型元素，display:none 除外）设置以下 3 个句之一：</p>\n<ol>\n<li>position : absolute </li>\n<li>float : left 或 float:right </li>\n<li>overflow:hidden/scroll/auto<br>简单来说，只要html代码中出现以上三句之一，元素的display显示类型就会自动变为以 display:inline-block（内联块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。<br>另外说到包裹性，在这里面的鼻祖应该算是diaplay:inline-block;其他的像overflow，position:absolute,float这几个产生包裹性的原因，本质应该都是因为他们使Dom元素具有了类似inline-block的性质，所以，凡是设置了像display:inline-block或者overflow:hidden/scroll/auto或者position:absolute或者float:left/right这几个属性时，他们<code>具有的包裹性都可以清除他们子元素浮动造成的影响</code>。</li>\n</ol>\n<h3 id=\"居中\"><a href=\"#居中\" class=\"headerlink\" title=\"居中\"></a>居中</h3><ul>\n<li>水平居中：定宽+左右margin为auto</li>\n<li>垂直居中：height和line-height相等</li>\n<li>text-align：center，设置文本水平居中</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://7xtj85.com1.z0.glb.clouddn.com/CSS%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.chm\" target=\"_blank\" rel=\"external\">CSS参考手册</a></p>\n","excerpt":"<p>CSS的知识总的来说比较杂，这里记录一下工作用到的东西，方便以后查看，将持续更新…<br>","more":"</p>\n<h3 id=\"四个伪类选择符\"><a href=\"#四个伪类选择符\" class=\"headerlink\" title=\"四个伪类选择符\"></a>四个伪类选择符</h3><ul>\n<li>E:link，设置超链接a在<strong>未被访问前</strong>的样式。 </li>\n<li>E:visited，设置超链接a在其链接地址<strong>已被访问过</strong>时的样式。 </li>\n<li>E:hover，设置鼠标<strong>悬停在</strong>元素上时的样式。 </li>\n<li>E:active，设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式。<br>这四个伪类的前后顺序在某些情况下是很重要的。</li>\n</ul>\n<h3 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a>盒模型</h3><p><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/%E7%9B%92%E6%A8%A1%E5%9E%8B.png\" alt=\"\"></p>\n<ul>\n<li>Content(内容)： 盒子的内容，显示文本和图像，CSS内定义的<code>width</code>和<code>height</code>属性，只是设置内容区域的宽度和高度。。</li>\n<li>Margin(外边距)： 外边距是透明的，其决定着不同盒子之间的距离，而两个元素之间间距到底为多少，取两者中<strong>最大的</strong>margin。</li>\n<li><strong>实际高度</strong> = 元素的内容高度 + <code>padding-top</code> + <code>padding-bottom</code> + <code>border-top</code> + <code>border-bottom</code>，margin是不算在内的。<br>元素的实际宽度计算方法同上。</li>\n</ul>\n<h3 id=\"CSS布局模型\"><a href=\"#CSS布局模型\" class=\"headerlink\" title=\"CSS布局模型\"></a>CSS布局模型</h3><ul>\n<li>流动模型：Flow，是默认的网页布局模式。<br>块状元素独占一行，宽度为100%；内联元素在所处的包含元素内从左到右显示。</li>\n<li>浮动模型：Float，不让块级元素独占一行。</li>\n<li>层模型：Layer，CSS定义了一组定位（position）属性来支持层布局模型。</li>\n</ul>\n<h3 id=\"position定位属性\"><a href=\"#position定位属性\" class=\"headerlink\" title=\"position定位属性\"></a>position定位属性</h3><ul>\n<li>默认值<code>position：static</code><br><strong>没有定位</strong>，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</li>\n<li>绝对定位<code>position:absolute</code><br>相对于其<strong>最接近</strong>的一个<strong>具有定位属性</strong>的父包含块进行定位。如果不存在这样的包含块，则相对于<code>body</code>元素。</li>\n<li>相对定位<code>position：relative</code><br>相对于元素<strong>本身正常位置</strong>进行定位，其偏移前后，父包含块内其他元素的位置保持不变。（正常位置即按static方式确定的位置）</li>\n<li>固定定位<code>position：fixed</code><br>位置固定不变，其是绝对定位的特殊情况，其相对于浏览器窗口定位，它的位置不会随浏览器窗口的滚动条滚动而变化。</li>\n</ul>\n<h3 id=\"隐性改变display类型\"><a href=\"#隐性改变display类型\" class=\"headerlink\" title=\"隐性改变display类型\"></a>隐性改变display类型</h3><p>有一个有趣的现象就是当为元素（不论之前是什么类型元素，display:none 除外）设置以下 3 个句之一：</p>\n<ol>\n<li>position : absolute </li>\n<li>float : left 或 float:right </li>\n<li>overflow:hidden/scroll/auto<br>简单来说，只要html代码中出现以上三句之一，元素的display显示类型就会自动变为以 display:inline-block（内联块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。<br>另外说到包裹性，在这里面的鼻祖应该算是diaplay:inline-block;其他的像overflow，position:absolute,float这几个产生包裹性的原因，本质应该都是因为他们使Dom元素具有了类似inline-block的性质，所以，凡是设置了像display:inline-block或者overflow:hidden/scroll/auto或者position:absolute或者float:left/right这几个属性时，他们<code>具有的包裹性都可以清除他们子元素浮动造成的影响</code>。</li>\n</ol>\n<h3 id=\"居中\"><a href=\"#居中\" class=\"headerlink\" title=\"居中\"></a>居中</h3><ul>\n<li>水平居中：定宽+左右margin为auto</li>\n<li>垂直居中：height和line-height相等</li>\n<li>text-align：center，设置文本水平居中</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://7xtj85.com1.z0.glb.clouddn.com/CSS%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.chm\">CSS参考手册</a></p>"},{"title":"JS中的Function类型","description":"在JS中一切都是对象","toc":true,"date":"2016-05-25T11:09:56.000Z","_content":"在JS中一切都是对象\n<!--more-->\n**函数是对象，函数名是指针：**在JS中函数实际上是对象，每个函数都是Function类型的实例,而函数名其实就是一个**变量**\n\n## 函数声明与函数表达式\n```JavaScript\n//函数声明\nfunction sum(num1, num2){\n    return num1 + num2;\n}\n//函数表达式\nvar f = function(num1, num2){\n    return num1 + num2;\n}\n```\n对于函数声明，JS会通过一个**声明提升**的过程，将函数名和函数引用添加到执行环境中。\n而对于函数表达式则必须等到解释器执行到所在代码行时，才会真正的被解释执行。\n\n## 作为值的函数\n因为JS中的**函数名本身就是变量**，所以函数也可以作为值来使用。\n即不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回\n\n## 函数的内部属性\n- arguments对象\n其主要用途是传递参数，但其还有一个名叫**callee(被调用者)**的属性，指向拥有这个arguments对象的函数\n\n- this\n见文章：JS中的this\n\n- caller\n指向调用当前函数的函数，和this不一样\n\n## 函数属性和方法\n- length\n其表示函数希望接收到的命名参数的个数\n- prototype\n原型，在此不做过多介绍\n\n- apply()和call()\n这两个方法的用途都是在**特定的作用域**中调用函数，实际上等于设置函数体内的**this值**。\n二者的作用相同，区别**仅仅在于**接收参数的方式不同，二者的第一个参数都是要指定的作用域，\n但第二个参数，apply是数组，而call必须逐个列出\n```JavaScript\nfunction sum(num1, num2){\n    return num1 + num2;\n}\nvar obj = {};\nsum.apply(obj, [10, 10]);\nsum.call(obj, 10, 10);\n```\n\n- bind()\n其会创建一个函数实例，实例的this会被绑定到传给bind函数的值\n```JavaScript\nfunction sayColor(){\n    console.log(this.color);\n}\nvar obj = {color:'blue'};\nvar objectSayColor = sayColor.bind(obj);\nobjectSayColor();\n//输出blue\n```\n\n## 参考资料\n[JavaScript高级程序设计](https://book.douban.com/subject/10546125/)\n","source":"_posts/JS中的Function引用类型.md","raw":"---\ntitle: JS中的Function类型\ncategories: JavaScript\ntags: [JavaScript, 函数, 前端开发]\ndescription: 在JS中一切都是对象\ntoc: true\ndate: 2016-05-25 19:09:56\n---\n在JS中一切都是对象\n<!--more-->\n**函数是对象，函数名是指针：**在JS中函数实际上是对象，每个函数都是Function类型的实例,而函数名其实就是一个**变量**\n\n## 函数声明与函数表达式\n```JavaScript\n//函数声明\nfunction sum(num1, num2){\n    return num1 + num2;\n}\n//函数表达式\nvar f = function(num1, num2){\n    return num1 + num2;\n}\n```\n对于函数声明，JS会通过一个**声明提升**的过程，将函数名和函数引用添加到执行环境中。\n而对于函数表达式则必须等到解释器执行到所在代码行时，才会真正的被解释执行。\n\n## 作为值的函数\n因为JS中的**函数名本身就是变量**，所以函数也可以作为值来使用。\n即不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回\n\n## 函数的内部属性\n- arguments对象\n其主要用途是传递参数，但其还有一个名叫**callee(被调用者)**的属性，指向拥有这个arguments对象的函数\n\n- this\n见文章：JS中的this\n\n- caller\n指向调用当前函数的函数，和this不一样\n\n## 函数属性和方法\n- length\n其表示函数希望接收到的命名参数的个数\n- prototype\n原型，在此不做过多介绍\n\n- apply()和call()\n这两个方法的用途都是在**特定的作用域**中调用函数，实际上等于设置函数体内的**this值**。\n二者的作用相同，区别**仅仅在于**接收参数的方式不同，二者的第一个参数都是要指定的作用域，\n但第二个参数，apply是数组，而call必须逐个列出\n```JavaScript\nfunction sum(num1, num2){\n    return num1 + num2;\n}\nvar obj = {};\nsum.apply(obj, [10, 10]);\nsum.call(obj, 10, 10);\n```\n\n- bind()\n其会创建一个函数实例，实例的this会被绑定到传给bind函数的值\n```JavaScript\nfunction sayColor(){\n    console.log(this.color);\n}\nvar obj = {color:'blue'};\nvar objectSayColor = sayColor.bind(obj);\nobjectSayColor();\n//输出blue\n```\n\n## 参考资料\n[JavaScript高级程序设计](https://book.douban.com/subject/10546125/)\n","slug":"JS中的Function引用类型","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqroy0006526rrle8nocg","content":"<p>在JS中一切都是对象<br><a id=\"more\"></a><br><strong>函数是对象，函数名是指针：</strong>在JS中函数实际上是对象，每个函数都是Function类型的实例,而函数名其实就是一个<strong>变量</strong></p>\n<h2 id=\"函数声明与函数表达式\"><a href=\"#函数声明与函数表达式\" class=\"headerlink\" title=\"函数声明与函数表达式\"></a>函数声明与函数表达式</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//函数声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">num1, num2</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> num1 + num2;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//函数表达式</span></div><div class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num1, num2</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> num1 + num2;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于函数声明，JS会通过一个<strong>声明提升</strong>的过程，将函数名和函数引用添加到执行环境中。<br>而对于函数表达式则必须等到解释器执行到所在代码行时，才会真正的被解释执行。</p>\n<h2 id=\"作为值的函数\"><a href=\"#作为值的函数\" class=\"headerlink\" title=\"作为值的函数\"></a>作为值的函数</h2><p>因为JS中的<strong>函数名本身就是变量</strong>，所以函数也可以作为值来使用。<br>即不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回</p>\n<h2 id=\"函数的内部属性\"><a href=\"#函数的内部属性\" class=\"headerlink\" title=\"函数的内部属性\"></a>函数的内部属性</h2><ul>\n<li><p>arguments对象<br>其主要用途是传递参数，但其还有一个名叫<strong>callee(被调用者)</strong>的属性，指向拥有这个arguments对象的函数</p>\n</li>\n<li><p>this<br>见文章：JS中的this</p>\n</li>\n<li><p>caller<br>指向调用当前函数的函数，和this不一样</p>\n</li>\n</ul>\n<h2 id=\"函数属性和方法\"><a href=\"#函数属性和方法\" class=\"headerlink\" title=\"函数属性和方法\"></a>函数属性和方法</h2><ul>\n<li>length<br>其表示函数希望接收到的命名参数的个数</li>\n<li><p>prototype<br>原型，在此不做过多介绍</p>\n</li>\n<li><p>apply()和call()<br>这两个方法的用途都是在<strong>特定的作用域</strong>中调用函数，实际上等于设置函数体内的<strong>this值</strong>。<br>二者的作用相同，区别<strong>仅仅在于</strong>接收参数的方式不同，二者的第一个参数都是要指定的作用域，<br>但第二个参数，apply是数组，而call必须逐个列出</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">num1, num2</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> num1 + num2;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</div><div class=\"line\">sum.apply(obj, [<span class=\"number\">10</span>, <span class=\"number\">10</span>]);</div><div class=\"line\">sum.call(obj, <span class=\"number\">10</span>, <span class=\"number\">10</span>);</div></pre></td></tr></table></figure>\n</li>\n<li><p>bind()<br>其会创建一个函数实例，实例的this会被绑定到传给bind函数的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayColor</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;color:<span class=\"string\">'blue'</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> objectSayColor = sayColor.bind(obj);</div><div class=\"line\">objectSayColor();</div><div class=\"line\"><span class=\"comment\">//输出blue</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://book.douban.com/subject/10546125/\" target=\"_blank\" rel=\"external\">JavaScript高级程序设计</a></p>\n","excerpt":"<p>在JS中一切都是对象<br>","more":"<br><strong>函数是对象，函数名是指针：</strong>在JS中函数实际上是对象，每个函数都是Function类型的实例,而函数名其实就是一个<strong>变量</strong></p>\n<h2 id=\"函数声明与函数表达式\"><a href=\"#函数声明与函数表达式\" class=\"headerlink\" title=\"函数声明与函数表达式\"></a>函数声明与函数表达式</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//函数声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">num1, num2</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> num1 + num2;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//函数表达式</span></div><div class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num1, num2</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> num1 + num2;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于函数声明，JS会通过一个<strong>声明提升</strong>的过程，将函数名和函数引用添加到执行环境中。<br>而对于函数表达式则必须等到解释器执行到所在代码行时，才会真正的被解释执行。</p>\n<h2 id=\"作为值的函数\"><a href=\"#作为值的函数\" class=\"headerlink\" title=\"作为值的函数\"></a>作为值的函数</h2><p>因为JS中的<strong>函数名本身就是变量</strong>，所以函数也可以作为值来使用。<br>即不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回</p>\n<h2 id=\"函数的内部属性\"><a href=\"#函数的内部属性\" class=\"headerlink\" title=\"函数的内部属性\"></a>函数的内部属性</h2><ul>\n<li><p>arguments对象<br>其主要用途是传递参数，但其还有一个名叫<strong>callee(被调用者)</strong>的属性，指向拥有这个arguments对象的函数</p>\n</li>\n<li><p>this<br>见文章：JS中的this</p>\n</li>\n<li><p>caller<br>指向调用当前函数的函数，和this不一样</p>\n</li>\n</ul>\n<h2 id=\"函数属性和方法\"><a href=\"#函数属性和方法\" class=\"headerlink\" title=\"函数属性和方法\"></a>函数属性和方法</h2><ul>\n<li>length<br>其表示函数希望接收到的命名参数的个数</li>\n<li><p>prototype<br>原型，在此不做过多介绍</p>\n</li>\n<li><p>apply()和call()<br>这两个方法的用途都是在<strong>特定的作用域</strong>中调用函数，实际上等于设置函数体内的<strong>this值</strong>。<br>二者的作用相同，区别<strong>仅仅在于</strong>接收参数的方式不同，二者的第一个参数都是要指定的作用域，<br>但第二个参数，apply是数组，而call必须逐个列出</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">num1, num2</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> num1 + num2;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</div><div class=\"line\">sum.apply(obj, [<span class=\"number\">10</span>, <span class=\"number\">10</span>]);</div><div class=\"line\">sum.call(obj, <span class=\"number\">10</span>, <span class=\"number\">10</span>);</div></pre></td></tr></table></figure>\n</li>\n<li><p>bind()<br>其会创建一个函数实例，实例的this会被绑定到传给bind函数的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayColor</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;color:<span class=\"string\">'blue'</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> objectSayColor = sayColor.bind(obj);</div><div class=\"line\">objectSayColor();</div><div class=\"line\"><span class=\"comment\">//输出blue</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://book.douban.com/subject/10546125/\">JavaScript高级程序设计</a></p>"},{"title":"JS中的this","description":"简单介绍一下this","toc":true,"date":"2016-05-28T14:00:13.000Z","_content":"<!--more-->\n## 一些总结\n- 和C++、Java类似，this指向当前正在调用该方法的对象本身；\n- this是执行环境的一个重要属性，其指向函数赖以执行的环境**对象**（注意是一个对象，而且是一个**普通对象**，而不是一个执行环境）；\n- this的值在进入上下文的时候才会被确定；\n- this的值**直接受**函数调用方式的影响，其是由激活上下文代码的调用者来提供的，指向调用时所在函数所绑定的对象。\n\n## 一个例子\n```JavaScript\nvar obj = {  \n    context: \"object\",\n    method: function () {\n        var context = \"function\";\n        console.log(this.context); \n        /*this指向当前正在调用该方法的对象本身*/\n    }\n}\nobj.method();\n//结果为object，而不是function\n```\n","source":"_posts/JS中的this.md","raw":"---\ntitle: JS中的this\ncategories: JavaScript\ntags: [JavaScript, this, 前端开发]\ndescription: 简单介绍一下this\ntoc: true\ndate: 2016-05-28 22:00:13\n---\n<!--more-->\n## 一些总结\n- 和C++、Java类似，this指向当前正在调用该方法的对象本身；\n- this是执行环境的一个重要属性，其指向函数赖以执行的环境**对象**（注意是一个对象，而且是一个**普通对象**，而不是一个执行环境）；\n- this的值在进入上下文的时候才会被确定；\n- this的值**直接受**函数调用方式的影响，其是由激活上下文代码的调用者来提供的，指向调用时所在函数所绑定的对象。\n\n## 一个例子\n```JavaScript\nvar obj = {  \n    context: \"object\",\n    method: function () {\n        var context = \"function\";\n        console.log(this.context); \n        /*this指向当前正在调用该方法的对象本身*/\n    }\n}\nobj.method();\n//结果为object，而不是function\n```\n","slug":"JS中的this","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrp00007526r42vzjrpk","content":"<a id=\"more\"></a>\n<h2 id=\"一些总结\"><a href=\"#一些总结\" class=\"headerlink\" title=\"一些总结\"></a>一些总结</h2><ul>\n<li>和C++、Java类似，this指向当前正在调用该方法的对象本身；</li>\n<li>this是执行环境的一个重要属性，其指向函数赖以执行的环境<strong>对象</strong>（注意是一个对象，而且是一个<strong>普通对象</strong>，而不是一个执行环境）；</li>\n<li>this的值在进入上下文的时候才会被确定；</li>\n<li>this的值<strong>直接受</strong>函数调用方式的影响，其是由激活上下文代码的调用者来提供的，指向调用时所在函数所绑定的对象。</li>\n</ul>\n<h2 id=\"一个例子\"><a href=\"#一个例子\" class=\"headerlink\" title=\"一个例子\"></a>一个例子</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;  </div><div class=\"line\">    context: <span class=\"string\">\"object\"</span>,</div><div class=\"line\">    method: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"string\">\"function\"</span>;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.context); </div><div class=\"line\">        <span class=\"comment\">/*this指向当前正在调用该方法的对象本身*/</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">obj.method();</div><div class=\"line\"><span class=\"comment\">//结果为object，而不是function</span></div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"一些总结\"><a href=\"#一些总结\" class=\"headerlink\" title=\"一些总结\"></a>一些总结</h2><ul>\n<li>和C++、Java类似，this指向当前正在调用该方法的对象本身；</li>\n<li>this是执行环境的一个重要属性，其指向函数赖以执行的环境<strong>对象</strong>（注意是一个对象，而且是一个<strong>普通对象</strong>，而不是一个执行环境）；</li>\n<li>this的值在进入上下文的时候才会被确定；</li>\n<li>this的值<strong>直接受</strong>函数调用方式的影响，其是由激活上下文代码的调用者来提供的，指向调用时所在函数所绑定的对象。</li>\n</ul>\n<h2 id=\"一个例子\"><a href=\"#一个例子\" class=\"headerlink\" title=\"一个例子\"></a>一个例子</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;  </div><div class=\"line\">    context: <span class=\"string\">\"object\"</span>,</div><div class=\"line\">    method: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"string\">\"function\"</span>;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.context); </div><div class=\"line\">        <span class=\"comment\">/*this指向当前正在调用该方法的对象本身*/</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">obj.method();</div><div class=\"line\"><span class=\"comment\">//结果为object，而不是function</span></div></pre></td></tr></table></figure>"},{"title":"JS中的寄生组合式继承","description":"寄生组合式继承是JS中最完美的继承方式","toc":true,"date":"2016-05-27T14:10:46.000Z","_content":"寄生组合式继承，集寄生式继承和组合式继承的优点于一身，是JS中最完美的继承方式。\n<!--more-->\n## 原型式继承\n- 实现方式\n```JavaScript\nSubType.prototype = new SuperType();\n//SubType是子类，SuperType是超类\n//将超类的一个实例赋给子类构造函数的原型\n```\n- 存在问题\n子类对象将共享所有继承的属性和方法，一个子类实例更改一个继承的属性，这将会影响到所有的子类实例\n\n## 组合继承\n- 实现方式\n```JavaScript\nfunction SubType(){\n    SuperType.call(this);\n    /*在子类构造函数的内部调用超类的构造函数，\n    这样就使的子类的每个实例都具有自己的属性，\n    解决了原型式继承带来的问题*/\n}\nSubType.prototype = new SuperType();\n```\n- 存在问题\n组合继承最大的问题就是在创建子类实例时，无论什么情况下，\n都会调用**两次**超类的构造函数，这将会导致效率低下。\n而且子类的原型对象和其实例会中有重复的属性，\n解决方法是：不必为了指定子类的原型而调用超类的构造函数，\n我们所需的不过就是超类原型对象的一个副本而已。\n\n## 寄生组合式继承\n- 实现方式\n```JavaScript\nfunction SubType(){\n    SuperType.call(this);\n    // 这和组合继承保持一样\n}\nfunction Extend(subType, superType){\n    function FTemp(){};\n    FTemp.prototype = superType.prototype;\n    var temp = new FTemp();\n    //创建一个临时中间对象\n    temp.constructor = subType;\n    subType.prototype = temp;\n}\nExtend(SubType, SuperType);\n```\n- 开发人员普遍认为寄生组合式继承是最理想的继承方式。\n\n## 一个寄生组合式继承的完整例子\n```JavaScript\nfunction SuperType(name){\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\nSuperType.prototype.sayName = function(){\n    console.log(this.name);\n}\n\nfunction SubType(name, age){\n    // 继承属性\n    SuperType.call(this, name);\n    this.age = age;\n}\n//继承方法\nSubType.prototype = new SuperType();\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = function(){\n    console.log(this.age);\n}\n\nvar instance1 = new SubType('bruce', 23);\ninstance1.colors.push('black');\nconsole.log(instance1.colors);\ninstance1.sayAge()\ninstance1.sayName();\n\nvar instance2 = new SubType('mike', 28);\nconsole.log(instance2.colors);\ninstance1.sayAge()\ninstance1.sayName();\n\n/*\n以上是组合式继承。\n组合继承最大的问题就是在创建子类实例时，无论什么情况下，\n都会调用**两次**超类的构造函数，这将会导致效率低下。\n而且子类的原型对象和其实例会中有重复的属性，\n解决方法是：不必为了指定子类的原型而调用超类的构造函数，\n我们所需的不过就是超类原型对象的一个副本而已。\n修改方法如下：\n*/\nfunction Extend(subType, superType){\n    function FTemp(){};\n    FTemp.prototype = superType.prototype;\n    var temp = new FTemp();\n    //创建一个临时中间对象\n    temp.constructor = subType;\n    subType.prototype = temp;\n}\nExtend(SubType, SuperType);\nSubType.prototype.sayAge = function(){\n    console.log(this.age);\n}\nvar instance3 = new SubType('cater', 25);\nconsole.log(instance3.colors);\ninstance3.sayAge()\ninstance3.sayName();\n```\n\n## 参考资料\n[JavaScript高级程序设计](https://book.douban.com/subject/10546125/)\n","source":"_posts/JS中的寄生组合式继承.md","raw":"---\ntitle: JS中的寄生组合式继承\ncategories: JavaScript\ntags: [JavaScript, Prototype, 前端开发]\ndescription: 寄生组合式继承是JS中最完美的继承方式\ntoc: true\ndate: 2016-05-27 22:10:46\n---\n寄生组合式继承，集寄生式继承和组合式继承的优点于一身，是JS中最完美的继承方式。\n<!--more-->\n## 原型式继承\n- 实现方式\n```JavaScript\nSubType.prototype = new SuperType();\n//SubType是子类，SuperType是超类\n//将超类的一个实例赋给子类构造函数的原型\n```\n- 存在问题\n子类对象将共享所有继承的属性和方法，一个子类实例更改一个继承的属性，这将会影响到所有的子类实例\n\n## 组合继承\n- 实现方式\n```JavaScript\nfunction SubType(){\n    SuperType.call(this);\n    /*在子类构造函数的内部调用超类的构造函数，\n    这样就使的子类的每个实例都具有自己的属性，\n    解决了原型式继承带来的问题*/\n}\nSubType.prototype = new SuperType();\n```\n- 存在问题\n组合继承最大的问题就是在创建子类实例时，无论什么情况下，\n都会调用**两次**超类的构造函数，这将会导致效率低下。\n而且子类的原型对象和其实例会中有重复的属性，\n解决方法是：不必为了指定子类的原型而调用超类的构造函数，\n我们所需的不过就是超类原型对象的一个副本而已。\n\n## 寄生组合式继承\n- 实现方式\n```JavaScript\nfunction SubType(){\n    SuperType.call(this);\n    // 这和组合继承保持一样\n}\nfunction Extend(subType, superType){\n    function FTemp(){};\n    FTemp.prototype = superType.prototype;\n    var temp = new FTemp();\n    //创建一个临时中间对象\n    temp.constructor = subType;\n    subType.prototype = temp;\n}\nExtend(SubType, SuperType);\n```\n- 开发人员普遍认为寄生组合式继承是最理想的继承方式。\n\n## 一个寄生组合式继承的完整例子\n```JavaScript\nfunction SuperType(name){\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\nSuperType.prototype.sayName = function(){\n    console.log(this.name);\n}\n\nfunction SubType(name, age){\n    // 继承属性\n    SuperType.call(this, name);\n    this.age = age;\n}\n//继承方法\nSubType.prototype = new SuperType();\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = function(){\n    console.log(this.age);\n}\n\nvar instance1 = new SubType('bruce', 23);\ninstance1.colors.push('black');\nconsole.log(instance1.colors);\ninstance1.sayAge()\ninstance1.sayName();\n\nvar instance2 = new SubType('mike', 28);\nconsole.log(instance2.colors);\ninstance1.sayAge()\ninstance1.sayName();\n\n/*\n以上是组合式继承。\n组合继承最大的问题就是在创建子类实例时，无论什么情况下，\n都会调用**两次**超类的构造函数，这将会导致效率低下。\n而且子类的原型对象和其实例会中有重复的属性，\n解决方法是：不必为了指定子类的原型而调用超类的构造函数，\n我们所需的不过就是超类原型对象的一个副本而已。\n修改方法如下：\n*/\nfunction Extend(subType, superType){\n    function FTemp(){};\n    FTemp.prototype = superType.prototype;\n    var temp = new FTemp();\n    //创建一个临时中间对象\n    temp.constructor = subType;\n    subType.prototype = temp;\n}\nExtend(SubType, SuperType);\nSubType.prototype.sayAge = function(){\n    console.log(this.age);\n}\nvar instance3 = new SubType('cater', 25);\nconsole.log(instance3.colors);\ninstance3.sayAge()\ninstance3.sayName();\n```\n\n## 参考资料\n[JavaScript高级程序设计](https://book.douban.com/subject/10546125/)\n","slug":"JS中的寄生组合式继承","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrp30009526racse4yxc","content":"<p>寄生组合式继承，集寄生式继承和组合式继承的优点于一身，是JS中最完美的继承方式。<br><a id=\"more\"></a></p>\n<h2 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h2><ul>\n<li><p>实现方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</div><div class=\"line\"><span class=\"comment\">//SubType是子类，SuperType是超类</span></div><div class=\"line\"><span class=\"comment\">//将超类的一个实例赋给子类构造函数的原型</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>存在问题<br>子类对象将共享所有继承的属性和方法，一个子类实例更改一个继承的属性，这将会影响到所有的子类实例</p>\n</li>\n</ul>\n<h2 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h2><ul>\n<li><p>实现方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    SuperType.call(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"comment\">/*在子类构造函数的内部调用超类的构造函数，</span></div><div class=\"line\">    这样就使的子类的每个实例都具有自己的属性，</div><div class=\"line\">    解决了原型式继承带来的问题*/</div><div class=\"line\">&#125;</div><div class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</div></pre></td></tr></table></figure>\n</li>\n<li><p>存在问题<br>组合继承最大的问题就是在创建子类实例时，无论什么情况下，<br>都会调用<strong>两次</strong>超类的构造函数，这将会导致效率低下。<br>而且子类的原型对象和其实例会中有重复的属性，<br>解决方法是：不必为了指定子类的原型而调用超类的构造函数，<br>我们所需的不过就是超类原型对象的一个副本而已。</p>\n</li>\n</ul>\n<h2 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h2><ul>\n<li><p>实现方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    SuperType.call(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"comment\">// 这和组合继承保持一样</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Extend</span>(<span class=\"params\">subType, superType</span>)</span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FTemp</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">    FTemp.prototype = superType.prototype;</div><div class=\"line\">    <span class=\"keyword\">var</span> temp = <span class=\"keyword\">new</span> FTemp();</div><div class=\"line\">    <span class=\"comment\">//创建一个临时中间对象</span></div><div class=\"line\">    temp.constructor = subType;</div><div class=\"line\">    subType.prototype = temp;</div><div class=\"line\">&#125;</div><div class=\"line\">Extend(SubType, SuperType);</div></pre></td></tr></table></figure>\n</li>\n<li><p>开发人员普遍认为寄生组合式继承是最理想的继承方式。</p>\n</li>\n</ul>\n<h2 id=\"一个寄生组合式继承的完整例子\"><a href=\"#一个寄生组合式继承的完整例子\" class=\"headerlink\" title=\"一个寄生组合式继承的完整例子\"></a>一个寄生组合式继承的完整例子</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'blue'</span>, <span class=\"string\">'green'</span>];</div><div class=\"line\">&#125;</div><div class=\"line\">SuperType.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 继承属性</span></div><div class=\"line\">    SuperType.call(<span class=\"keyword\">this</span>, name);</div><div class=\"line\">    <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//继承方法</span></div><div class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</div><div class=\"line\">SubType.prototype.constructor = SubType;</div><div class=\"line\">SubType.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'bruce'</span>, <span class=\"number\">23</span>);</div><div class=\"line\">instance1.colors.push(<span class=\"string\">'black'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(instance1.colors);</div><div class=\"line\">instance1.sayAge()</div><div class=\"line\">instance1.sayName();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'mike'</span>, <span class=\"number\">28</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(instance2.colors);</div><div class=\"line\">instance1.sayAge()</div><div class=\"line\">instance1.sayName();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">以上是组合式继承。</div><div class=\"line\">组合继承最大的问题就是在创建子类实例时，无论什么情况下，</div><div class=\"line\">都会调用**两次**超类的构造函数，这将会导致效率低下。</div><div class=\"line\">而且子类的原型对象和其实例会中有重复的属性，</div><div class=\"line\">解决方法是：不必为了指定子类的原型而调用超类的构造函数，</div><div class=\"line\">我们所需的不过就是超类原型对象的一个副本而已。</div><div class=\"line\">修改方法如下：</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Extend</span>(<span class=\"params\">subType, superType</span>)</span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FTemp</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">    FTemp.prototype = superType.prototype;</div><div class=\"line\">    <span class=\"keyword\">var</span> temp = <span class=\"keyword\">new</span> FTemp();</div><div class=\"line\">    <span class=\"comment\">//创建一个临时中间对象</span></div><div class=\"line\">    temp.constructor = subType;</div><div class=\"line\">    subType.prototype = temp;</div><div class=\"line\">&#125;</div><div class=\"line\">Extend(SubType, SuperType);</div><div class=\"line\">SubType.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> instance3 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'cater'</span>, <span class=\"number\">25</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(instance3.colors);</div><div class=\"line\">instance3.sayAge()</div><div class=\"line\">instance3.sayName();</div></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://book.douban.com/subject/10546125/\" target=\"_blank\" rel=\"external\">JavaScript高级程序设计</a></p>\n","excerpt":"<p>寄生组合式继承，集寄生式继承和组合式继承的优点于一身，是JS中最完美的继承方式。<br>","more":"</p>\n<h2 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h2><ul>\n<li><p>实现方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</div><div class=\"line\"><span class=\"comment\">//SubType是子类，SuperType是超类</span></div><div class=\"line\"><span class=\"comment\">//将超类的一个实例赋给子类构造函数的原型</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>存在问题<br>子类对象将共享所有继承的属性和方法，一个子类实例更改一个继承的属性，这将会影响到所有的子类实例</p>\n</li>\n</ul>\n<h2 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h2><ul>\n<li><p>实现方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    SuperType.call(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"comment\">/*在子类构造函数的内部调用超类的构造函数，</div><div class=\"line\">    这样就使的子类的每个实例都具有自己的属性，</div><div class=\"line\">    解决了原型式继承带来的问题*/</span></div><div class=\"line\">&#125;</div><div class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</div></pre></td></tr></table></figure>\n</li>\n<li><p>存在问题<br>组合继承最大的问题就是在创建子类实例时，无论什么情况下，<br>都会调用<strong>两次</strong>超类的构造函数，这将会导致效率低下。<br>而且子类的原型对象和其实例会中有重复的属性，<br>解决方法是：不必为了指定子类的原型而调用超类的构造函数，<br>我们所需的不过就是超类原型对象的一个副本而已。</p>\n</li>\n</ul>\n<h2 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h2><ul>\n<li><p>实现方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    SuperType.call(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"comment\">// 这和组合继承保持一样</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Extend</span>(<span class=\"params\">subType, superType</span>)</span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FTemp</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">    FTemp.prototype = superType.prototype;</div><div class=\"line\">    <span class=\"keyword\">var</span> temp = <span class=\"keyword\">new</span> FTemp();</div><div class=\"line\">    <span class=\"comment\">//创建一个临时中间对象</span></div><div class=\"line\">    temp.constructor = subType;</div><div class=\"line\">    subType.prototype = temp;</div><div class=\"line\">&#125;</div><div class=\"line\">Extend(SubType, SuperType);</div></pre></td></tr></table></figure>\n</li>\n<li><p>开发人员普遍认为寄生组合式继承是最理想的继承方式。</p>\n</li>\n</ul>\n<h2 id=\"一个寄生组合式继承的完整例子\"><a href=\"#一个寄生组合式继承的完整例子\" class=\"headerlink\" title=\"一个寄生组合式继承的完整例子\"></a>一个寄生组合式继承的完整例子</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'blue'</span>, <span class=\"string\">'green'</span>];</div><div class=\"line\">&#125;</div><div class=\"line\">SuperType.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 继承属性</span></div><div class=\"line\">    SuperType.call(<span class=\"keyword\">this</span>, name);</div><div class=\"line\">    <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//继承方法</span></div><div class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</div><div class=\"line\">SubType.prototype.constructor = SubType;</div><div class=\"line\">SubType.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'bruce'</span>, <span class=\"number\">23</span>);</div><div class=\"line\">instance1.colors.push(<span class=\"string\">'black'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(instance1.colors);</div><div class=\"line\">instance1.sayAge()</div><div class=\"line\">instance1.sayName();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'mike'</span>, <span class=\"number\">28</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(instance2.colors);</div><div class=\"line\">instance1.sayAge()</div><div class=\"line\">instance1.sayName();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\">以上是组合式继承。</div><div class=\"line\">组合继承最大的问题就是在创建子类实例时，无论什么情况下，</div><div class=\"line\">都会调用**两次**超类的构造函数，这将会导致效率低下。</div><div class=\"line\">而且子类的原型对象和其实例会中有重复的属性，</div><div class=\"line\">解决方法是：不必为了指定子类的原型而调用超类的构造函数，</div><div class=\"line\">我们所需的不过就是超类原型对象的一个副本而已。</div><div class=\"line\">修改方法如下：</div><div class=\"line\">*/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Extend</span>(<span class=\"params\">subType, superType</span>)</span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FTemp</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">    FTemp.prototype = superType.prototype;</div><div class=\"line\">    <span class=\"keyword\">var</span> temp = <span class=\"keyword\">new</span> FTemp();</div><div class=\"line\">    <span class=\"comment\">//创建一个临时中间对象</span></div><div class=\"line\">    temp.constructor = subType;</div><div class=\"line\">    subType.prototype = temp;</div><div class=\"line\">&#125;</div><div class=\"line\">Extend(SubType, SuperType);</div><div class=\"line\">SubType.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> instance3 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'cater'</span>, <span class=\"number\">25</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(instance3.colors);</div><div class=\"line\">instance3.sayAge()</div><div class=\"line\">instance3.sayName();</div></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://book.douban.com/subject/10546125/\">JavaScript高级程序设计</a></p>"},{"title":"JS中的零碎知识","description":"记录一下JavaScript中的零碎小知识","toc":true,"date":"2016-05-25T02:59:48.000Z","_content":"将持续更新\n<!--more-->\n1. 变量命名除了数字、字母、下划线外，新加入美元符号$\n2. 变量类型为松散类型，即可以把任意类型的数据赋给一个变量，同一个变量可以反复赋值，而且可以是不同类型的数据，这种变量本身类型不固定的语言称为**动态语言**，比如Python，JS\n3. `var关键字`：定义一个局部变量，定义变量时省略var关键字，将定义一个全局变量\n4. 5种**基本类型**：`Undefined、Null、Boolean、Number、String`\n5种**引用类型**:`Object、Array、Date、RegExp、Function`\n - Undefined：未定义变量或定义了但是未初始化\n - Null：**空对象指针**\n - Number：IEEE754格式表示，说明JS中的数字均是浮点数\n - String：同C一样，字符串是不可变的\n - Object：是所有实例的基础\n5. JS中的操作符与其他语言不同的是，它们能够适用于很多值，例如String、Number、Boolean，甚至对象，**当一个操作符应用于不同类型的值时**,会先进行**类型转换**，再进行计算,**因为一个操作符两边操作数的类型要保持一致**,这和C一样\n6. 逻辑与、逻辑或：在有一个操作数不是布尔值的情况下，**不一定返回布尔值**\n7. 加法操作符：数值加法、字符串拼接，当有一个操作数是字符串时，即为字符串拼接\n8. `==`和`===`:前者会进行强制类型转换，而后者不会进行类型转换\nswitch语句在比较值时使用的是全等操作符\n9. JS中没有块级作用域\n10. `with语句`提供了一种读取对象属性的快捷方式，但是在with语句中**并不能**给这个对象创建一个新的属性，\n也就是说使用with设定的变量对象，是**只读的**，不可写，因为变量对象是用来解析标识符的。\n并且大量使用with语句会导致性能下降，同时也会给代码调试造成困难。\n```JavaScript\nfunction buildUrl(){\n    var qs = '?bebug=true';\n    with(location){\n        var url = href + qs;\n    }\n\n    return url;\n    /*在with语句中定义的变量url，并没有成为location的一个属性，\n    而是成为了函数执行环境的一部分*/\n}\n```\n11. 解除引用\n```JavaScript\nvar example = new Object();\nexample = null;\n/* 一旦数据不再有用，最好通过将其值设置为null来释放其引用，这称为：解除引用\n * 解除一个值的引用并不意味着**立刻回收**该值所占用的内存，其真正的作用是\n * 让值脱离执行环境，以便垃圾收集器下次运行时将其回收.\n */\n```\n12. 基本包装类型\n为了便于操作基本类型值，JS还提供了3个特殊的引用类型:**Boolean、Number、String**，称为基本包装类型。\n实际上，**每当读取**一个基本类型值的时候，**后台就会自动创建**一个对应的基本包装类型的对象，从而让我们可以调用一些方法来操作这些数据。\n而自动创建的基本包装类型的对象，则只存在于**一行代码的执行瞬间。**\n```JavaScript\nvar s1 = \"some text\";\nvar s2 = s1.substring(2);\n/*上面这句话(var s2 = s1.substring(2);)，后台会自动完成以下操作\n *var s1 = new String(\"some text\");\n *var s2 = s1.substring(2);\n *s1 = null;\n *经过此番处理，基本的字符串值就变得跟对象一样了\n */\n```\n13. 作用域链和原型链\n- 作用域链用来查找对象\n- 原型链用来查找对象的属性\n","source":"_posts/JS中的零碎知识.md","raw":"---\ntitle: JS中的零碎知识\ncategories: JavaScript\ntags: [JavaScript, 前端开发]\ndescription: 记录一下JavaScript中的零碎小知识\ntoc: true\ndate: 2016-05-25 10:59:48\n---\n将持续更新\n<!--more-->\n1. 变量命名除了数字、字母、下划线外，新加入美元符号$\n2. 变量类型为松散类型，即可以把任意类型的数据赋给一个变量，同一个变量可以反复赋值，而且可以是不同类型的数据，这种变量本身类型不固定的语言称为**动态语言**，比如Python，JS\n3. `var关键字`：定义一个局部变量，定义变量时省略var关键字，将定义一个全局变量\n4. 5种**基本类型**：`Undefined、Null、Boolean、Number、String`\n5种**引用类型**:`Object、Array、Date、RegExp、Function`\n - Undefined：未定义变量或定义了但是未初始化\n - Null：**空对象指针**\n - Number：IEEE754格式表示，说明JS中的数字均是浮点数\n - String：同C一样，字符串是不可变的\n - Object：是所有实例的基础\n5. JS中的操作符与其他语言不同的是，它们能够适用于很多值，例如String、Number、Boolean，甚至对象，**当一个操作符应用于不同类型的值时**,会先进行**类型转换**，再进行计算,**因为一个操作符两边操作数的类型要保持一致**,这和C一样\n6. 逻辑与、逻辑或：在有一个操作数不是布尔值的情况下，**不一定返回布尔值**\n7. 加法操作符：数值加法、字符串拼接，当有一个操作数是字符串时，即为字符串拼接\n8. `==`和`===`:前者会进行强制类型转换，而后者不会进行类型转换\nswitch语句在比较值时使用的是全等操作符\n9. JS中没有块级作用域\n10. `with语句`提供了一种读取对象属性的快捷方式，但是在with语句中**并不能**给这个对象创建一个新的属性，\n也就是说使用with设定的变量对象，是**只读的**，不可写，因为变量对象是用来解析标识符的。\n并且大量使用with语句会导致性能下降，同时也会给代码调试造成困难。\n```JavaScript\nfunction buildUrl(){\n    var qs = '?bebug=true';\n    with(location){\n        var url = href + qs;\n    }\n\n    return url;\n    /*在with语句中定义的变量url，并没有成为location的一个属性，\n    而是成为了函数执行环境的一部分*/\n}\n```\n11. 解除引用\n```JavaScript\nvar example = new Object();\nexample = null;\n/* 一旦数据不再有用，最好通过将其值设置为null来释放其引用，这称为：解除引用\n * 解除一个值的引用并不意味着**立刻回收**该值所占用的内存，其真正的作用是\n * 让值脱离执行环境，以便垃圾收集器下次运行时将其回收.\n */\n```\n12. 基本包装类型\n为了便于操作基本类型值，JS还提供了3个特殊的引用类型:**Boolean、Number、String**，称为基本包装类型。\n实际上，**每当读取**一个基本类型值的时候，**后台就会自动创建**一个对应的基本包装类型的对象，从而让我们可以调用一些方法来操作这些数据。\n而自动创建的基本包装类型的对象，则只存在于**一行代码的执行瞬间。**\n```JavaScript\nvar s1 = \"some text\";\nvar s2 = s1.substring(2);\n/*上面这句话(var s2 = s1.substring(2);)，后台会自动完成以下操作\n *var s1 = new String(\"some text\");\n *var s2 = s1.substring(2);\n *s1 = null;\n *经过此番处理，基本的字符串值就变得跟对象一样了\n */\n```\n13. 作用域链和原型链\n- 作用域链用来查找对象\n- 原型链用来查找对象的属性\n","slug":"JS中的零碎知识","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrp5000b526redkr3702","content":"<p>将持续更新<br><a id=\"more\"></a></p>\n<ol>\n<li>变量命名除了数字、字母、下划线外，新加入美元符号$</li>\n<li>变量类型为松散类型，即可以把任意类型的数据赋给一个变量，同一个变量可以反复赋值，而且可以是不同类型的数据，这种变量本身类型不固定的语言称为<strong>动态语言</strong>，比如Python，JS</li>\n<li><code>var关键字</code>：定义一个局部变量，定义变量时省略var关键字，将定义一个全局变量</li>\n<li>5种<strong>基本类型</strong>：<code>Undefined、Null、Boolean、Number、String</code><br>5种<strong>引用类型</strong>:<code>Object、Array、Date、RegExp、Function</code><ul>\n<li>Undefined：未定义变量或定义了但是未初始化</li>\n<li>Null：<strong>空对象指针</strong></li>\n<li>Number：IEEE754格式表示，说明JS中的数字均是浮点数</li>\n<li>String：同C一样，字符串是不可变的</li>\n<li>Object：是所有实例的基础</li>\n</ul>\n</li>\n<li>JS中的操作符与其他语言不同的是，它们能够适用于很多值，例如String、Number、Boolean，甚至对象，<strong>当一个操作符应用于不同类型的值时</strong>,会先进行<strong>类型转换</strong>，再进行计算,<strong>因为一个操作符两边操作数的类型要保持一致</strong>,这和C一样</li>\n<li>逻辑与、逻辑或：在有一个操作数不是布尔值的情况下，<strong>不一定返回布尔值</strong></li>\n<li>加法操作符：数值加法、字符串拼接，当有一个操作数是字符串时，即为字符串拼接</li>\n<li><code>==</code>和<code>===</code>:前者会进行强制类型转换，而后者不会进行类型转换<br>switch语句在比较值时使用的是全等操作符</li>\n<li>JS中没有块级作用域</li>\n<li><p><code>with语句</code>提供了一种读取对象属性的快捷方式，但是在with语句中<strong>并不能</strong>给这个对象创建一个新的属性，<br>也就是说使用with设定的变量对象，是<strong>只读的</strong>，不可写，因为变量对象是用来解析标识符的。<br>并且大量使用with语句会导致性能下降，同时也会给代码调试造成困难。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildUrl</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> qs = <span class=\"string\">'?bebug=true'</span>;</div><div class=\"line\">    <span class=\"keyword\">with</span>(location)&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> url = href + qs;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> url;</div><div class=\"line\">    <span class=\"comment\">/*在with语句中定义的变量url，并没有成为location的一个属性，</span></div><div class=\"line\">    而是成为了函数执行环境的一部分*/</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>解除引用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> example = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">example = <span class=\"literal\">null</span>;</div><div class=\"line\"><span class=\"comment\">/* 一旦数据不再有用，最好通过将其值设置为null来释放其引用，这称为：解除引用</span></div><div class=\"line\"> * 解除一个值的引用并不意味着**立刻回收**该值所占用的内存，其真正的作用是</div><div class=\"line\"> * 让值脱离执行环境，以便垃圾收集器下次运行时将其回收.</div><div class=\"line\"> */</div></pre></td></tr></table></figure>\n</li>\n<li><p>基本包装类型<br>为了便于操作基本类型值，JS还提供了3个特殊的引用类型:<strong>Boolean、Number、String</strong>，称为基本包装类型。<br>实际上，<strong>每当读取</strong>一个基本类型值的时候，<strong>后台就会自动创建</strong>一个对应的基本包装类型的对象，从而让我们可以调用一些方法来操作这些数据。<br>而自动创建的基本包装类型的对象，则只存在于<strong>一行代码的执行瞬间。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">\"some text\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> s2 = s1.substring(<span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"comment\">/*上面这句话(var s2 = s1.substring(2);)，后台会自动完成以下操作</span></div><div class=\"line\"> *var s1 = new String(\"some text\");</div><div class=\"line\"> *var s2 = s1.substring(2);</div><div class=\"line\"> *s1 = null;</div><div class=\"line\"> *经过此番处理，基本的字符串值就变得跟对象一样了</div><div class=\"line\"> */</div></pre></td></tr></table></figure>\n</li>\n<li><p>作用域链和原型链</p>\n</li>\n</ol>\n<ul>\n<li>作用域链用来查找对象</li>\n<li>原型链用来查找对象的属性</li>\n</ul>\n","excerpt":"<p>将持续更新<br>","more":"</p>\n<ol>\n<li>变量命名除了数字、字母、下划线外，新加入美元符号$</li>\n<li>变量类型为松散类型，即可以把任意类型的数据赋给一个变量，同一个变量可以反复赋值，而且可以是不同类型的数据，这种变量本身类型不固定的语言称为<strong>动态语言</strong>，比如Python，JS</li>\n<li><code>var关键字</code>：定义一个局部变量，定义变量时省略var关键字，将定义一个全局变量</li>\n<li>5种<strong>基本类型</strong>：<code>Undefined、Null、Boolean、Number、String</code><br>5种<strong>引用类型</strong>:<code>Object、Array、Date、RegExp、Function</code><ul>\n<li>Undefined：未定义变量或定义了但是未初始化</li>\n<li>Null：<strong>空对象指针</strong></li>\n<li>Number：IEEE754格式表示，说明JS中的数字均是浮点数</li>\n<li>String：同C一样，字符串是不可变的</li>\n<li>Object：是所有实例的基础</li>\n</ul>\n</li>\n<li>JS中的操作符与其他语言不同的是，它们能够适用于很多值，例如String、Number、Boolean，甚至对象，<strong>当一个操作符应用于不同类型的值时</strong>,会先进行<strong>类型转换</strong>，再进行计算,<strong>因为一个操作符两边操作数的类型要保持一致</strong>,这和C一样</li>\n<li>逻辑与、逻辑或：在有一个操作数不是布尔值的情况下，<strong>不一定返回布尔值</strong></li>\n<li>加法操作符：数值加法、字符串拼接，当有一个操作数是字符串时，即为字符串拼接</li>\n<li><code>==</code>和<code>===</code>:前者会进行强制类型转换，而后者不会进行类型转换<br>switch语句在比较值时使用的是全等操作符</li>\n<li>JS中没有块级作用域</li>\n<li><p><code>with语句</code>提供了一种读取对象属性的快捷方式，但是在with语句中<strong>并不能</strong>给这个对象创建一个新的属性，<br>也就是说使用with设定的变量对象，是<strong>只读的</strong>，不可写，因为变量对象是用来解析标识符的。<br>并且大量使用with语句会导致性能下降，同时也会给代码调试造成困难。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildUrl</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> qs = <span class=\"string\">'?bebug=true'</span>;</div><div class=\"line\">    <span class=\"keyword\">with</span>(location)&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> url = href + qs;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> url;</div><div class=\"line\">    <span class=\"comment\">/*在with语句中定义的变量url，并没有成为location的一个属性，</div><div class=\"line\">    而是成为了函数执行环境的一部分*/</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>解除引用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> example = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">example = <span class=\"literal\">null</span>;</div><div class=\"line\"><span class=\"comment\">/* 一旦数据不再有用，最好通过将其值设置为null来释放其引用，这称为：解除引用</div><div class=\"line\"> * 解除一个值的引用并不意味着**立刻回收**该值所占用的内存，其真正的作用是</div><div class=\"line\"> * 让值脱离执行环境，以便垃圾收集器下次运行时将其回收.</div><div class=\"line\"> */</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>基本包装类型<br>为了便于操作基本类型值，JS还提供了3个特殊的引用类型:<strong>Boolean、Number、String</strong>，称为基本包装类型。<br>实际上，<strong>每当读取</strong>一个基本类型值的时候，<strong>后台就会自动创建</strong>一个对应的基本包装类型的对象，从而让我们可以调用一些方法来操作这些数据。<br>而自动创建的基本包装类型的对象，则只存在于<strong>一行代码的执行瞬间。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">\"some text\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> s2 = s1.substring(<span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"comment\">/*上面这句话(var s2 = s1.substring(2);)，后台会自动完成以下操作</div><div class=\"line\"> *var s1 = new String(\"some text\");</div><div class=\"line\"> *var s2 = s1.substring(2);</div><div class=\"line\"> *s1 = null;</div><div class=\"line\"> *经过此番处理，基本的字符串值就变得跟对象一样了</div><div class=\"line\"> */</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>作用域链和原型链</p>\n</li>\n</ol>\n<ul>\n<li>作用域链用来查找对象</li>\n<li>原型链用来查找对象的属性</li>\n</ul>"},{"title":"JS事件详解","description":"事件作为JS的一个重要组成部分，搞定它的意义毋庸置疑。","toc":true,"date":"2016-06-04T08:11:35.000Z","_content":"事件作为JS的一个重要组成部分，搞定它的意义毋庸置疑。\n<!--more-->\n## 事件流的三个阶段\n> Netscape(网景)和IE曾经为了取得浏览器的控制权，网景主张捕获方式，微软主张冒泡方式。后来 W3C 采用折中的方式，制定了统一的标准——先捕获再冒泡，这个过程具体如下：\n\n1. 捕获阶段\n即在事件到达预定目标之前捕获它，低版本的IE不支持捕获阶段\n2. 目标阶段\n事件到达预定目标，其被看成是冒泡阶段的一部分\n3. 冒泡阶段\n事件被冒泡至window对象，所有现代浏览器都支持事件冒泡\n\n**注：**大多数浏览器都是从`window对象`开始捕获，然后冒泡至`window对象`；\n建议通常都使用事件冒泡，只有在特殊情况下才使用事件捕获。\n\n## 绑定事件和解绑事件\n### W3C\n- 绑定事件： `target.addEventListener(eventType, listener, bIsUseCapture)`\neventType: 事件类型，比如`click`\nlistener: 事件触发时执行的函数（事件处理程序或事件侦听器）\nbIsUseCapture： 表示是否在捕获阶段调用事件处理函数，如果为false（默认为false），表示在冒泡阶段调用listener\n- 解绑事件: `target.removeEventListener(eventType, listener, bIsUseCapture)`\n参数意义同上\n\n### IE\n- 绑定事件： `target.attachEvent(listenerName, listener)`\nlistenerName: 事件处理程序的名字，以\"on\"开头，比如`onclick`\nlistener: 同W3C\n- 解绑事件： `target.detachEvent(listenerName, listener)`\n参数意义同上\n\n### 不同\n1. 事件处理程序的作用域\nW3C对应的作用域是事件所依附的目标元素，即`this`指向当前元素\n而IE对应的作用域是全局作用域，即`this`指向window对象\n2. 多个事件处理程序的触发顺序\nW3C按照添加它们的前后顺序触发，即先添加的先触发\n而IE恰好相反，先添加的后触发\n3. 事件处理程序的阶段\nW3C即可以添加到冒泡阶段，也可以添加捕获阶段\n而IE只能添加到冒泡阶段\n\n### 相同\n对于绑定事件和解绑事件，二者都要求解绑时的参数要与绑定时的参数**相同**，这意味着添加的匿名事件处理程序将没法被移除，因为所有声明的匿名函数都是一个新函数，即使二者代码完全一样。\n\n### 原生JS实现事件绑定函数\n其接口是`target.addEventListener(eventType, listener)`\n核心需求就是可以对某一个事件名称绑定多个事件响应函数，大致实现思路就是创建一个类，其中有两个函数，一个 `bind`一个`trigger`，分别实现绑定事件和触发事件，然后当触发这个事件名称时，依次按绑定顺序触发相应的响应函数。具体做法是在bind和trigger函数外层作用域创建一个`字典对象`，用于存储注册的事件及响应函数列表，bind时，如果字典没有则创建一个，key是事件名称，value是数组，里面放着当前注册的响应函数，如果字段中有，那么就直接push到数组即可。trigger时调出来依次触发事件响应函数即可。\n其中key和value的关系其实是`C#中的委托`，C#中的委托是一个二级指针，指向一个函数指针数组（当然这些函数必须具有相同的参数列表和返回值，不一样还瞎掺和啥），这个数组中的每一个元素都是一个函数，当调用委托时，数组中的函数将被依次唤起。\n下面是一个简单的例子\n```JavaScript\n//有待完善\nfunction attachEvent(eventType, listener){\n    var objDelegate;\n    var that = this;\n\n    function bind(eventType, listener){\n        if(objDelegate[eventType] instanceof Array){\n            objDelegate[eventType].push(listener);\n        }else{\n            objDelegate[eventType] = [];\n            objDelegate[eventType].push(listener);\n        }\n        that.objDelegate = objDelegate;\n    }\n\n    function trigger(){\n        var args = [];\n        for(var i=0; i<arguments.length; i++){\n            args.push[arguments[i]];\n        }\n        var listeners = that.objDelegate[eventType];\n        for (var index in listeners){\n            listeners[index].apply(that, args);\n            //listeners.shift();\n        }\n    }\n}\n```\n\n## 事件代理/委托\n> 如果你单击了某个button，JS认为单击事件不仅仅发生在button上，换句话说，在单击button的同时，你也单击了button的父元素，甚至也单击了整个页面。\n\nJS的事件委托靠事件冒泡来实现\n### 优点\n- 内存占用少： 因为每个事件处理函数都是对象，都会占用内存\n- DOM访问次数少： 加快页面的交互就绪时间，因为不管什么时候，只要是访问DOM树中的一个元素，浏览器都会搜索整个DOM树，从中查找匹配的元素\n- 动态绑定事件： 可以实现当新增子对象时无需再次对其绑定事件，对于动态内容部分尤为合适\n\n### 缺点\n事件代理的应用应该仅限于上述需求下，如果把所有事件都用代理就可能会出现事件误判，即本不该绑定事件的元素被绑上了事件。\n\n### 原生JS实现事件委托\n> 首先说一下事件对象event的常用属性\n> 1.target（在IE中为srcElement）属性： 指向事件的实际目标元素\n> 2.currentTarget（IE中没有）属性： 事件处理函数的作用域\n> 3.type属性： 被触发的事件的类型\n\n```JavaScript\n/*简单的事件委托，思路如下\n *1.事件处理程序是绑定在父元素上的\n *2.事件对象event的target属性（在IE中为srcElement属性）\n *  是指向实际目标元素的\n *3.当实际目标元素等于给定元素时，才调用真实的事件处理函数 \n**/\nfunction delegateEvent(selector, eventType, listener){\n    var delegator = this;\n    if (delegator.addEventListener){\n        delegator.addEventListener(eventType, listenerFunc, false);\n    } else if(delegator.attachEvent){\n        delegator.attachEvent(\"on\"+eventType, listenerFunc);\n    } else {\n        delegator[\"on\"+eventType] = listenerFunc;\n    }\n\n    // 封装实际的事件处理函数\n    function listenerFunc(event){\n        var event = event || window.event;\n        var target = event.target || event.srcElement;\n\n        if(target.matchSelector(selector)){\n            if(listener){\n                listener.call(target, event);\n            }\n        }\n    }\n\n    // 判断实际目标元素是不是事先给定的元素\n    function matchSelector(selector){\n        var targetElement = this;\n        \n        if (selector.charAt(0) === \"#\"){\n            return targetElement.id = selector.slice(1);\n        }\n\n        if (selector.charAt(0) === \".\"){\n            return (\" \" + targetElement.className + \" \").indexOf(\n                \" \" + selector.slice(1) + \" \") != -1;\n        }\n\n       return targetElement.tagName.toLowerCase() === selector.toLowerCase();\n    }\n\n}\n\n// 调用\nvar outerDiv = document.getElementById(\"outerDiv\");\nouterDiv.delegateEvent(\"#innerDiv\", \"click\", function(event){\n    console.log(event.target.id);\n})\n```\n\n## 模拟事件\n事件通常由用户操作或通过浏览器的某些功能来触发，但JS也能在任意时刻手动的触发特定事件。\n这被称为事件模拟，也被称为事件派发或事件广播，在`测试Web应用程序`时，模拟触发事件是一种极其有用的技术。\n一般来说模拟触发一个事件要经过以下3步：\n1. 创建一个事件对象event\n2. 对其进行初始化\n3. 调用`dispatchEvent`（IE下为fireEvent方法）触发这个事件\n\n在这里就不详细介绍了，留一个印象即可。\n\n## 其他\n那么接下来就是熟悉各种类型的事件，比如click、文本改变事件等等各种事件。\n少年，踩坑去吧，看好你...\n\n\n","source":"_posts/JS事件详解.md","raw":"---\ntitle: JS事件详解\ncategories: JavaScript\ntags: [JavaScript, 前端开发， 事件]\ndescription: 事件作为JS的一个重要组成部分，搞定它的意义毋庸置疑。\ntoc: true\ndate: 2016-06-04 16:11:35\n---\n事件作为JS的一个重要组成部分，搞定它的意义毋庸置疑。\n<!--more-->\n## 事件流的三个阶段\n> Netscape(网景)和IE曾经为了取得浏览器的控制权，网景主张捕获方式，微软主张冒泡方式。后来 W3C 采用折中的方式，制定了统一的标准——先捕获再冒泡，这个过程具体如下：\n\n1. 捕获阶段\n即在事件到达预定目标之前捕获它，低版本的IE不支持捕获阶段\n2. 目标阶段\n事件到达预定目标，其被看成是冒泡阶段的一部分\n3. 冒泡阶段\n事件被冒泡至window对象，所有现代浏览器都支持事件冒泡\n\n**注：**大多数浏览器都是从`window对象`开始捕获，然后冒泡至`window对象`；\n建议通常都使用事件冒泡，只有在特殊情况下才使用事件捕获。\n\n## 绑定事件和解绑事件\n### W3C\n- 绑定事件： `target.addEventListener(eventType, listener, bIsUseCapture)`\neventType: 事件类型，比如`click`\nlistener: 事件触发时执行的函数（事件处理程序或事件侦听器）\nbIsUseCapture： 表示是否在捕获阶段调用事件处理函数，如果为false（默认为false），表示在冒泡阶段调用listener\n- 解绑事件: `target.removeEventListener(eventType, listener, bIsUseCapture)`\n参数意义同上\n\n### IE\n- 绑定事件： `target.attachEvent(listenerName, listener)`\nlistenerName: 事件处理程序的名字，以\"on\"开头，比如`onclick`\nlistener: 同W3C\n- 解绑事件： `target.detachEvent(listenerName, listener)`\n参数意义同上\n\n### 不同\n1. 事件处理程序的作用域\nW3C对应的作用域是事件所依附的目标元素，即`this`指向当前元素\n而IE对应的作用域是全局作用域，即`this`指向window对象\n2. 多个事件处理程序的触发顺序\nW3C按照添加它们的前后顺序触发，即先添加的先触发\n而IE恰好相反，先添加的后触发\n3. 事件处理程序的阶段\nW3C即可以添加到冒泡阶段，也可以添加捕获阶段\n而IE只能添加到冒泡阶段\n\n### 相同\n对于绑定事件和解绑事件，二者都要求解绑时的参数要与绑定时的参数**相同**，这意味着添加的匿名事件处理程序将没法被移除，因为所有声明的匿名函数都是一个新函数，即使二者代码完全一样。\n\n### 原生JS实现事件绑定函数\n其接口是`target.addEventListener(eventType, listener)`\n核心需求就是可以对某一个事件名称绑定多个事件响应函数，大致实现思路就是创建一个类，其中有两个函数，一个 `bind`一个`trigger`，分别实现绑定事件和触发事件，然后当触发这个事件名称时，依次按绑定顺序触发相应的响应函数。具体做法是在bind和trigger函数外层作用域创建一个`字典对象`，用于存储注册的事件及响应函数列表，bind时，如果字典没有则创建一个，key是事件名称，value是数组，里面放着当前注册的响应函数，如果字段中有，那么就直接push到数组即可。trigger时调出来依次触发事件响应函数即可。\n其中key和value的关系其实是`C#中的委托`，C#中的委托是一个二级指针，指向一个函数指针数组（当然这些函数必须具有相同的参数列表和返回值，不一样还瞎掺和啥），这个数组中的每一个元素都是一个函数，当调用委托时，数组中的函数将被依次唤起。\n下面是一个简单的例子\n```JavaScript\n//有待完善\nfunction attachEvent(eventType, listener){\n    var objDelegate;\n    var that = this;\n\n    function bind(eventType, listener){\n        if(objDelegate[eventType] instanceof Array){\n            objDelegate[eventType].push(listener);\n        }else{\n            objDelegate[eventType] = [];\n            objDelegate[eventType].push(listener);\n        }\n        that.objDelegate = objDelegate;\n    }\n\n    function trigger(){\n        var args = [];\n        for(var i=0; i<arguments.length; i++){\n            args.push[arguments[i]];\n        }\n        var listeners = that.objDelegate[eventType];\n        for (var index in listeners){\n            listeners[index].apply(that, args);\n            //listeners.shift();\n        }\n    }\n}\n```\n\n## 事件代理/委托\n> 如果你单击了某个button，JS认为单击事件不仅仅发生在button上，换句话说，在单击button的同时，你也单击了button的父元素，甚至也单击了整个页面。\n\nJS的事件委托靠事件冒泡来实现\n### 优点\n- 内存占用少： 因为每个事件处理函数都是对象，都会占用内存\n- DOM访问次数少： 加快页面的交互就绪时间，因为不管什么时候，只要是访问DOM树中的一个元素，浏览器都会搜索整个DOM树，从中查找匹配的元素\n- 动态绑定事件： 可以实现当新增子对象时无需再次对其绑定事件，对于动态内容部分尤为合适\n\n### 缺点\n事件代理的应用应该仅限于上述需求下，如果把所有事件都用代理就可能会出现事件误判，即本不该绑定事件的元素被绑上了事件。\n\n### 原生JS实现事件委托\n> 首先说一下事件对象event的常用属性\n> 1.target（在IE中为srcElement）属性： 指向事件的实际目标元素\n> 2.currentTarget（IE中没有）属性： 事件处理函数的作用域\n> 3.type属性： 被触发的事件的类型\n\n```JavaScript\n/*简单的事件委托，思路如下\n *1.事件处理程序是绑定在父元素上的\n *2.事件对象event的target属性（在IE中为srcElement属性）\n *  是指向实际目标元素的\n *3.当实际目标元素等于给定元素时，才调用真实的事件处理函数 \n**/\nfunction delegateEvent(selector, eventType, listener){\n    var delegator = this;\n    if (delegator.addEventListener){\n        delegator.addEventListener(eventType, listenerFunc, false);\n    } else if(delegator.attachEvent){\n        delegator.attachEvent(\"on\"+eventType, listenerFunc);\n    } else {\n        delegator[\"on\"+eventType] = listenerFunc;\n    }\n\n    // 封装实际的事件处理函数\n    function listenerFunc(event){\n        var event = event || window.event;\n        var target = event.target || event.srcElement;\n\n        if(target.matchSelector(selector)){\n            if(listener){\n                listener.call(target, event);\n            }\n        }\n    }\n\n    // 判断实际目标元素是不是事先给定的元素\n    function matchSelector(selector){\n        var targetElement = this;\n        \n        if (selector.charAt(0) === \"#\"){\n            return targetElement.id = selector.slice(1);\n        }\n\n        if (selector.charAt(0) === \".\"){\n            return (\" \" + targetElement.className + \" \").indexOf(\n                \" \" + selector.slice(1) + \" \") != -1;\n        }\n\n       return targetElement.tagName.toLowerCase() === selector.toLowerCase();\n    }\n\n}\n\n// 调用\nvar outerDiv = document.getElementById(\"outerDiv\");\nouterDiv.delegateEvent(\"#innerDiv\", \"click\", function(event){\n    console.log(event.target.id);\n})\n```\n\n## 模拟事件\n事件通常由用户操作或通过浏览器的某些功能来触发，但JS也能在任意时刻手动的触发特定事件。\n这被称为事件模拟，也被称为事件派发或事件广播，在`测试Web应用程序`时，模拟触发事件是一种极其有用的技术。\n一般来说模拟触发一个事件要经过以下3步：\n1. 创建一个事件对象event\n2. 对其进行初始化\n3. 调用`dispatchEvent`（IE下为fireEvent方法）触发这个事件\n\n在这里就不详细介绍了，留一个印象即可。\n\n## 其他\n那么接下来就是熟悉各种类型的事件，比如click、文本改变事件等等各种事件。\n少年，踩坑去吧，看好你...\n\n\n","slug":"JS事件详解","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrp7000c526ruqzqhiq0","content":"<p>事件作为JS的一个重要组成部分，搞定它的意义毋庸置疑。<br><a id=\"more\"></a></p>\n<h2 id=\"事件流的三个阶段\"><a href=\"#事件流的三个阶段\" class=\"headerlink\" title=\"事件流的三个阶段\"></a>事件流的三个阶段</h2><blockquote>\n<p>Netscape(网景)和IE曾经为了取得浏览器的控制权，网景主张捕获方式，微软主张冒泡方式。后来 W3C 采用折中的方式，制定了统一的标准——先捕获再冒泡，这个过程具体如下：</p>\n</blockquote>\n<ol>\n<li>捕获阶段<br>即在事件到达预定目标之前捕获它，低版本的IE不支持捕获阶段</li>\n<li>目标阶段<br>事件到达预定目标，其被看成是冒泡阶段的一部分</li>\n<li>冒泡阶段<br>事件被冒泡至window对象，所有现代浏览器都支持事件冒泡</li>\n</ol>\n<p><strong>注：</strong>大多数浏览器都是从<code>window对象</code>开始捕获，然后冒泡至<code>window对象</code>；<br>建议通常都使用事件冒泡，只有在特殊情况下才使用事件捕获。</p>\n<h2 id=\"绑定事件和解绑事件\"><a href=\"#绑定事件和解绑事件\" class=\"headerlink\" title=\"绑定事件和解绑事件\"></a>绑定事件和解绑事件</h2><h3 id=\"W3C\"><a href=\"#W3C\" class=\"headerlink\" title=\"W3C\"></a>W3C</h3><ul>\n<li>绑定事件： <code>target.addEventListener(eventType, listener, bIsUseCapture)</code><br>eventType: 事件类型，比如<code>click</code><br>listener: 事件触发时执行的函数（事件处理程序或事件侦听器）<br>bIsUseCapture： 表示是否在捕获阶段调用事件处理函数，如果为false（默认为false），表示在冒泡阶段调用listener</li>\n<li>解绑事件: <code>target.removeEventListener(eventType, listener, bIsUseCapture)</code><br>参数意义同上</li>\n</ul>\n<h3 id=\"IE\"><a href=\"#IE\" class=\"headerlink\" title=\"IE\"></a>IE</h3><ul>\n<li>绑定事件： <code>target.attachEvent(listenerName, listener)</code><br>listenerName: 事件处理程序的名字，以”on”开头，比如<code>onclick</code><br>listener: 同W3C</li>\n<li>解绑事件： <code>target.detachEvent(listenerName, listener)</code><br>参数意义同上</li>\n</ul>\n<h3 id=\"不同\"><a href=\"#不同\" class=\"headerlink\" title=\"不同\"></a>不同</h3><ol>\n<li>事件处理程序的作用域<br>W3C对应的作用域是事件所依附的目标元素，即<code>this</code>指向当前元素<br>而IE对应的作用域是全局作用域，即<code>this</code>指向window对象</li>\n<li>多个事件处理程序的触发顺序<br>W3C按照添加它们的前后顺序触发，即先添加的先触发<br>而IE恰好相反，先添加的后触发</li>\n<li>事件处理程序的阶段<br>W3C即可以添加到冒泡阶段，也可以添加捕获阶段<br>而IE只能添加到冒泡阶段</li>\n</ol>\n<h3 id=\"相同\"><a href=\"#相同\" class=\"headerlink\" title=\"相同\"></a>相同</h3><p>对于绑定事件和解绑事件，二者都要求解绑时的参数要与绑定时的参数<strong>相同</strong>，这意味着添加的匿名事件处理程序将没法被移除，因为所有声明的匿名函数都是一个新函数，即使二者代码完全一样。</p>\n<h3 id=\"原生JS实现事件绑定函数\"><a href=\"#原生JS实现事件绑定函数\" class=\"headerlink\" title=\"原生JS实现事件绑定函数\"></a>原生JS实现事件绑定函数</h3><p>其接口是<code>target.addEventListener(eventType, listener)</code><br>核心需求就是可以对某一个事件名称绑定多个事件响应函数，大致实现思路就是创建一个类，其中有两个函数，一个 <code>bind</code>一个<code>trigger</code>，分别实现绑定事件和触发事件，然后当触发这个事件名称时，依次按绑定顺序触发相应的响应函数。具体做法是在bind和trigger函数外层作用域创建一个<code>字典对象</code>，用于存储注册的事件及响应函数列表，bind时，如果字典没有则创建一个，key是事件名称，value是数组，里面放着当前注册的响应函数，如果字段中有，那么就直接push到数组即可。trigger时调出来依次触发事件响应函数即可。<br>其中key和value的关系其实是<code>C#中的委托</code>，C#中的委托是一个二级指针，指向一个函数指针数组（当然这些函数必须具有相同的参数列表和返回值，不一样还瞎掺和啥），这个数组中的每一个元素都是一个函数，当调用委托时，数组中的函数将被依次唤起。<br>下面是一个简单的例子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//有待完善</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">attachEvent</span>(<span class=\"params\">eventType, listener</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> objDelegate;</div><div class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">eventType, listener</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(objDelegate[eventType] <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>)&#123;</div><div class=\"line\">            objDelegate[eventType].push(listener);</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            objDelegate[eventType] = [];</div><div class=\"line\">            objDelegate[eventType].push(listener);</div><div class=\"line\">        &#125;</div><div class=\"line\">        that.objDelegate = objDelegate;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trigger</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> args = [];</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">arguments</span>.length; i++)&#123;</div><div class=\"line\">            args.push[<span class=\"built_in\">arguments</span>[i]];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">var</span> listeners = that.objDelegate[eventType];</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index <span class=\"keyword\">in</span> listeners)&#123;</div><div class=\"line\">            listeners[index].apply(that, args);</div><div class=\"line\">            <span class=\"comment\">//listeners.shift();</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"事件代理-委托\"><a href=\"#事件代理-委托\" class=\"headerlink\" title=\"事件代理/委托\"></a>事件代理/委托</h2><blockquote>\n<p>如果你单击了某个button，JS认为单击事件不仅仅发生在button上，换句话说，在单击button的同时，你也单击了button的父元素，甚至也单击了整个页面。</p>\n</blockquote>\n<p>JS的事件委托靠事件冒泡来实现</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>内存占用少： 因为每个事件处理函数都是对象，都会占用内存</li>\n<li>DOM访问次数少： 加快页面的交互就绪时间，因为不管什么时候，只要是访问DOM树中的一个元素，浏览器都会搜索整个DOM树，从中查找匹配的元素</li>\n<li>动态绑定事件： 可以实现当新增子对象时无需再次对其绑定事件，对于动态内容部分尤为合适</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>事件代理的应用应该仅限于上述需求下，如果把所有事件都用代理就可能会出现事件误判，即本不该绑定事件的元素被绑上了事件。</p>\n<h3 id=\"原生JS实现事件委托\"><a href=\"#原生JS实现事件委托\" class=\"headerlink\" title=\"原生JS实现事件委托\"></a>原生JS实现事件委托</h3><blockquote>\n<p>首先说一下事件对象event的常用属性<br>1.target（在IE中为srcElement）属性： 指向事件的实际目标元素<br>2.currentTarget（IE中没有）属性： 事件处理函数的作用域<br>3.type属性： 被触发的事件的类型</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*简单的事件委托，思路如下</span></div><div class=\"line\"> *1.事件处理程序是绑定在父元素上的</div><div class=\"line\"> *2.事件对象event的target属性（在IE中为srcElement属性）</div><div class=\"line\"> *  是指向实际目标元素的</div><div class=\"line\"> *3.当实际目标元素等于给定元素时，才调用真实的事件处理函数 </div><div class=\"line\">**/</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delegateEvent</span>(<span class=\"params\">selector, eventType, listener</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> delegator = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (delegator.addEventListener)&#123;</div><div class=\"line\">        delegator.addEventListener(eventType, listenerFunc, <span class=\"literal\">false</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(delegator.attachEvent)&#123;</div><div class=\"line\">        delegator.attachEvent(<span class=\"string\">\"on\"</span>+eventType, listenerFunc);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        delegator[<span class=\"string\">\"on\"</span>+eventType] = listenerFunc;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 封装实际的事件处理函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">listenerFunc</span>(<span class=\"params\">event</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> event = event || <span class=\"built_in\">window</span>.event;</div><div class=\"line\">        <span class=\"keyword\">var</span> target = event.target || event.srcElement;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span>(target.matchSelector(selector))&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(listener)&#123;</div><div class=\"line\">                listener.call(target, event);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 判断实际目标元素是不是事先给定的元素</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">matchSelector</span>(<span class=\"params\">selector</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> targetElement = <span class=\"keyword\">this</span>;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span> (selector.charAt(<span class=\"number\">0</span>) === <span class=\"string\">\"#\"</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> targetElement.id = selector.slice(<span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (selector.charAt(<span class=\"number\">0</span>) === <span class=\"string\">\".\"</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"string\">\" \"</span> + targetElement.className + <span class=\"string\">\" \"</span>).indexOf(</div><div class=\"line\">                <span class=\"string\">\" \"</span> + selector.slice(<span class=\"number\">1</span>) + <span class=\"string\">\" \"</span>) != <span class=\"number\">-1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> targetElement.tagName.toLowerCase() === selector.toLowerCase();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 调用</span></div><div class=\"line\"><span class=\"keyword\">var</span> outerDiv = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"outerDiv\"</span>);</div><div class=\"line\">outerDiv.delegateEvent(<span class=\"string\">\"#innerDiv\"</span>, <span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(event.target.id);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"模拟事件\"><a href=\"#模拟事件\" class=\"headerlink\" title=\"模拟事件\"></a>模拟事件</h2><p>事件通常由用户操作或通过浏览器的某些功能来触发，但JS也能在任意时刻手动的触发特定事件。<br>这被称为事件模拟，也被称为事件派发或事件广播，在<code>测试Web应用程序</code>时，模拟触发事件是一种极其有用的技术。<br>一般来说模拟触发一个事件要经过以下3步：</p>\n<ol>\n<li>创建一个事件对象event</li>\n<li>对其进行初始化</li>\n<li>调用<code>dispatchEvent</code>（IE下为fireEvent方法）触发这个事件</li>\n</ol>\n<p>在这里就不详细介绍了，留一个印象即可。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>那么接下来就是熟悉各种类型的事件，比如click、文本改变事件等等各种事件。<br>少年，踩坑去吧，看好你…</p>\n","excerpt":"<p>事件作为JS的一个重要组成部分，搞定它的意义毋庸置疑。<br>","more":"</p>\n<h2 id=\"事件流的三个阶段\"><a href=\"#事件流的三个阶段\" class=\"headerlink\" title=\"事件流的三个阶段\"></a>事件流的三个阶段</h2><blockquote>\n<p>Netscape(网景)和IE曾经为了取得浏览器的控制权，网景主张捕获方式，微软主张冒泡方式。后来 W3C 采用折中的方式，制定了统一的标准——先捕获再冒泡，这个过程具体如下：</p>\n</blockquote>\n<ol>\n<li>捕获阶段<br>即在事件到达预定目标之前捕获它，低版本的IE不支持捕获阶段</li>\n<li>目标阶段<br>事件到达预定目标，其被看成是冒泡阶段的一部分</li>\n<li>冒泡阶段<br>事件被冒泡至window对象，所有现代浏览器都支持事件冒泡</li>\n</ol>\n<p><strong>注：</strong>大多数浏览器都是从<code>window对象</code>开始捕获，然后冒泡至<code>window对象</code>；<br>建议通常都使用事件冒泡，只有在特殊情况下才使用事件捕获。</p>\n<h2 id=\"绑定事件和解绑事件\"><a href=\"#绑定事件和解绑事件\" class=\"headerlink\" title=\"绑定事件和解绑事件\"></a>绑定事件和解绑事件</h2><h3 id=\"W3C\"><a href=\"#W3C\" class=\"headerlink\" title=\"W3C\"></a>W3C</h3><ul>\n<li>绑定事件： <code>target.addEventListener(eventType, listener, bIsUseCapture)</code><br>eventType: 事件类型，比如<code>click</code><br>listener: 事件触发时执行的函数（事件处理程序或事件侦听器）<br>bIsUseCapture： 表示是否在捕获阶段调用事件处理函数，如果为false（默认为false），表示在冒泡阶段调用listener</li>\n<li>解绑事件: <code>target.removeEventListener(eventType, listener, bIsUseCapture)</code><br>参数意义同上</li>\n</ul>\n<h3 id=\"IE\"><a href=\"#IE\" class=\"headerlink\" title=\"IE\"></a>IE</h3><ul>\n<li>绑定事件： <code>target.attachEvent(listenerName, listener)</code><br>listenerName: 事件处理程序的名字，以”on”开头，比如<code>onclick</code><br>listener: 同W3C</li>\n<li>解绑事件： <code>target.detachEvent(listenerName, listener)</code><br>参数意义同上</li>\n</ul>\n<h3 id=\"不同\"><a href=\"#不同\" class=\"headerlink\" title=\"不同\"></a>不同</h3><ol>\n<li>事件处理程序的作用域<br>W3C对应的作用域是事件所依附的目标元素，即<code>this</code>指向当前元素<br>而IE对应的作用域是全局作用域，即<code>this</code>指向window对象</li>\n<li>多个事件处理程序的触发顺序<br>W3C按照添加它们的前后顺序触发，即先添加的先触发<br>而IE恰好相反，先添加的后触发</li>\n<li>事件处理程序的阶段<br>W3C即可以添加到冒泡阶段，也可以添加捕获阶段<br>而IE只能添加到冒泡阶段</li>\n</ol>\n<h3 id=\"相同\"><a href=\"#相同\" class=\"headerlink\" title=\"相同\"></a>相同</h3><p>对于绑定事件和解绑事件，二者都要求解绑时的参数要与绑定时的参数<strong>相同</strong>，这意味着添加的匿名事件处理程序将没法被移除，因为所有声明的匿名函数都是一个新函数，即使二者代码完全一样。</p>\n<h3 id=\"原生JS实现事件绑定函数\"><a href=\"#原生JS实现事件绑定函数\" class=\"headerlink\" title=\"原生JS实现事件绑定函数\"></a>原生JS实现事件绑定函数</h3><p>其接口是<code>target.addEventListener(eventType, listener)</code><br>核心需求就是可以对某一个事件名称绑定多个事件响应函数，大致实现思路就是创建一个类，其中有两个函数，一个 <code>bind</code>一个<code>trigger</code>，分别实现绑定事件和触发事件，然后当触发这个事件名称时，依次按绑定顺序触发相应的响应函数。具体做法是在bind和trigger函数外层作用域创建一个<code>字典对象</code>，用于存储注册的事件及响应函数列表，bind时，如果字典没有则创建一个，key是事件名称，value是数组，里面放着当前注册的响应函数，如果字段中有，那么就直接push到数组即可。trigger时调出来依次触发事件响应函数即可。<br>其中key和value的关系其实是<code>C#中的委托</code>，C#中的委托是一个二级指针，指向一个函数指针数组（当然这些函数必须具有相同的参数列表和返回值，不一样还瞎掺和啥），这个数组中的每一个元素都是一个函数，当调用委托时，数组中的函数将被依次唤起。<br>下面是一个简单的例子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//有待完善</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">attachEvent</span>(<span class=\"params\">eventType, listener</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> objDelegate;</div><div class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">eventType, listener</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(objDelegate[eventType] <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>)&#123;</div><div class=\"line\">            objDelegate[eventType].push(listener);</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            objDelegate[eventType] = [];</div><div class=\"line\">            objDelegate[eventType].push(listener);</div><div class=\"line\">        &#125;</div><div class=\"line\">        that.objDelegate = objDelegate;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trigger</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> args = [];</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">arguments</span>.length; i++)&#123;</div><div class=\"line\">            args.push[<span class=\"built_in\">arguments</span>[i]];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">var</span> listeners = that.objDelegate[eventType];</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index <span class=\"keyword\">in</span> listeners)&#123;</div><div class=\"line\">            listeners[index].apply(that, args);</div><div class=\"line\">            <span class=\"comment\">//listeners.shift();</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"事件代理-委托\"><a href=\"#事件代理-委托\" class=\"headerlink\" title=\"事件代理/委托\"></a>事件代理/委托</h2><blockquote>\n<p>如果你单击了某个button，JS认为单击事件不仅仅发生在button上，换句话说，在单击button的同时，你也单击了button的父元素，甚至也单击了整个页面。</p>\n</blockquote>\n<p>JS的事件委托靠事件冒泡来实现</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>内存占用少： 因为每个事件处理函数都是对象，都会占用内存</li>\n<li>DOM访问次数少： 加快页面的交互就绪时间，因为不管什么时候，只要是访问DOM树中的一个元素，浏览器都会搜索整个DOM树，从中查找匹配的元素</li>\n<li>动态绑定事件： 可以实现当新增子对象时无需再次对其绑定事件，对于动态内容部分尤为合适</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>事件代理的应用应该仅限于上述需求下，如果把所有事件都用代理就可能会出现事件误判，即本不该绑定事件的元素被绑上了事件。</p>\n<h3 id=\"原生JS实现事件委托\"><a href=\"#原生JS实现事件委托\" class=\"headerlink\" title=\"原生JS实现事件委托\"></a>原生JS实现事件委托</h3><blockquote>\n<p>首先说一下事件对象event的常用属性<br>1.target（在IE中为srcElement）属性： 指向事件的实际目标元素<br>2.currentTarget（IE中没有）属性： 事件处理函数的作用域<br>3.type属性： 被触发的事件的类型</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*简单的事件委托，思路如下</div><div class=\"line\"> *1.事件处理程序是绑定在父元素上的</div><div class=\"line\"> *2.事件对象event的target属性（在IE中为srcElement属性）</div><div class=\"line\"> *  是指向实际目标元素的</div><div class=\"line\"> *3.当实际目标元素等于给定元素时，才调用真实的事件处理函数 </div><div class=\"line\">**/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delegateEvent</span>(<span class=\"params\">selector, eventType, listener</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> delegator = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (delegator.addEventListener)&#123;</div><div class=\"line\">        delegator.addEventListener(eventType, listenerFunc, <span class=\"literal\">false</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(delegator.attachEvent)&#123;</div><div class=\"line\">        delegator.attachEvent(<span class=\"string\">\"on\"</span>+eventType, listenerFunc);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        delegator[<span class=\"string\">\"on\"</span>+eventType] = listenerFunc;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 封装实际的事件处理函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">listenerFunc</span>(<span class=\"params\">event</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> event = event || <span class=\"built_in\">window</span>.event;</div><div class=\"line\">        <span class=\"keyword\">var</span> target = event.target || event.srcElement;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span>(target.matchSelector(selector))&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(listener)&#123;</div><div class=\"line\">                listener.call(target, event);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 判断实际目标元素是不是事先给定的元素</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">matchSelector</span>(<span class=\"params\">selector</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> targetElement = <span class=\"keyword\">this</span>;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span> (selector.charAt(<span class=\"number\">0</span>) === <span class=\"string\">\"#\"</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> targetElement.id = selector.slice(<span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (selector.charAt(<span class=\"number\">0</span>) === <span class=\"string\">\".\"</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"string\">\" \"</span> + targetElement.className + <span class=\"string\">\" \"</span>).indexOf(</div><div class=\"line\">                <span class=\"string\">\" \"</span> + selector.slice(<span class=\"number\">1</span>) + <span class=\"string\">\" \"</span>) != <span class=\"number\">-1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> targetElement.tagName.toLowerCase() === selector.toLowerCase();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 调用</span></div><div class=\"line\"><span class=\"keyword\">var</span> outerDiv = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"outerDiv\"</span>);</div><div class=\"line\">outerDiv.delegateEvent(<span class=\"string\">\"#innerDiv\"</span>, <span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(event.target.id);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"模拟事件\"><a href=\"#模拟事件\" class=\"headerlink\" title=\"模拟事件\"></a>模拟事件</h2><p>事件通常由用户操作或通过浏览器的某些功能来触发，但JS也能在任意时刻手动的触发特定事件。<br>这被称为事件模拟，也被称为事件派发或事件广播，在<code>测试Web应用程序</code>时，模拟触发事件是一种极其有用的技术。<br>一般来说模拟触发一个事件要经过以下3步：</p>\n<ol>\n<li>创建一个事件对象event</li>\n<li>对其进行初始化</li>\n<li>调用<code>dispatchEvent</code>（IE下为fireEvent方法）触发这个事件</li>\n</ol>\n<p>在这里就不详细介绍了，留一个印象即可。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>那么接下来就是熟悉各种类型的事件，比如click、文本改变事件等等各种事件。<br>少年，踩坑去吧，看好你…</p>"},{"title":"JS小实践之项目官网开发","description":"俗话说光说不练假把式，知道和会差别是很大的，技术只有经过项目的考验，踩过无数的坑之后，方可说熟练运用。","toc":true,"date":"2016-06-03T08:50:27.000Z","_content":"俗话说光说不练假把式，知道和会差别是很大的，技术只有经过项目的考验，踩过无数的坑之后，方可说熟练运用。正好最近项目要做个网站，作为我们产品的官网，项目组就我一个开发，还有一个architecture，人家自然看不上去写网站，所以就交给我了，恰好我很乐意。\n<!--more-->\n### 技术选型\n由于领导不想在这个网站上花费太多时间，他们的重点都在桌面，所以我就选了**Bootstrap+原生JS+Jinjia2模板+Python Flask**。\n- Bootstrap不必说，中规中矩的一个CSS框架\n- 由于网站也没什么太多交互，原生JS就能直接搞定\n- Jinjia2模板，好用易学，用它写HTML很方便，可以将页脚和页眉都写进父模板中去\n- Flask，作为Python的一个轻量级Web框架，在[Github上排名](https://github.com/showcases/web-application-frameworks)很不错，用在这里绰绰有余\n\n### 踩到的坑\n#### CORS跨域\nXHR（XMLHttpRequest）作为负责Ajax（Asynchronous JavaScript and XML，异步JS和XML）运行的核心对象，最早由微软在IE5中引入，用于通过JS从服务器取得XML数据，在此之后，各大浏览器都实现了相同的特性，使XHR成为了Web的一个标准。\n同源策略是对XHR的一个主要约束，它为通信设置了**同域、同端口、同协议**的限制，默认情况下当使用XHR访问上述限制之外的资源，浏览器会直接驳回跨域请求，并引发错误，触发error事件，此时请求不会到达服务器。\nW3C定义了CORS的实现标准：当发送请求时，在HTTP请求头中附加一个额外的**Origin字段：告诉服务器，我这个请求是从哪里来的**，然后服务器根据这个头部来判断要不要接受这个请求，如果同意，就在**Access-Control-Allow-Origin响应头部中，回发相同的Origin源信息**（如果是公共资源，可以回发`*`），然后浏览器会检查这个响应头部，如果没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求，并触发error事件。\n各大浏览器也根据W3C的这个标准，实现了CORS，但限制很多，比如请求和响应都不包含cookie，**不能自定义请求头部**，坑就在这里，这次我要发送表单到项目组的另一个server，这显然不同源，最重要的是那个server要使用4个自定义的头部，所以即使跨域也不行，我最后的解决方案是把我自己的server作为中介，请求先到我的server，再到项目组的server，响应也经过我的server再到达浏览器。\n\n#### 生成XML数据\n因为提交给项目组server的数据格式是XML，这个在很早之前他们就定好的，所以我这边要把表单数据转成XML格式，这个还好，是个小坑\n\n#### 发送GA事件\n本来想在每个能点的地方都加上click事件，后来想了想，直接把click事件加在document对象上，利用事件冒泡，再利用自定义的ga_info属性就可以了\n\n#### 如何判断是否点击了整个button\n![](http://7xtj85.com1.z0.glb.clouddn.com/%E6%8C%89%E9%92%AE.png)\n在这个案例中我只有两个这样的button，但我觉得这是一个普遍现象，是在每个button都加上click事件，还是在两个button的父元素上只加**一个事件**，我的看法是后者更好，理由如下：首先每个函数都是对象，都会占用内存，内存中的对象越多，性能就越差；其次，必须事先指定所有事件处理函数而导致的DOM访问次数，会延迟整个页面的交互就绪时间。\n第二种方法虽好，但这里有一个坑，就是如果直接在父元素的click事件处理函数里判断button的id属性，会导致一个问题，就是当我点击button里的图片或文字时，会没有反应，原因是click事件一直被传播到了button里的图片或文字，然后再往上冒泡，但此时`event.target`明显不是整个button，判断id属性自然会出错。\n所以必须判断`event.target`是不是button的子元素，方法如下\n```JavaScript\nfunction isParent (obj,parentObj){\n    while (obj != undefined && obj != null && obj.tagName.toUpperCase() != 'BODY'){\n        if (obj == parentObj){\n            return true;\n        }\n        obj = obj.parentNode;\n        //这里用到了DOM的parentNode属性，指向父元素\n    }\n    return false;\n}\n```\n如果`event.target`为button的子元素，我们就认为整个button被点击了，然后再处理\n\n#### deploy\n部署采用nginx+flask，部署在AWS上，在这个小项目中，前端很简单，后端就更加不用提了。\n[访问网址，有兴趣的话，可以下载我们的产品跑一跑，这也是我一直在负责的产品，如果能帮到你，万分荣幸。](http://devicesecurity.trendmicro.com/)\n\n### 展望\n项目虽小，但还算可以，权当练手，本来还想加点效果的，但领导一直强调不要在网站花费太多的时间，比如表单输入时，没有内容时submit按钮为灰，有内容时才可以提交，这可以用文本输入事件来实现，技术有的时候是相通的，在我们的桌面产品当时实现类似的功能时，也是采用文本输入事件，在没有别人提醒时，我开始还开了两个线程去判断文字有没有改变，被他们笑了好几天，囧。。。\n\n","source":"_posts/JS小实践之项目官网开发.md","raw":"---\ntitle: JS小实践之项目官网开发\ncategories: JavaScript\ntags: [JavaScript, 前端开发]\ndescription: 俗话说光说不练假把式，知道和会差别是很大的，技术只有经过项目的考验，踩过无数的坑之后，方可说熟练运用。\ntoc: true\ndate: 2016-06-03 16:50:27\n---\n俗话说光说不练假把式，知道和会差别是很大的，技术只有经过项目的考验，踩过无数的坑之后，方可说熟练运用。正好最近项目要做个网站，作为我们产品的官网，项目组就我一个开发，还有一个architecture，人家自然看不上去写网站，所以就交给我了，恰好我很乐意。\n<!--more-->\n### 技术选型\n由于领导不想在这个网站上花费太多时间，他们的重点都在桌面，所以我就选了**Bootstrap+原生JS+Jinjia2模板+Python Flask**。\n- Bootstrap不必说，中规中矩的一个CSS框架\n- 由于网站也没什么太多交互，原生JS就能直接搞定\n- Jinjia2模板，好用易学，用它写HTML很方便，可以将页脚和页眉都写进父模板中去\n- Flask，作为Python的一个轻量级Web框架，在[Github上排名](https://github.com/showcases/web-application-frameworks)很不错，用在这里绰绰有余\n\n### 踩到的坑\n#### CORS跨域\nXHR（XMLHttpRequest）作为负责Ajax（Asynchronous JavaScript and XML，异步JS和XML）运行的核心对象，最早由微软在IE5中引入，用于通过JS从服务器取得XML数据，在此之后，各大浏览器都实现了相同的特性，使XHR成为了Web的一个标准。\n同源策略是对XHR的一个主要约束，它为通信设置了**同域、同端口、同协议**的限制，默认情况下当使用XHR访问上述限制之外的资源，浏览器会直接驳回跨域请求，并引发错误，触发error事件，此时请求不会到达服务器。\nW3C定义了CORS的实现标准：当发送请求时，在HTTP请求头中附加一个额外的**Origin字段：告诉服务器，我这个请求是从哪里来的**，然后服务器根据这个头部来判断要不要接受这个请求，如果同意，就在**Access-Control-Allow-Origin响应头部中，回发相同的Origin源信息**（如果是公共资源，可以回发`*`），然后浏览器会检查这个响应头部，如果没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求，并触发error事件。\n各大浏览器也根据W3C的这个标准，实现了CORS，但限制很多，比如请求和响应都不包含cookie，**不能自定义请求头部**，坑就在这里，这次我要发送表单到项目组的另一个server，这显然不同源，最重要的是那个server要使用4个自定义的头部，所以即使跨域也不行，我最后的解决方案是把我自己的server作为中介，请求先到我的server，再到项目组的server，响应也经过我的server再到达浏览器。\n\n#### 生成XML数据\n因为提交给项目组server的数据格式是XML，这个在很早之前他们就定好的，所以我这边要把表单数据转成XML格式，这个还好，是个小坑\n\n#### 发送GA事件\n本来想在每个能点的地方都加上click事件，后来想了想，直接把click事件加在document对象上，利用事件冒泡，再利用自定义的ga_info属性就可以了\n\n#### 如何判断是否点击了整个button\n![](http://7xtj85.com1.z0.glb.clouddn.com/%E6%8C%89%E9%92%AE.png)\n在这个案例中我只有两个这样的button，但我觉得这是一个普遍现象，是在每个button都加上click事件，还是在两个button的父元素上只加**一个事件**，我的看法是后者更好，理由如下：首先每个函数都是对象，都会占用内存，内存中的对象越多，性能就越差；其次，必须事先指定所有事件处理函数而导致的DOM访问次数，会延迟整个页面的交互就绪时间。\n第二种方法虽好，但这里有一个坑，就是如果直接在父元素的click事件处理函数里判断button的id属性，会导致一个问题，就是当我点击button里的图片或文字时，会没有反应，原因是click事件一直被传播到了button里的图片或文字，然后再往上冒泡，但此时`event.target`明显不是整个button，判断id属性自然会出错。\n所以必须判断`event.target`是不是button的子元素，方法如下\n```JavaScript\nfunction isParent (obj,parentObj){\n    while (obj != undefined && obj != null && obj.tagName.toUpperCase() != 'BODY'){\n        if (obj == parentObj){\n            return true;\n        }\n        obj = obj.parentNode;\n        //这里用到了DOM的parentNode属性，指向父元素\n    }\n    return false;\n}\n```\n如果`event.target`为button的子元素，我们就认为整个button被点击了，然后再处理\n\n#### deploy\n部署采用nginx+flask，部署在AWS上，在这个小项目中，前端很简单，后端就更加不用提了。\n[访问网址，有兴趣的话，可以下载我们的产品跑一跑，这也是我一直在负责的产品，如果能帮到你，万分荣幸。](http://devicesecurity.trendmicro.com/)\n\n### 展望\n项目虽小，但还算可以，权当练手，本来还想加点效果的，但领导一直强调不要在网站花费太多的时间，比如表单输入时，没有内容时submit按钮为灰，有内容时才可以提交，这可以用文本输入事件来实现，技术有的时候是相通的，在我们的桌面产品当时实现类似的功能时，也是采用文本输入事件，在没有别人提醒时，我开始还开了两个线程去判断文字有没有改变，被他们笑了好几天，囧。。。\n\n","slug":"JS小实践之项目官网开发","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrp9000g526rozx0x431","content":"<p>俗话说光说不练假把式，知道和会差别是很大的，技术只有经过项目的考验，踩过无数的坑之后，方可说熟练运用。正好最近项目要做个网站，作为我们产品的官网，项目组就我一个开发，还有一个architecture，人家自然看不上去写网站，所以就交给我了，恰好我很乐意。<br><a id=\"more\"></a></p>\n<h3 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h3><p>由于领导不想在这个网站上花费太多时间，他们的重点都在桌面，所以我就选了<strong>Bootstrap+原生JS+Jinjia2模板+Python Flask</strong>。</p>\n<ul>\n<li>Bootstrap不必说，中规中矩的一个CSS框架</li>\n<li>由于网站也没什么太多交互，原生JS就能直接搞定</li>\n<li>Jinjia2模板，好用易学，用它写HTML很方便，可以将页脚和页眉都写进父模板中去</li>\n<li>Flask，作为Python的一个轻量级Web框架，在<a href=\"https://github.com/showcases/web-application-frameworks\" target=\"_blank\" rel=\"external\">Github上排名</a>很不错，用在这里绰绰有余</li>\n</ul>\n<h3 id=\"踩到的坑\"><a href=\"#踩到的坑\" class=\"headerlink\" title=\"踩到的坑\"></a>踩到的坑</h3><h4 id=\"CORS跨域\"><a href=\"#CORS跨域\" class=\"headerlink\" title=\"CORS跨域\"></a>CORS跨域</h4><p>XHR（XMLHttpRequest）作为负责Ajax（Asynchronous JavaScript and XML，异步JS和XML）运行的核心对象，最早由微软在IE5中引入，用于通过JS从服务器取得XML数据，在此之后，各大浏览器都实现了相同的特性，使XHR成为了Web的一个标准。<br>同源策略是对XHR的一个主要约束，它为通信设置了<strong>同域、同端口、同协议</strong>的限制，默认情况下当使用XHR访问上述限制之外的资源，浏览器会直接驳回跨域请求，并引发错误，触发error事件，此时请求不会到达服务器。<br>W3C定义了CORS的实现标准：当发送请求时，在HTTP请求头中附加一个额外的<strong>Origin字段：告诉服务器，我这个请求是从哪里来的</strong>，然后服务器根据这个头部来判断要不要接受这个请求，如果同意，就在<strong>Access-Control-Allow-Origin响应头部中，回发相同的Origin源信息</strong>（如果是公共资源，可以回发<code>*</code>），然后浏览器会检查这个响应头部，如果没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求，并触发error事件。<br>各大浏览器也根据W3C的这个标准，实现了CORS，但限制很多，比如请求和响应都不包含cookie，<strong>不能自定义请求头部</strong>，坑就在这里，这次我要发送表单到项目组的另一个server，这显然不同源，最重要的是那个server要使用4个自定义的头部，所以即使跨域也不行，我最后的解决方案是把我自己的server作为中介，请求先到我的server，再到项目组的server，响应也经过我的server再到达浏览器。</p>\n<h4 id=\"生成XML数据\"><a href=\"#生成XML数据\" class=\"headerlink\" title=\"生成XML数据\"></a>生成XML数据</h4><p>因为提交给项目组server的数据格式是XML，这个在很早之前他们就定好的，所以我这边要把表单数据转成XML格式，这个还好，是个小坑</p>\n<h4 id=\"发送GA事件\"><a href=\"#发送GA事件\" class=\"headerlink\" title=\"发送GA事件\"></a>发送GA事件</h4><p>本来想在每个能点的地方都加上click事件，后来想了想，直接把click事件加在document对象上，利用事件冒泡，再利用自定义的ga_info属性就可以了</p>\n<h4 id=\"如何判断是否点击了整个button\"><a href=\"#如何判断是否点击了整个button\" class=\"headerlink\" title=\"如何判断是否点击了整个button\"></a>如何判断是否点击了整个button</h4><p><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/%E6%8C%89%E9%92%AE.png\" alt=\"\"><br>在这个案例中我只有两个这样的button，但我觉得这是一个普遍现象，是在每个button都加上click事件，还是在两个button的父元素上只加<strong>一个事件</strong>，我的看法是后者更好，理由如下：首先每个函数都是对象，都会占用内存，内存中的对象越多，性能就越差；其次，必须事先指定所有事件处理函数而导致的DOM访问次数，会延迟整个页面的交互就绪时间。<br>第二种方法虽好，但这里有一个坑，就是如果直接在父元素的click事件处理函数里判断button的id属性，会导致一个问题，就是当我点击button里的图片或文字时，会没有反应，原因是click事件一直被传播到了button里的图片或文字，然后再往上冒泡，但此时<code>event.target</code>明显不是整个button，判断id属性自然会出错。<br>所以必须判断<code>event.target</code>是不是button的子元素，方法如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isParent</span> (<span class=\"params\">obj,parentObj</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (obj != <span class=\"literal\">undefined</span> &amp;&amp; obj != <span class=\"literal\">null</span> &amp;&amp; obj.tagName.toUpperCase() != <span class=\"string\">'BODY'</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (obj == parentObj)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        obj = obj.parentNode;</div><div class=\"line\">        <span class=\"comment\">//这里用到了DOM的parentNode属性，指向父元素</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果<code>event.target</code>为button的子元素，我们就认为整个button被点击了，然后再处理</p>\n<h4 id=\"deploy\"><a href=\"#deploy\" class=\"headerlink\" title=\"deploy\"></a>deploy</h4><p>部署采用nginx+flask，部署在AWS上，在这个小项目中，前端很简单，后端就更加不用提了。<br><a href=\"http://devicesecurity.trendmicro.com/\" target=\"_blank\" rel=\"external\">访问网址，有兴趣的话，可以下载我们的产品跑一跑，这也是我一直在负责的产品，如果能帮到你，万分荣幸。</a></p>\n<h3 id=\"展望\"><a href=\"#展望\" class=\"headerlink\" title=\"展望\"></a>展望</h3><p>项目虽小，但还算可以，权当练手，本来还想加点效果的，但领导一直强调不要在网站花费太多的时间，比如表单输入时，没有内容时submit按钮为灰，有内容时才可以提交，这可以用文本输入事件来实现，技术有的时候是相通的，在我们的桌面产品当时实现类似的功能时，也是采用文本输入事件，在没有别人提醒时，我开始还开了两个线程去判断文字有没有改变，被他们笑了好几天，囧。。。</p>\n","excerpt":"<p>俗话说光说不练假把式，知道和会差别是很大的，技术只有经过项目的考验，踩过无数的坑之后，方可说熟练运用。正好最近项目要做个网站，作为我们产品的官网，项目组就我一个开发，还有一个architecture，人家自然看不上去写网站，所以就交给我了，恰好我很乐意。<br>","more":"</p>\n<h3 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h3><p>由于领导不想在这个网站上花费太多时间，他们的重点都在桌面，所以我就选了<strong>Bootstrap+原生JS+Jinjia2模板+Python Flask</strong>。</p>\n<ul>\n<li>Bootstrap不必说，中规中矩的一个CSS框架</li>\n<li>由于网站也没什么太多交互，原生JS就能直接搞定</li>\n<li>Jinjia2模板，好用易学，用它写HTML很方便，可以将页脚和页眉都写进父模板中去</li>\n<li>Flask，作为Python的一个轻量级Web框架，在<a href=\"https://github.com/showcases/web-application-frameworks\">Github上排名</a>很不错，用在这里绰绰有余</li>\n</ul>\n<h3 id=\"踩到的坑\"><a href=\"#踩到的坑\" class=\"headerlink\" title=\"踩到的坑\"></a>踩到的坑</h3><h4 id=\"CORS跨域\"><a href=\"#CORS跨域\" class=\"headerlink\" title=\"CORS跨域\"></a>CORS跨域</h4><p>XHR（XMLHttpRequest）作为负责Ajax（Asynchronous JavaScript and XML，异步JS和XML）运行的核心对象，最早由微软在IE5中引入，用于通过JS从服务器取得XML数据，在此之后，各大浏览器都实现了相同的特性，使XHR成为了Web的一个标准。<br>同源策略是对XHR的一个主要约束，它为通信设置了<strong>同域、同端口、同协议</strong>的限制，默认情况下当使用XHR访问上述限制之外的资源，浏览器会直接驳回跨域请求，并引发错误，触发error事件，此时请求不会到达服务器。<br>W3C定义了CORS的实现标准：当发送请求时，在HTTP请求头中附加一个额外的<strong>Origin字段：告诉服务器，我这个请求是从哪里来的</strong>，然后服务器根据这个头部来判断要不要接受这个请求，如果同意，就在<strong>Access-Control-Allow-Origin响应头部中，回发相同的Origin源信息</strong>（如果是公共资源，可以回发<code>*</code>），然后浏览器会检查这个响应头部，如果没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求，并触发error事件。<br>各大浏览器也根据W3C的这个标准，实现了CORS，但限制很多，比如请求和响应都不包含cookie，<strong>不能自定义请求头部</strong>，坑就在这里，这次我要发送表单到项目组的另一个server，这显然不同源，最重要的是那个server要使用4个自定义的头部，所以即使跨域也不行，我最后的解决方案是把我自己的server作为中介，请求先到我的server，再到项目组的server，响应也经过我的server再到达浏览器。</p>\n<h4 id=\"生成XML数据\"><a href=\"#生成XML数据\" class=\"headerlink\" title=\"生成XML数据\"></a>生成XML数据</h4><p>因为提交给项目组server的数据格式是XML，这个在很早之前他们就定好的，所以我这边要把表单数据转成XML格式，这个还好，是个小坑</p>\n<h4 id=\"发送GA事件\"><a href=\"#发送GA事件\" class=\"headerlink\" title=\"发送GA事件\"></a>发送GA事件</h4><p>本来想在每个能点的地方都加上click事件，后来想了想，直接把click事件加在document对象上，利用事件冒泡，再利用自定义的ga_info属性就可以了</p>\n<h4 id=\"如何判断是否点击了整个button\"><a href=\"#如何判断是否点击了整个button\" class=\"headerlink\" title=\"如何判断是否点击了整个button\"></a>如何判断是否点击了整个button</h4><p><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/%E6%8C%89%E9%92%AE.png\" alt=\"\"><br>在这个案例中我只有两个这样的button，但我觉得这是一个普遍现象，是在每个button都加上click事件，还是在两个button的父元素上只加<strong>一个事件</strong>，我的看法是后者更好，理由如下：首先每个函数都是对象，都会占用内存，内存中的对象越多，性能就越差；其次，必须事先指定所有事件处理函数而导致的DOM访问次数，会延迟整个页面的交互就绪时间。<br>第二种方法虽好，但这里有一个坑，就是如果直接在父元素的click事件处理函数里判断button的id属性，会导致一个问题，就是当我点击button里的图片或文字时，会没有反应，原因是click事件一直被传播到了button里的图片或文字，然后再往上冒泡，但此时<code>event.target</code>明显不是整个button，判断id属性自然会出错。<br>所以必须判断<code>event.target</code>是不是button的子元素，方法如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isParent</span> (<span class=\"params\">obj,parentObj</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (obj != <span class=\"literal\">undefined</span> &amp;&amp; obj != <span class=\"literal\">null</span> &amp;&amp; obj.tagName.toUpperCase() != <span class=\"string\">'BODY'</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (obj == parentObj)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        obj = obj.parentNode;</div><div class=\"line\">        <span class=\"comment\">//这里用到了DOM的parentNode属性，指向父元素</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果<code>event.target</code>为button的子元素，我们就认为整个button被点击了，然后再处理</p>\n<h4 id=\"deploy\"><a href=\"#deploy\" class=\"headerlink\" title=\"deploy\"></a>deploy</h4><p>部署采用nginx+flask，部署在AWS上，在这个小项目中，前端很简单，后端就更加不用提了。<br><a href=\"http://devicesecurity.trendmicro.com/\">访问网址，有兴趣的话，可以下载我们的产品跑一跑，这也是我一直在负责的产品，如果能帮到你，万分荣幸。</a></p>\n<h3 id=\"展望\"><a href=\"#展望\" class=\"headerlink\" title=\"展望\"></a>展望</h3><p>项目虽小，但还算可以，权当练手，本来还想加点效果的，但领导一直强调不要在网站花费太多的时间，比如表单输入时，没有内容时submit按钮为灰，有内容时才可以提交，这可以用文本输入事件来实现，技术有的时候是相通的，在我们的桌面产品当时实现类似的功能时，也是采用文本输入事件，在没有别人提醒时，我开始还开了两个线程去判断文字有没有改变，被他们笑了好几天，囧。。。</p>"},{"title":"JavaScript中的函数形参","toc":true,"date":"2016-05-25T01:50:39.000Z","description":"JavaScript中的函数总体来说与大多数其他语言有所不同","_content":"JavaScript中的函数总体来说与大多数其他语言有所不同\n下面将从返回值、参数传递两个方面进行说明\n<!--more-->\n## 基本语法\n```JavaScript\nfunction functionName(arg0, arg1, ..., argN){\n    statements\n}\n/*以下是一个例子*/\nfunction sayHi(name, message){\n    alert('Hello ' + name + ',' + message);\n}\n/*invoke*/\nsayHi('bruce zhou', 'how are you today?');\n```\n\n## 返回值\n- 在定义时不必指定返回值，因为JS中的函数可以在任何时候返回任何值\n- 未指定返回值的函数（没有return语句或return语句没有带返回值），返回undefined\n\n## 参数传递\n**在JS中，因为函数参数是用一个数组arguments传递的，而其他语言是用形参传递的，所以:**\n- 没有函数声明的概念，命名的形参只提供便利，并不是必需的\n比如你定义的函数只接受两个参数，但在调用的时候，可以传递一个、三个甚至不传递参数\n- 可以向函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数\n- arguments和形参\n - 在函数内部，二者可以一起使用\n - 二者可以互换使用\n - arguments的值和对应形参的值保持**同步**\n **注：**但是二者的内存空间是独立的，只是他们的值会同步\n- 没有传递值的形参将自动被赋予undefined \n- 参数传递是**值传递**，不能通过引用传递参数\n","source":"_posts/JavaScript中的函数形参.md","raw":"---\ntitle: JavaScript中的函数形参\ntoc: true\ndate: 2016-05-25 09:50:39\ncategories: JavaScript\ntags: [JavaScript, 函数, 前端开发]\ndescription: JavaScript中的函数总体来说与大多数其他语言有所不同\n---\nJavaScript中的函数总体来说与大多数其他语言有所不同\n下面将从返回值、参数传递两个方面进行说明\n<!--more-->\n## 基本语法\n```JavaScript\nfunction functionName(arg0, arg1, ..., argN){\n    statements\n}\n/*以下是一个例子*/\nfunction sayHi(name, message){\n    alert('Hello ' + name + ',' + message);\n}\n/*invoke*/\nsayHi('bruce zhou', 'how are you today?');\n```\n\n## 返回值\n- 在定义时不必指定返回值，因为JS中的函数可以在任何时候返回任何值\n- 未指定返回值的函数（没有return语句或return语句没有带返回值），返回undefined\n\n## 参数传递\n**在JS中，因为函数参数是用一个数组arguments传递的，而其他语言是用形参传递的，所以:**\n- 没有函数声明的概念，命名的形参只提供便利，并不是必需的\n比如你定义的函数只接受两个参数，但在调用的时候，可以传递一个、三个甚至不传递参数\n- 可以向函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数\n- arguments和形参\n - 在函数内部，二者可以一起使用\n - 二者可以互换使用\n - arguments的值和对应形参的值保持**同步**\n **注：**但是二者的内存空间是独立的，只是他们的值会同步\n- 没有传递值的形参将自动被赋予undefined \n- 参数传递是**值传递**，不能通过引用传递参数\n","slug":"JavaScript中的函数形参","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrpb000i526rwl7z799f","content":"<p>JavaScript中的函数总体来说与大多数其他语言有所不同<br>下面将从返回值、参数传递两个方面进行说明<br><a id=\"more\"></a></p>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">functionName</span>(<span class=\"params\">arg0, arg1, ..., argN</span>)</span>&#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">/*以下是一个例子*/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\">name, message</span>)</span>&#123;</div><div class=\"line\">    alert(<span class=\"string\">'Hello '</span> + name + <span class=\"string\">','</span> + message);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">/*invoke*/</span></div><div class=\"line\">sayHi(<span class=\"string\">'bruce zhou'</span>, <span class=\"string\">'how are you today?'</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><ul>\n<li>在定义时不必指定返回值，因为JS中的函数可以在任何时候返回任何值</li>\n<li>未指定返回值的函数（没有return语句或return语句没有带返回值），返回undefined</li>\n</ul>\n<h2 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h2><p><strong>在JS中，因为函数参数是用一个数组arguments传递的，而其他语言是用形参传递的，所以:</strong></p>\n<ul>\n<li>没有函数声明的概念，命名的形参只提供便利，并不是必需的<br>比如你定义的函数只接受两个参数，但在调用的时候，可以传递一个、三个甚至不传递参数</li>\n<li>可以向函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数</li>\n<li>arguments和形参<ul>\n<li>在函数内部，二者可以一起使用</li>\n<li>二者可以互换使用</li>\n<li>arguments的值和对应形参的值保持<strong>同步</strong><br><strong>注：</strong>但是二者的内存空间是独立的，只是他们的值会同步</li>\n</ul>\n</li>\n<li>没有传递值的形参将自动被赋予undefined </li>\n<li>参数传递是<strong>值传递</strong>，不能通过引用传递参数</li>\n</ul>\n","excerpt":"<p>JavaScript中的函数总体来说与大多数其他语言有所不同<br>下面将从返回值、参数传递两个方面进行说明<br>","more":"</p>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">functionName</span>(<span class=\"params\">arg0, arg1, ..., argN</span>)</span>&#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">/*以下是一个例子*/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\">name, message</span>)</span>&#123;</div><div class=\"line\">    alert(<span class=\"string\">'Hello '</span> + name + <span class=\"string\">','</span> + message);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">/*invoke*/</span></div><div class=\"line\">sayHi(<span class=\"string\">'bruce zhou'</span>, <span class=\"string\">'how are you today?'</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><ul>\n<li>在定义时不必指定返回值，因为JS中的函数可以在任何时候返回任何值</li>\n<li>未指定返回值的函数（没有return语句或return语句没有带返回值），返回undefined</li>\n</ul>\n<h2 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h2><p><strong>在JS中，因为函数参数是用一个数组arguments传递的，而其他语言是用形参传递的，所以:</strong></p>\n<ul>\n<li>没有函数声明的概念，命名的形参只提供便利，并不是必需的<br>比如你定义的函数只接受两个参数，但在调用的时候，可以传递一个、三个甚至不传递参数</li>\n<li>可以向函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数</li>\n<li>arguments和形参<ul>\n<li>在函数内部，二者可以一起使用</li>\n<li>二者可以互换使用</li>\n<li>arguments的值和对应形参的值保持<strong>同步</strong><br><strong>注：</strong>但是二者的内存空间是独立的，只是他们的值会同步</li>\n</ul>\n</li>\n<li>没有传递值的形参将自动被赋予undefined </li>\n<li>参数传递是<strong>值传递</strong>，不能通过引用传递参数</li>\n</ul>"},{"title":"Vue.js学习笔记 (1):绑定","description":"本文的关键词是绑定","toc":true,"date":"2016-07-28T05:26:43.000Z","_content":"<!--more-->\n### 初始化\n\n初始化vue时，我们一般指定三个选项：\n- `el`:element，表示MVVM中的View，是一个CSS选择器，是用户实际看到的DOM元素\n- `data`:表示MVVM中的Model，是一个原生的JavaScript对象\n- `methods`:View可以触发的函数\n\n还有其他的一些选项，可以在[Vue.js的API文档](http://vuejs.org.cn/api/)中查看。\n\nVue.js 提供的核心是 MVVM 中的 VM，也就是 `ViewModel`，其负责`连接` View 和 Model，保证视图和数据的一致性，因此在一些文档中经常会使用 `vm` 这个变量名。\n\n### 例1\n```JavaScript\n<div id=\"demo\">\n    <p>{{message}}</p>\n    <input v-model=\"message\">\n</div>\n\nvar data = {\n    message: 'Hello Vue.js!'\n}\n\nvar vm = new Vue({\n    el: '#demo',\n    data: data\n})\n```\n在创建vm对象的过程中，其实 Vue.js `已经建立了DOM元素和数据data之间的连接`,\n即把二者`绑定`在了一起，这表示对 data.message 的任何改动，都会触发 DOM的更新。 \n同样当用户在输入栏里打字的时候，数据会被同步回 data.message 当中去,\n这也说明在MVVM中，`Model和View是双向绑定的`，即若修改了View，则Model会立即改变，同样的若修改了Model，则View也会立即改变。\n\n### 例2\n```JavaScript\n<a v-bind:href=\"url\">test</a>\n```\n这里的href是v-bind指令的参数，它告诉v-bind指令将元素的href属性跟表达式url的值`绑定`在一起\n\n### 参考资料\n[官方文档](http://vuejs.org.cn/guide/)\n[Vue.js 中文入门](http://www.html-js.com/article/column/99)\n\n","source":"_posts/Vue-js学习笔记-1-绑定.md","raw":"---\ntitle: Vue.js学习笔记 (1):绑定\ncategories: JavaScript\ntags: [JavaScript, Vue, 前端开发]\ndescription: 本文的关键词是绑定\ntoc: true\ndate: 2016-07-28 13:26:43\n---\n<!--more-->\n### 初始化\n\n初始化vue时，我们一般指定三个选项：\n- `el`:element，表示MVVM中的View，是一个CSS选择器，是用户实际看到的DOM元素\n- `data`:表示MVVM中的Model，是一个原生的JavaScript对象\n- `methods`:View可以触发的函数\n\n还有其他的一些选项，可以在[Vue.js的API文档](http://vuejs.org.cn/api/)中查看。\n\nVue.js 提供的核心是 MVVM 中的 VM，也就是 `ViewModel`，其负责`连接` View 和 Model，保证视图和数据的一致性，因此在一些文档中经常会使用 `vm` 这个变量名。\n\n### 例1\n```JavaScript\n<div id=\"demo\">\n    <p>{{message}}</p>\n    <input v-model=\"message\">\n</div>\n\nvar data = {\n    message: 'Hello Vue.js!'\n}\n\nvar vm = new Vue({\n    el: '#demo',\n    data: data\n})\n```\n在创建vm对象的过程中，其实 Vue.js `已经建立了DOM元素和数据data之间的连接`,\n即把二者`绑定`在了一起，这表示对 data.message 的任何改动，都会触发 DOM的更新。 \n同样当用户在输入栏里打字的时候，数据会被同步回 data.message 当中去,\n这也说明在MVVM中，`Model和View是双向绑定的`，即若修改了View，则Model会立即改变，同样的若修改了Model，则View也会立即改变。\n\n### 例2\n```JavaScript\n<a v-bind:href=\"url\">test</a>\n```\n这里的href是v-bind指令的参数，它告诉v-bind指令将元素的href属性跟表达式url的值`绑定`在一起\n\n### 参考资料\n[官方文档](http://vuejs.org.cn/guide/)\n[Vue.js 中文入门](http://www.html-js.com/article/column/99)\n\n","slug":"Vue-js学习笔记-1-绑定","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrpf000m526rctu3t9t6","content":"<a id=\"more\"></a>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>初始化vue时，我们一般指定三个选项：</p>\n<ul>\n<li><code>el</code>:element，表示MVVM中的View，是一个CSS选择器，是用户实际看到的DOM元素</li>\n<li><code>data</code>:表示MVVM中的Model，是一个原生的JavaScript对象</li>\n<li><code>methods</code>:View可以触发的函数</li>\n</ul>\n<p>还有其他的一些选项，可以在<a href=\"http://vuejs.org.cn/api/\" target=\"_blank\" rel=\"external\">Vue.js的API文档</a>中查看。</p>\n<p>Vue.js 提供的核心是 MVVM 中的 VM，也就是 <code>ViewModel</code>，其负责<code>连接</code> View 和 Model，保证视图和数据的一致性，因此在一些文档中经常会使用 <code>vm</code> 这个变量名。</p>\n<h3 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=<span class=\"string\">\"demo\"</span>&gt;</div><div class=\"line\">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</div><div class=\"line\">    &lt;input v-model=<span class=\"string\">\"message\"</span>&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;</div><div class=\"line\">    message: <span class=\"string\">'Hello Vue.js!'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">    el: <span class=\"string\">'#demo'</span>,</div><div class=\"line\">    data: data</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在创建vm对象的过程中，其实 Vue.js <code>已经建立了DOM元素和数据data之间的连接</code>,<br>即把二者<code>绑定</code>在了一起，这表示对 data.message 的任何改动，都会触发 DOM的更新。<br>同样当用户在输入栏里打字的时候，数据会被同步回 data.message 当中去,<br>这也说明在MVVM中，<code>Model和View是双向绑定的</code>，即若修改了View，则Model会立即改变，同样的若修改了Model，则View也会立即改变。</p>\n<h3 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;a v-bind:href=<span class=\"string\">\"url\"</span>&gt;test&lt;<span class=\"regexp\">/a&gt;</span></div></pre></td></tr></table></figure>\n<p>这里的href是v-bind指令的参数，它告诉v-bind指令将元素的href属性跟表达式url的值<code>绑定</code>在一起</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://vuejs.org.cn/guide/\" target=\"_blank\" rel=\"external\">官方文档</a><br><a href=\"http://www.html-js.com/article/column/99\" target=\"_blank\" rel=\"external\">Vue.js 中文入门</a></p>\n","excerpt":"","more":"<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>初始化vue时，我们一般指定三个选项：</p>\n<ul>\n<li><code>el</code>:element，表示MVVM中的View，是一个CSS选择器，是用户实际看到的DOM元素</li>\n<li><code>data</code>:表示MVVM中的Model，是一个原生的JavaScript对象</li>\n<li><code>methods</code>:View可以触发的函数</li>\n</ul>\n<p>还有其他的一些选项，可以在<a href=\"http://vuejs.org.cn/api/\">Vue.js的API文档</a>中查看。</p>\n<p>Vue.js 提供的核心是 MVVM 中的 VM，也就是 <code>ViewModel</code>，其负责<code>连接</code> View 和 Model，保证视图和数据的一致性，因此在一些文档中经常会使用 <code>vm</code> 这个变量名。</p>\n<h3 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=<span class=\"string\">\"demo\"</span>&gt;</div><div class=\"line\">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</div><div class=\"line\">    &lt;input v-model=<span class=\"string\">\"message\"</span>&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;</div><div class=\"line\">    message: <span class=\"string\">'Hello Vue.js!'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">    el: <span class=\"string\">'#demo'</span>,</div><div class=\"line\">    data: data</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在创建vm对象的过程中，其实 Vue.js <code>已经建立了DOM元素和数据data之间的连接</code>,<br>即把二者<code>绑定</code>在了一起，这表示对 data.message 的任何改动，都会触发 DOM的更新。<br>同样当用户在输入栏里打字的时候，数据会被同步回 data.message 当中去,<br>这也说明在MVVM中，<code>Model和View是双向绑定的</code>，即若修改了View，则Model会立即改变，同样的若修改了Model，则View也会立即改变。</p>\n<h3 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;a v-bind:href=<span class=\"string\">\"url\"</span>&gt;test&lt;<span class=\"regexp\">/a&gt;</span></div></pre></td></tr></table></figure>\n<p>这里的href是v-bind指令的参数，它告诉v-bind指令将元素的href属性跟表达式url的值<code>绑定</code>在一起</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://vuejs.org.cn/guide/\">官方文档</a><br><a href=\"http://www.html-js.com/article/column/99\">Vue.js 中文入门</a></p>"},{"title":"Vue.js学习笔记 (2):指令","description":null,"toc":true,"date":"2016-07-28T06:02:51.000Z","_content":"<!--more-->\n### 绑定表达式\n在 Vue.js 中，一段绑定表达式由一个简单的 JavaScript 表达式和可选的一个或多个过滤器构成。\n其可以用在`{% raw %}{{  }}{% endraw %}`、`{% raw %}{{{  }}}{% endraw %}`内，也可以作为指令的值。\n\n### 指令\n指令都带有`前缀v-`，以指示它们是Vue.js提供的特殊属性。\n指令的值被限定为绑定表达式，其的作用是把表达式的值和DOM元素`绑定`起来。\n\n#### 参数\n有些指令可以在其名称后面带一个“参数” (Argument)，中间放一个`冒号`隔开。\n```JavaScript\n<a v-bind:href=\"url\"></a>\n```\n\n#### 修饰符\n修饰符 (Modifiers) 是以`半角句号 . `开始的特殊后缀，用于表示指令应当以特殊方式绑定。\n```JavaScript\n<input v-model=\"newTodo\" v-on:keyup.enter=\"addTodo\">\n```\n\n#### 常用指令\n- v-on：监听DOM事件，事件类型可以作为它的参数\n- v-bind：绑定HTML属性\n- v-text：等同于{% raw %}{{}}{% endraw %}\n- v-componet：自定义组件\n- v-for：循环\n\n### 参考资料\n[官方文档](http://vuejs.org.cn/guide/)\n[Vue.js 中文入门](http://www.html-js.com/article/column/99)\n","source":"_posts/Vue-js学习笔记-2-指令.md","raw":"---\ntitle: Vue.js学习笔记 (2):指令\ncategories: JavaScript\ntags: [JavaScript, Vue, 前端开发]\ndescription: \ntoc: true\ndate: 2016-07-28 14:02:51\n---\n<!--more-->\n### 绑定表达式\n在 Vue.js 中，一段绑定表达式由一个简单的 JavaScript 表达式和可选的一个或多个过滤器构成。\n其可以用在`{% raw %}{{  }}{% endraw %}`、`{% raw %}{{{  }}}{% endraw %}`内，也可以作为指令的值。\n\n### 指令\n指令都带有`前缀v-`，以指示它们是Vue.js提供的特殊属性。\n指令的值被限定为绑定表达式，其的作用是把表达式的值和DOM元素`绑定`起来。\n\n#### 参数\n有些指令可以在其名称后面带一个“参数” (Argument)，中间放一个`冒号`隔开。\n```JavaScript\n<a v-bind:href=\"url\"></a>\n```\n\n#### 修饰符\n修饰符 (Modifiers) 是以`半角句号 . `开始的特殊后缀，用于表示指令应当以特殊方式绑定。\n```JavaScript\n<input v-model=\"newTodo\" v-on:keyup.enter=\"addTodo\">\n```\n\n#### 常用指令\n- v-on：监听DOM事件，事件类型可以作为它的参数\n- v-bind：绑定HTML属性\n- v-text：等同于{% raw %}{{}}{% endraw %}\n- v-componet：自定义组件\n- v-for：循环\n\n### 参考资料\n[官方文档](http://vuejs.org.cn/guide/)\n[Vue.js 中文入门](http://www.html-js.com/article/column/99)\n","slug":"Vue-js学习笔记-2-指令","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrph000o526r8rlkm3r1","content":"<a id=\"more\"></a>\n<h3 id=\"绑定表达式\"><a href=\"#绑定表达式\" class=\"headerlink\" title=\"绑定表达式\"></a>绑定表达式</h3><p>在 Vue.js 中，一段绑定表达式由一个简单的 JavaScript 表达式和可选的一个或多个过滤器构成。<br>其可以用在<code>{{  }}</code>、<code>{{{  }}}</code>内，也可以作为指令的值。</p>\n<h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><p>指令都带有<code>前缀v-</code>，以指示它们是Vue.js提供的特殊属性。<br>指令的值被限定为绑定表达式，其的作用是把表达式的值和DOM元素<code>绑定</code>起来。</p>\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>有些指令可以在其名称后面带一个“参数” (Argument)，中间放一个<code>冒号</code>隔开。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;a v-bind:href=<span class=\"string\">\"url\"</span>&gt;&lt;/a&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h4><p>修饰符 (Modifiers) 是以<code>半角句号 .</code>开始的特殊后缀，用于表示指令应当以特殊方式绑定。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input v-model=<span class=\"string\">\"newTodo\"</span> v-on:keyup.enter=<span class=\"string\">\"addTodo\"</span>&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h4><ul>\n<li>v-on：监听DOM事件，事件类型可以作为它的参数</li>\n<li>v-bind：绑定HTML属性</li>\n<li>v-text：等同于{{}}</li>\n<li>v-componet：自定义组件</li>\n<li>v-for：循环</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://vuejs.org.cn/guide/\" target=\"_blank\" rel=\"external\">官方文档</a><br><a href=\"http://www.html-js.com/article/column/99\" target=\"_blank\" rel=\"external\">Vue.js 中文入门</a></p>\n","excerpt":"","more":"<h3 id=\"绑定表达式\"><a href=\"#绑定表达式\" class=\"headerlink\" title=\"绑定表达式\"></a>绑定表达式</h3><p>在 Vue.js 中，一段绑定表达式由一个简单的 JavaScript 表达式和可选的一个或多个过滤器构成。<br>其可以用在<code>{{  }}</code>、<code>{{{  }}}</code>内，也可以作为指令的值。</p>\n<h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><p>指令都带有<code>前缀v-</code>，以指示它们是Vue.js提供的特殊属性。<br>指令的值被限定为绑定表达式，其的作用是把表达式的值和DOM元素<code>绑定</code>起来。</p>\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>有些指令可以在其名称后面带一个“参数” (Argument)，中间放一个<code>冒号</code>隔开。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;a v-bind:href=<span class=\"string\">\"url\"</span>&gt;&lt;/a&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h4><p>修饰符 (Modifiers) 是以<code>半角句号 .</code>开始的特殊后缀，用于表示指令应当以特殊方式绑定。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input v-model=<span class=\"string\">\"newTodo\"</span> v-on:keyup.enter=<span class=\"string\">\"addTodo\"</span>&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h4><ul>\n<li>v-on：监听DOM事件，事件类型可以作为它的参数</li>\n<li>v-bind：绑定HTML属性</li>\n<li>v-text：等同于{{}}</li>\n<li>v-componet：自定义组件</li>\n<li>v-for：循环</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://vuejs.org.cn/guide/\">官方文档</a><br><a href=\"http://www.html-js.com/article/column/99\">Vue.js 中文入门</a></p>"},{"title":"初次通读代码大全2","description":"它山之石，可以攻玉，在软件开发领域，借鉴前人们的经验是一个快速提升的捷径。","toc":true,"date":"2016-06-30T02:33:34.000Z","_content":"<!--more-->\n它山之石，可以攻玉，在软件开发领域，借鉴前人们的经验是一个快速提升的捷径，而代码大全作为编程的最佳实践，它讲了很多实际开发中可能并没有考虑到的情况，然而随着编程经验的丰富可能会犯很多人犯过的错误，它告诉我们很多不必要的错误是可以避免的，但是需要你遵循规范来进行软件构建这项活动。\n一些有创造精神的程序员，他们都有一个很明显的特点，就是特别聪明，他们将各种标准规范和前人的经验看成是束缚其创造力的东西，我以前也是这样认为的，但工作中发现当代码量一旦超过2万行，如果抽象的不好的话，每天的时间就是在代码中翻来翻去的，效率非常之低，而代码大全2是刚进入公司时每个人的标配，人手一本，刚来时比较忙，幸好后来有时间，就给自己定了个计划，抽了3个月的时间，天天没事时就看这本书，经典就是经典，确实受益匪浅。\n我就我感受很深的几个部分，和大家做个分享，权当抛砖引玉，有不对之处，虚心接受指正。\n\n# 软件构建的首要技术使命就是管理复杂度\n> 没有谁的大脑能装得下一个现代的计算机程序，也就是说作为一名软件开发人员，我们不应该试着\n> 在同一时间把整个程序都塞进自己的大脑，而应该试着以某种方式去组织程序，以便`能够在一个时\n> 刻可以专注于一个特定的部分`。\n\n首先要明白两点\n第一是：要相信阅读代码的次数要远远大于编写代码的次数\n第二是：程序首先是为人写的，其次才是为机器\n在本书中围绕`复杂度这个中心`也讲了很多话题，比如变量、语句等这些编程的基本要素，还有如何构建一个类、如何构建一个高质量的子程序、防御式编程、命名、重构、代码布局等等一系列话题,可谓不无巨细。不过深入理解一下，这些内容都是复杂度这个中心话题展开的，也就是软件构建的首要技术使命就是管理复杂度，，而这些方法论产生的根源就在于`人脑恒久不变的智力水平同计算机日益增强的计算能力以及软件项目复杂程度之间的矛盾`。书中常常会提到几个数字，差不多在`7左右`变化，对于人的理解力来说，7是一个神奇的数字，心理学研究发现，通常人类很难公式记住超过7个单位的信息，这一发现已经应用于各种领域了，因为这是人脑智力管理的极限，多了，就管不过来了，比如:\n- 类成员变量应该控制在7加减2（即5个或9个）\n- 继承层次应该限制在最多6层之内，类与类之间有依赖、关联、聚合、组合、实现、继承六种关系，而继承是这6种关系中耦合程度最强的一种，因为父类变子类也会变，子类应该保存父类中的所有假设。继承出现的常见场景有：A是一个B以及利用继承去消除大量的case语句，如果A有一个B，则应该使用聚合或组合。对于继承说这么多，是因为继承往往会让你和软件构建的首要技术使命（即管理复杂度）背道而驰，从控制复杂度的角度来说，你应该对继承持有非常歧视的态度\n- 把子程序的参数个数控制在7个之内，其实，别说7个了，没有现代IDE的帮助，我连4个以上的参数我都记不住\n- 小心危险的深层嵌套，像于If，循环，要保持嵌套层次不能多于6层，而据实际调查，一般3层以上的嵌套就会使程序员非常的困惑和抓狂了\n\n想要管理复杂度，从作者的书中总结一下，大概有以下几点：\n- 分割并`隐藏信息`，既然大脑管不过来，那就把系统进行分割，也就是从设计角度上`抽象`出若干个部分，并将各个部分的变化隐藏在其内部，集中控制它，并且要针对接口编程，只要接口不变，不管每个部分的内部如何变化，都不会将变化波及其他部分，而良好的类接口就像是冰山一角一样，让类的大部分内容都不会暴露出来\n- 清晰的表达，也就是增加程序的可读性，书上也围绕着这个不断的论述，上面提到那些事无巨细的部分反复的说着这一点，甚至连命名都有专门的一章来讨论\n这样下来每次大脑就focus在一个部分上，这点我是有深刻体会，虽然我现在完全自己做的东西超不过30000行，不过也不能妄想自己把所有的部分都记住，如果抽象的不好的话，我就特别头疼，每天在代码中翻来翻去的，效率非常低。\n\n## 命名\n> 良好的编程习惯是：恰当的注释、良好的变量和子程序命名方式。\n\n命名不仅仅局限在变量和子程序，也包括为类、包、文件以及其他的编程实体命名，通常命名你需要注意以下三个方面：\n- 变量的种类（它代表什么）\n- 数据的种类（常量、简单变量、用户自定义类型或类、BOOL变量、临时变量、循环下标），对于不同的类型，命名的方式是不一样的\n- 变量的作用域（私有的、类的、包的、全局的）\n- 一个好记的名字应该反映其意图，即这个变量是用去做什么，并非是什么\n- \n\n## 注释\n注释应说明代码的意图，如果将要注释的代码片段换成同样功能的子程序，注释就像为子程序命名一样\n伪代码开发过程\n## 其他\n通常来说，在一个类中，公有方法、保护方法、私有方法所完成的任务总是呈现一种`逐级一次细化的层次结构`，即保护方法所完成的功能通常比公有方法所实现的功能更为细小琐碎。\n\n\n# 有效编程最重要的工作是思考\n有效编程最重要的工作就是思考，而人思考时通常不会看起来很忙。如果和我共事的程序员总是忙个不停，我会认为他并非优秀的程序员，因为他没有用最有价值的工具——自己的脑袋。\n最理想的状态就是，拿到一个问题，先不要动手，要做到谋定而后动，先想一想或在纸上画一画，然后再键盘上一阵子噼里啪啦，最后只测试一次，OK通过，整个过程是一气呵成，这也许就是所谓的键盘侠吧，哈哈。\n\n## 调试\n通过反复尝试来完成编程\n随机的修改代码，直到你的代码看起来能工作，这样你学不到任何东西，你只是在晃来晃去的浪费时间\n分析问题，解决问题是软件构建过程中的核心行为，而调试就是一个不断提出假设、验证假设的过程，这个过程如同破案一样有趣，要善于从蛛丝马迹中找到root cause。\n调试是能让你更好的理解程序、错误、代码质量和解决问题的良机\n\n## 测试\n测试先行，开发而后的编程是过去十年中所形成的最有用的软件开发实践之一\n不要通过测试去验证你的程序\n\n\n# 最后\n\n","source":"_posts/初次通读代码大全2.md","raw":"---\ntitle: 初次通读代码大全2\ncategories: 基本功\ntags: [代码大全2, 编码规范]\ndescription: 它山之石，可以攻玉，在软件开发领域，借鉴前人们的经验是一个快速提升的捷径。\ntoc: true\ndate: 2016-06-30 10:33:34\n---\n<!--more-->\n它山之石，可以攻玉，在软件开发领域，借鉴前人们的经验是一个快速提升的捷径，而代码大全作为编程的最佳实践，它讲了很多实际开发中可能并没有考虑到的情况，然而随着编程经验的丰富可能会犯很多人犯过的错误，它告诉我们很多不必要的错误是可以避免的，但是需要你遵循规范来进行软件构建这项活动。\n一些有创造精神的程序员，他们都有一个很明显的特点，就是特别聪明，他们将各种标准规范和前人的经验看成是束缚其创造力的东西，我以前也是这样认为的，但工作中发现当代码量一旦超过2万行，如果抽象的不好的话，每天的时间就是在代码中翻来翻去的，效率非常之低，而代码大全2是刚进入公司时每个人的标配，人手一本，刚来时比较忙，幸好后来有时间，就给自己定了个计划，抽了3个月的时间，天天没事时就看这本书，经典就是经典，确实受益匪浅。\n我就我感受很深的几个部分，和大家做个分享，权当抛砖引玉，有不对之处，虚心接受指正。\n\n# 软件构建的首要技术使命就是管理复杂度\n> 没有谁的大脑能装得下一个现代的计算机程序，也就是说作为一名软件开发人员，我们不应该试着\n> 在同一时间把整个程序都塞进自己的大脑，而应该试着以某种方式去组织程序，以便`能够在一个时\n> 刻可以专注于一个特定的部分`。\n\n首先要明白两点\n第一是：要相信阅读代码的次数要远远大于编写代码的次数\n第二是：程序首先是为人写的，其次才是为机器\n在本书中围绕`复杂度这个中心`也讲了很多话题，比如变量、语句等这些编程的基本要素，还有如何构建一个类、如何构建一个高质量的子程序、防御式编程、命名、重构、代码布局等等一系列话题,可谓不无巨细。不过深入理解一下，这些内容都是复杂度这个中心话题展开的，也就是软件构建的首要技术使命就是管理复杂度，，而这些方法论产生的根源就在于`人脑恒久不变的智力水平同计算机日益增强的计算能力以及软件项目复杂程度之间的矛盾`。书中常常会提到几个数字，差不多在`7左右`变化，对于人的理解力来说，7是一个神奇的数字，心理学研究发现，通常人类很难公式记住超过7个单位的信息，这一发现已经应用于各种领域了，因为这是人脑智力管理的极限，多了，就管不过来了，比如:\n- 类成员变量应该控制在7加减2（即5个或9个）\n- 继承层次应该限制在最多6层之内，类与类之间有依赖、关联、聚合、组合、实现、继承六种关系，而继承是这6种关系中耦合程度最强的一种，因为父类变子类也会变，子类应该保存父类中的所有假设。继承出现的常见场景有：A是一个B以及利用继承去消除大量的case语句，如果A有一个B，则应该使用聚合或组合。对于继承说这么多，是因为继承往往会让你和软件构建的首要技术使命（即管理复杂度）背道而驰，从控制复杂度的角度来说，你应该对继承持有非常歧视的态度\n- 把子程序的参数个数控制在7个之内，其实，别说7个了，没有现代IDE的帮助，我连4个以上的参数我都记不住\n- 小心危险的深层嵌套，像于If，循环，要保持嵌套层次不能多于6层，而据实际调查，一般3层以上的嵌套就会使程序员非常的困惑和抓狂了\n\n想要管理复杂度，从作者的书中总结一下，大概有以下几点：\n- 分割并`隐藏信息`，既然大脑管不过来，那就把系统进行分割，也就是从设计角度上`抽象`出若干个部分，并将各个部分的变化隐藏在其内部，集中控制它，并且要针对接口编程，只要接口不变，不管每个部分的内部如何变化，都不会将变化波及其他部分，而良好的类接口就像是冰山一角一样，让类的大部分内容都不会暴露出来\n- 清晰的表达，也就是增加程序的可读性，书上也围绕着这个不断的论述，上面提到那些事无巨细的部分反复的说着这一点，甚至连命名都有专门的一章来讨论\n这样下来每次大脑就focus在一个部分上，这点我是有深刻体会，虽然我现在完全自己做的东西超不过30000行，不过也不能妄想自己把所有的部分都记住，如果抽象的不好的话，我就特别头疼，每天在代码中翻来翻去的，效率非常低。\n\n## 命名\n> 良好的编程习惯是：恰当的注释、良好的变量和子程序命名方式。\n\n命名不仅仅局限在变量和子程序，也包括为类、包、文件以及其他的编程实体命名，通常命名你需要注意以下三个方面：\n- 变量的种类（它代表什么）\n- 数据的种类（常量、简单变量、用户自定义类型或类、BOOL变量、临时变量、循环下标），对于不同的类型，命名的方式是不一样的\n- 变量的作用域（私有的、类的、包的、全局的）\n- 一个好记的名字应该反映其意图，即这个变量是用去做什么，并非是什么\n- \n\n## 注释\n注释应说明代码的意图，如果将要注释的代码片段换成同样功能的子程序，注释就像为子程序命名一样\n伪代码开发过程\n## 其他\n通常来说，在一个类中，公有方法、保护方法、私有方法所完成的任务总是呈现一种`逐级一次细化的层次结构`，即保护方法所完成的功能通常比公有方法所实现的功能更为细小琐碎。\n\n\n# 有效编程最重要的工作是思考\n有效编程最重要的工作就是思考，而人思考时通常不会看起来很忙。如果和我共事的程序员总是忙个不停，我会认为他并非优秀的程序员，因为他没有用最有价值的工具——自己的脑袋。\n最理想的状态就是，拿到一个问题，先不要动手，要做到谋定而后动，先想一想或在纸上画一画，然后再键盘上一阵子噼里啪啦，最后只测试一次，OK通过，整个过程是一气呵成，这也许就是所谓的键盘侠吧，哈哈。\n\n## 调试\n通过反复尝试来完成编程\n随机的修改代码，直到你的代码看起来能工作，这样你学不到任何东西，你只是在晃来晃去的浪费时间\n分析问题，解决问题是软件构建过程中的核心行为，而调试就是一个不断提出假设、验证假设的过程，这个过程如同破案一样有趣，要善于从蛛丝马迹中找到root cause。\n调试是能让你更好的理解程序、错误、代码质量和解决问题的良机\n\n## 测试\n测试先行，开发而后的编程是过去十年中所形成的最有用的软件开发实践之一\n不要通过测试去验证你的程序\n\n\n# 最后\n\n","slug":"初次通读代码大全2","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrpj000s526rnc5ol3h6","content":"<a id=\"more\"></a>\n<p>它山之石，可以攻玉，在软件开发领域，借鉴前人们的经验是一个快速提升的捷径，而代码大全作为编程的最佳实践，它讲了很多实际开发中可能并没有考虑到的情况，然而随着编程经验的丰富可能会犯很多人犯过的错误，它告诉我们很多不必要的错误是可以避免的，但是需要你遵循规范来进行软件构建这项活动。<br>一些有创造精神的程序员，他们都有一个很明显的特点，就是特别聪明，他们将各种标准规范和前人的经验看成是束缚其创造力的东西，我以前也是这样认为的，但工作中发现当代码量一旦超过2万行，如果抽象的不好的话，每天的时间就是在代码中翻来翻去的，效率非常之低，而代码大全2是刚进入公司时每个人的标配，人手一本，刚来时比较忙，幸好后来有时间，就给自己定了个计划，抽了3个月的时间，天天没事时就看这本书，经典就是经典，确实受益匪浅。<br>我就我感受很深的几个部分，和大家做个分享，权当抛砖引玉，有不对之处，虚心接受指正。</p>\n<h1 id=\"软件构建的首要技术使命就是管理复杂度\"><a href=\"#软件构建的首要技术使命就是管理复杂度\" class=\"headerlink\" title=\"软件构建的首要技术使命就是管理复杂度\"></a>软件构建的首要技术使命就是管理复杂度</h1><blockquote>\n<p>没有谁的大脑能装得下一个现代的计算机程序，也就是说作为一名软件开发人员，我们不应该试着<br>在同一时间把整个程序都塞进自己的大脑，而应该试着以某种方式去组织程序，以便<code>能够在一个时\n刻可以专注于一个特定的部分</code>。</p>\n</blockquote>\n<p>首先要明白两点<br>第一是：要相信阅读代码的次数要远远大于编写代码的次数<br>第二是：程序首先是为人写的，其次才是为机器<br>在本书中围绕<code>复杂度这个中心</code>也讲了很多话题，比如变量、语句等这些编程的基本要素，还有如何构建一个类、如何构建一个高质量的子程序、防御式编程、命名、重构、代码布局等等一系列话题,可谓不无巨细。不过深入理解一下，这些内容都是复杂度这个中心话题展开的，也就是软件构建的首要技术使命就是管理复杂度，，而这些方法论产生的根源就在于<code>人脑恒久不变的智力水平同计算机日益增强的计算能力以及软件项目复杂程度之间的矛盾</code>。书中常常会提到几个数字，差不多在<code>7左右</code>变化，对于人的理解力来说，7是一个神奇的数字，心理学研究发现，通常人类很难公式记住超过7个单位的信息，这一发现已经应用于各种领域了，因为这是人脑智力管理的极限，多了，就管不过来了，比如:</p>\n<ul>\n<li>类成员变量应该控制在7加减2（即5个或9个）</li>\n<li>继承层次应该限制在最多6层之内，类与类之间有依赖、关联、聚合、组合、实现、继承六种关系，而继承是这6种关系中耦合程度最强的一种，因为父类变子类也会变，子类应该保存父类中的所有假设。继承出现的常见场景有：A是一个B以及利用继承去消除大量的case语句，如果A有一个B，则应该使用聚合或组合。对于继承说这么多，是因为继承往往会让你和软件构建的首要技术使命（即管理复杂度）背道而驰，从控制复杂度的角度来说，你应该对继承持有非常歧视的态度</li>\n<li>把子程序的参数个数控制在7个之内，其实，别说7个了，没有现代IDE的帮助，我连4个以上的参数我都记不住</li>\n<li>小心危险的深层嵌套，像于If，循环，要保持嵌套层次不能多于6层，而据实际调查，一般3层以上的嵌套就会使程序员非常的困惑和抓狂了</li>\n</ul>\n<p>想要管理复杂度，从作者的书中总结一下，大概有以下几点：</p>\n<ul>\n<li>分割并<code>隐藏信息</code>，既然大脑管不过来，那就把系统进行分割，也就是从设计角度上<code>抽象</code>出若干个部分，并将各个部分的变化隐藏在其内部，集中控制它，并且要针对接口编程，只要接口不变，不管每个部分的内部如何变化，都不会将变化波及其他部分，而良好的类接口就像是冰山一角一样，让类的大部分内容都不会暴露出来</li>\n<li>清晰的表达，也就是增加程序的可读性，书上也围绕着这个不断的论述，上面提到那些事无巨细的部分反复的说着这一点，甚至连命名都有专门的一章来讨论<br>这样下来每次大脑就focus在一个部分上，这点我是有深刻体会，虽然我现在完全自己做的东西超不过30000行，不过也不能妄想自己把所有的部分都记住，如果抽象的不好的话，我就特别头疼，每天在代码中翻来翻去的，效率非常低。</li>\n</ul>\n<h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h2><blockquote>\n<p>良好的编程习惯是：恰当的注释、良好的变量和子程序命名方式。</p>\n</blockquote>\n<p>命名不仅仅局限在变量和子程序，也包括为类、包、文件以及其他的编程实体命名，通常命名你需要注意以下三个方面：</p>\n<ul>\n<li>变量的种类（它代表什么）</li>\n<li>数据的种类（常量、简单变量、用户自定义类型或类、BOOL变量、临时变量、循环下标），对于不同的类型，命名的方式是不一样的</li>\n<li>变量的作用域（私有的、类的、包的、全局的）</li>\n<li>一个好记的名字应该反映其意图，即这个变量是用去做什么，并非是什么</li>\n<li></li>\n</ul>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>注释应说明代码的意图，如果将要注释的代码片段换成同样功能的子程序，注释就像为子程序命名一样<br>伪代码开发过程</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>通常来说，在一个类中，公有方法、保护方法、私有方法所完成的任务总是呈现一种<code>逐级一次细化的层次结构</code>，即保护方法所完成的功能通常比公有方法所实现的功能更为细小琐碎。</p>\n<h1 id=\"有效编程最重要的工作是思考\"><a href=\"#有效编程最重要的工作是思考\" class=\"headerlink\" title=\"有效编程最重要的工作是思考\"></a>有效编程最重要的工作是思考</h1><p>有效编程最重要的工作就是思考，而人思考时通常不会看起来很忙。如果和我共事的程序员总是忙个不停，我会认为他并非优秀的程序员，因为他没有用最有价值的工具——自己的脑袋。<br>最理想的状态就是，拿到一个问题，先不要动手，要做到谋定而后动，先想一想或在纸上画一画，然后再键盘上一阵子噼里啪啦，最后只测试一次，OK通过，整个过程是一气呵成，这也许就是所谓的键盘侠吧，哈哈。</p>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><p>通过反复尝试来完成编程<br>随机的修改代码，直到你的代码看起来能工作，这样你学不到任何东西，你只是在晃来晃去的浪费时间<br>分析问题，解决问题是软件构建过程中的核心行为，而调试就是一个不断提出假设、验证假设的过程，这个过程如同破案一样有趣，要善于从蛛丝马迹中找到root cause。<br>调试是能让你更好的理解程序、错误、代码质量和解决问题的良机</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>测试先行，开发而后的编程是过去十年中所形成的最有用的软件开发实践之一<br>不要通过测试去验证你的程序</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1>","excerpt":"","more":"<p>它山之石，可以攻玉，在软件开发领域，借鉴前人们的经验是一个快速提升的捷径，而代码大全作为编程的最佳实践，它讲了很多实际开发中可能并没有考虑到的情况，然而随着编程经验的丰富可能会犯很多人犯过的错误，它告诉我们很多不必要的错误是可以避免的，但是需要你遵循规范来进行软件构建这项活动。<br>一些有创造精神的程序员，他们都有一个很明显的特点，就是特别聪明，他们将各种标准规范和前人的经验看成是束缚其创造力的东西，我以前也是这样认为的，但工作中发现当代码量一旦超过2万行，如果抽象的不好的话，每天的时间就是在代码中翻来翻去的，效率非常之低，而代码大全2是刚进入公司时每个人的标配，人手一本，刚来时比较忙，幸好后来有时间，就给自己定了个计划，抽了3个月的时间，天天没事时就看这本书，经典就是经典，确实受益匪浅。<br>我就我感受很深的几个部分，和大家做个分享，权当抛砖引玉，有不对之处，虚心接受指正。</p>\n<h1 id=\"软件构建的首要技术使命就是管理复杂度\"><a href=\"#软件构建的首要技术使命就是管理复杂度\" class=\"headerlink\" title=\"软件构建的首要技术使命就是管理复杂度\"></a>软件构建的首要技术使命就是管理复杂度</h1><blockquote>\n<p>没有谁的大脑能装得下一个现代的计算机程序，也就是说作为一名软件开发人员，我们不应该试着<br>在同一时间把整个程序都塞进自己的大脑，而应该试着以某种方式去组织程序，以便<code>能够在一个时\n刻可以专注于一个特定的部分</code>。</p>\n</blockquote>\n<p>首先要明白两点<br>第一是：要相信阅读代码的次数要远远大于编写代码的次数<br>第二是：程序首先是为人写的，其次才是为机器<br>在本书中围绕<code>复杂度这个中心</code>也讲了很多话题，比如变量、语句等这些编程的基本要素，还有如何构建一个类、如何构建一个高质量的子程序、防御式编程、命名、重构、代码布局等等一系列话题,可谓不无巨细。不过深入理解一下，这些内容都是复杂度这个中心话题展开的，也就是软件构建的首要技术使命就是管理复杂度，，而这些方法论产生的根源就在于<code>人脑恒久不变的智力水平同计算机日益增强的计算能力以及软件项目复杂程度之间的矛盾</code>。书中常常会提到几个数字，差不多在<code>7左右</code>变化，对于人的理解力来说，7是一个神奇的数字，心理学研究发现，通常人类很难公式记住超过7个单位的信息，这一发现已经应用于各种领域了，因为这是人脑智力管理的极限，多了，就管不过来了，比如:</p>\n<ul>\n<li>类成员变量应该控制在7加减2（即5个或9个）</li>\n<li>继承层次应该限制在最多6层之内，类与类之间有依赖、关联、聚合、组合、实现、继承六种关系，而继承是这6种关系中耦合程度最强的一种，因为父类变子类也会变，子类应该保存父类中的所有假设。继承出现的常见场景有：A是一个B以及利用继承去消除大量的case语句，如果A有一个B，则应该使用聚合或组合。对于继承说这么多，是因为继承往往会让你和软件构建的首要技术使命（即管理复杂度）背道而驰，从控制复杂度的角度来说，你应该对继承持有非常歧视的态度</li>\n<li>把子程序的参数个数控制在7个之内，其实，别说7个了，没有现代IDE的帮助，我连4个以上的参数我都记不住</li>\n<li>小心危险的深层嵌套，像于If，循环，要保持嵌套层次不能多于6层，而据实际调查，一般3层以上的嵌套就会使程序员非常的困惑和抓狂了</li>\n</ul>\n<p>想要管理复杂度，从作者的书中总结一下，大概有以下几点：</p>\n<ul>\n<li>分割并<code>隐藏信息</code>，既然大脑管不过来，那就把系统进行分割，也就是从设计角度上<code>抽象</code>出若干个部分，并将各个部分的变化隐藏在其内部，集中控制它，并且要针对接口编程，只要接口不变，不管每个部分的内部如何变化，都不会将变化波及其他部分，而良好的类接口就像是冰山一角一样，让类的大部分内容都不会暴露出来</li>\n<li>清晰的表达，也就是增加程序的可读性，书上也围绕着这个不断的论述，上面提到那些事无巨细的部分反复的说着这一点，甚至连命名都有专门的一章来讨论<br>这样下来每次大脑就focus在一个部分上，这点我是有深刻体会，虽然我现在完全自己做的东西超不过30000行，不过也不能妄想自己把所有的部分都记住，如果抽象的不好的话，我就特别头疼，每天在代码中翻来翻去的，效率非常低。</li>\n</ul>\n<h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h2><blockquote>\n<p>良好的编程习惯是：恰当的注释、良好的变量和子程序命名方式。</p>\n</blockquote>\n<p>命名不仅仅局限在变量和子程序，也包括为类、包、文件以及其他的编程实体命名，通常命名你需要注意以下三个方面：</p>\n<ul>\n<li>变量的种类（它代表什么）</li>\n<li>数据的种类（常量、简单变量、用户自定义类型或类、BOOL变量、临时变量、循环下标），对于不同的类型，命名的方式是不一样的</li>\n<li>变量的作用域（私有的、类的、包的、全局的）</li>\n<li>一个好记的名字应该反映其意图，即这个变量是用去做什么，并非是什么</li>\n<li></li>\n</ul>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>注释应说明代码的意图，如果将要注释的代码片段换成同样功能的子程序，注释就像为子程序命名一样<br>伪代码开发过程</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>通常来说，在一个类中，公有方法、保护方法、私有方法所完成的任务总是呈现一种<code>逐级一次细化的层次结构</code>，即保护方法所完成的功能通常比公有方法所实现的功能更为细小琐碎。</p>\n<h1 id=\"有效编程最重要的工作是思考\"><a href=\"#有效编程最重要的工作是思考\" class=\"headerlink\" title=\"有效编程最重要的工作是思考\"></a>有效编程最重要的工作是思考</h1><p>有效编程最重要的工作就是思考，而人思考时通常不会看起来很忙。如果和我共事的程序员总是忙个不停，我会认为他并非优秀的程序员，因为他没有用最有价值的工具——自己的脑袋。<br>最理想的状态就是，拿到一个问题，先不要动手，要做到谋定而后动，先想一想或在纸上画一画，然后再键盘上一阵子噼里啪啦，最后只测试一次，OK通过，整个过程是一气呵成，这也许就是所谓的键盘侠吧，哈哈。</p>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><p>通过反复尝试来完成编程<br>随机的修改代码，直到你的代码看起来能工作，这样你学不到任何东西，你只是在晃来晃去的浪费时间<br>分析问题，解决问题是软件构建过程中的核心行为，而调试就是一个不断提出假设、验证假设的过程，这个过程如同破案一样有趣，要善于从蛛丝马迹中找到root cause。<br>调试是能让你更好的理解程序、错误、代码质量和解决问题的良机</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>测试先行，开发而后的编程是过去十年中所形成的最有用的软件开发实践之一<br>不要通过测试去验证你的程序</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1>"},{"title":"如何设计一份令人惊艳的PPT","toc":true,"date":"2016-05-21T15:14:31.000Z","description":"利用PPT来表达你的观点","_content":"前言：公司组织了一个学习活动，然后大家每周轮流分享学习成果，下周就轮到我了，被逼无奈学习了一下如何做PPT，记录下来，方便以后查看。干货在最后，干货在最后，干货在最后，重要的事说三遍。\n<!--more-->\n## 四个步骤 ##\n要设计一份漂亮的PPT，通常会经过以下四个步骤\n- 目标分析\n- 结构设计\n- 撰写美化\n- 演示汇报\n\n以下将分别介绍这四个步骤\n\n### 目标分析 ###\n- 做好准备： 优秀的演讲者花费**500%的时间在准备上**，前期的准备决定演讲的成败\n- 确定演示目的： 分析演示对象，确定我们想要观众得到什么，由此可分为分享型和说服型演讲\n\n### 结构设计 ###\n- 结构清晰\n常常采用**议论文的方式，有一个中心论点，然后有许多个分论点**\n使用markdown来列提纲就是一个很好的办法.\n- 重点突出\n80%的演讲内容将会被听众丢失，所以要突出重点，常用策略如下\n - 能够使自己获益\n - 符合自己的兴趣\n - 使听众发笑\n - 与众不同\n - 把文字翻译成图\n \n### 撰写美化 ###\n- 学会使用模板(也称为母版)\n右击一张slide，然后选择layout\n[百度经验-怎样使用幻灯片模板](http://jingyan.baidu.com/article/9989c746605468f648ecfe81.html)\n- 色彩运用\n - 大块配色或主色不过三\n - 内容文字——黑色\n - 边框、背景、图片——彩色，经典背景色：#00172D，#010101，#001F3F \n- 文字编排\n - 建议统一使用黑体、微软雅黑\n - 投影用：最小24，阅读用：最小9\n- 插入图表\n\n### 演示汇报 ###\n- 加入动画\n- [使用演讲者模式](http://jingyan.baidu.com/article/6f2f55a1b8d5b6b5b93e6c27.html)\n\n## 干货 ##\n- [按照以上步骤，我设计了一个PPT，回顾了去年5月份川藏线骑行之旅，在公司的分享活动上讲给了大家，现场效果很赞，当然我讲的也很好，真的不是我骄傲，我发现我有这个天赋，擅长讲故事，有兴趣的话，可以下载下来看看，保证你不会后悔](http://7xtj85.com1.z0.glb.clouddn.com/%E5%B7%9D%E8%97%8F%E7%BA%BF%E9%AA%91%E8%A1%8C%E4%B9%8B%E6%97%85.pptx)\n- [如何做好PPT：公司主管分享给我们的，本篇文章的提纲就来自于这里](http://7xtj85.com1.z0.glb.clouddn.com/%E5%A6%82%E4%BD%95%E5%81%9APPT%28Thomas%E7%9A%84%E5%88%86%E4%BA%AB%29.pptx)\n- 最受欢迎的快捷键\n![最受欢迎的快捷键](http://7xtj85.com1.z0.glb.clouddn.com/ppt_key.png)\n","source":"_posts/如何设计一份令人惊艳的PPT.md","raw":"---\ntitle: 如何设计一份令人惊艳的PPT\ntoc: true\ndate: 2016-05-21 23:14:31\ncategories: 不务正业\ntags: [PPT]\ndescription: 利用PPT来表达你的观点\n---\n前言：公司组织了一个学习活动，然后大家每周轮流分享学习成果，下周就轮到我了，被逼无奈学习了一下如何做PPT，记录下来，方便以后查看。干货在最后，干货在最后，干货在最后，重要的事说三遍。\n<!--more-->\n## 四个步骤 ##\n要设计一份漂亮的PPT，通常会经过以下四个步骤\n- 目标分析\n- 结构设计\n- 撰写美化\n- 演示汇报\n\n以下将分别介绍这四个步骤\n\n### 目标分析 ###\n- 做好准备： 优秀的演讲者花费**500%的时间在准备上**，前期的准备决定演讲的成败\n- 确定演示目的： 分析演示对象，确定我们想要观众得到什么，由此可分为分享型和说服型演讲\n\n### 结构设计 ###\n- 结构清晰\n常常采用**议论文的方式，有一个中心论点，然后有许多个分论点**\n使用markdown来列提纲就是一个很好的办法.\n- 重点突出\n80%的演讲内容将会被听众丢失，所以要突出重点，常用策略如下\n - 能够使自己获益\n - 符合自己的兴趣\n - 使听众发笑\n - 与众不同\n - 把文字翻译成图\n \n### 撰写美化 ###\n- 学会使用模板(也称为母版)\n右击一张slide，然后选择layout\n[百度经验-怎样使用幻灯片模板](http://jingyan.baidu.com/article/9989c746605468f648ecfe81.html)\n- 色彩运用\n - 大块配色或主色不过三\n - 内容文字——黑色\n - 边框、背景、图片——彩色，经典背景色：#00172D，#010101，#001F3F \n- 文字编排\n - 建议统一使用黑体、微软雅黑\n - 投影用：最小24，阅读用：最小9\n- 插入图表\n\n### 演示汇报 ###\n- 加入动画\n- [使用演讲者模式](http://jingyan.baidu.com/article/6f2f55a1b8d5b6b5b93e6c27.html)\n\n## 干货 ##\n- [按照以上步骤，我设计了一个PPT，回顾了去年5月份川藏线骑行之旅，在公司的分享活动上讲给了大家，现场效果很赞，当然我讲的也很好，真的不是我骄傲，我发现我有这个天赋，擅长讲故事，有兴趣的话，可以下载下来看看，保证你不会后悔](http://7xtj85.com1.z0.glb.clouddn.com/%E5%B7%9D%E8%97%8F%E7%BA%BF%E9%AA%91%E8%A1%8C%E4%B9%8B%E6%97%85.pptx)\n- [如何做好PPT：公司主管分享给我们的，本篇文章的提纲就来自于这里](http://7xtj85.com1.z0.glb.clouddn.com/%E5%A6%82%E4%BD%95%E5%81%9APPT%28Thomas%E7%9A%84%E5%88%86%E4%BA%AB%29.pptx)\n- 最受欢迎的快捷键\n![最受欢迎的快捷键](http://7xtj85.com1.z0.glb.clouddn.com/ppt_key.png)\n","slug":"如何设计一份令人惊艳的PPT","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrpl000v526r583pcd69","content":"<p>前言：公司组织了一个学习活动，然后大家每周轮流分享学习成果，下周就轮到我了，被逼无奈学习了一下如何做PPT，记录下来，方便以后查看。干货在最后，干货在最后，干货在最后，重要的事说三遍。<br><a id=\"more\"></a></p>\n<h2 id=\"四个步骤\"><a href=\"#四个步骤\" class=\"headerlink\" title=\"四个步骤\"></a>四个步骤</h2><p>要设计一份漂亮的PPT，通常会经过以下四个步骤</p>\n<ul>\n<li>目标分析</li>\n<li>结构设计</li>\n<li>撰写美化</li>\n<li>演示汇报</li>\n</ul>\n<p>以下将分别介绍这四个步骤</p>\n<h3 id=\"目标分析\"><a href=\"#目标分析\" class=\"headerlink\" title=\"目标分析\"></a>目标分析</h3><ul>\n<li>做好准备： 优秀的演讲者花费<strong>500%的时间在准备上</strong>，前期的准备决定演讲的成败</li>\n<li>确定演示目的： 分析演示对象，确定我们想要观众得到什么，由此可分为分享型和说服型演讲</li>\n</ul>\n<h3 id=\"结构设计\"><a href=\"#结构设计\" class=\"headerlink\" title=\"结构设计\"></a>结构设计</h3><ul>\n<li>结构清晰<br>常常采用<strong>议论文的方式，有一个中心论点，然后有许多个分论点</strong><br>使用markdown来列提纲就是一个很好的办法.</li>\n<li>重点突出<br>80%的演讲内容将会被听众丢失，所以要突出重点，常用策略如下<ul>\n<li>能够使自己获益</li>\n<li>符合自己的兴趣</li>\n<li>使听众发笑</li>\n<li>与众不同</li>\n<li>把文字翻译成图</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"撰写美化\"><a href=\"#撰写美化\" class=\"headerlink\" title=\"撰写美化\"></a>撰写美化</h3><ul>\n<li>学会使用模板(也称为母版)<br>右击一张slide，然后选择layout<br><a href=\"http://jingyan.baidu.com/article/9989c746605468f648ecfe81.html\" target=\"_blank\" rel=\"external\">百度经验-怎样使用幻灯片模板</a></li>\n<li>色彩运用<ul>\n<li>大块配色或主色不过三</li>\n<li>内容文字——黑色</li>\n<li>边框、背景、图片——彩色，经典背景色：#00172D，#010101，#001F3F </li>\n</ul>\n</li>\n<li>文字编排<ul>\n<li>建议统一使用黑体、微软雅黑</li>\n<li>投影用：最小24，阅读用：最小9</li>\n</ul>\n</li>\n<li>插入图表</li>\n</ul>\n<h3 id=\"演示汇报\"><a href=\"#演示汇报\" class=\"headerlink\" title=\"演示汇报\"></a>演示汇报</h3><ul>\n<li>加入动画</li>\n<li><a href=\"http://jingyan.baidu.com/article/6f2f55a1b8d5b6b5b93e6c27.html\" target=\"_blank\" rel=\"external\">使用演讲者模式</a></li>\n</ul>\n<h2 id=\"干货\"><a href=\"#干货\" class=\"headerlink\" title=\"干货\"></a>干货</h2><ul>\n<li><a href=\"http://7xtj85.com1.z0.glb.clouddn.com/%E5%B7%9D%E8%97%8F%E7%BA%BF%E9%AA%91%E8%A1%8C%E4%B9%8B%E6%97%85.pptx\" target=\"_blank\" rel=\"external\">按照以上步骤，我设计了一个PPT，回顾了去年5月份川藏线骑行之旅，在公司的分享活动上讲给了大家，现场效果很赞，当然我讲的也很好，真的不是我骄傲，我发现我有这个天赋，擅长讲故事，有兴趣的话，可以下载下来看看，保证你不会后悔</a></li>\n<li><a href=\"http://7xtj85.com1.z0.glb.clouddn.com/%E5%A6%82%E4%BD%95%E5%81%9APPT%28Thomas%E7%9A%84%E5%88%86%E4%BA%AB%29.pptx\" target=\"_blank\" rel=\"external\">如何做好PPT：公司主管分享给我们的，本篇文章的提纲就来自于这里</a></li>\n<li>最受欢迎的快捷键<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/ppt_key.png\" alt=\"最受欢迎的快捷键\"></li>\n</ul>\n","excerpt":"<p>前言：公司组织了一个学习活动，然后大家每周轮流分享学习成果，下周就轮到我了，被逼无奈学习了一下如何做PPT，记录下来，方便以后查看。干货在最后，干货在最后，干货在最后，重要的事说三遍。<br>","more":"</p>\n<h2 id=\"四个步骤\"><a href=\"#四个步骤\" class=\"headerlink\" title=\"四个步骤\"></a>四个步骤</h2><p>要设计一份漂亮的PPT，通常会经过以下四个步骤</p>\n<ul>\n<li>目标分析</li>\n<li>结构设计</li>\n<li>撰写美化</li>\n<li>演示汇报</li>\n</ul>\n<p>以下将分别介绍这四个步骤</p>\n<h3 id=\"目标分析\"><a href=\"#目标分析\" class=\"headerlink\" title=\"目标分析\"></a>目标分析</h3><ul>\n<li>做好准备： 优秀的演讲者花费<strong>500%的时间在准备上</strong>，前期的准备决定演讲的成败</li>\n<li>确定演示目的： 分析演示对象，确定我们想要观众得到什么，由此可分为分享型和说服型演讲</li>\n</ul>\n<h3 id=\"结构设计\"><a href=\"#结构设计\" class=\"headerlink\" title=\"结构设计\"></a>结构设计</h3><ul>\n<li>结构清晰<br>常常采用<strong>议论文的方式，有一个中心论点，然后有许多个分论点</strong><br>使用markdown来列提纲就是一个很好的办法.</li>\n<li>重点突出<br>80%的演讲内容将会被听众丢失，所以要突出重点，常用策略如下<ul>\n<li>能够使自己获益</li>\n<li>符合自己的兴趣</li>\n<li>使听众发笑</li>\n<li>与众不同</li>\n<li>把文字翻译成图</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"撰写美化\"><a href=\"#撰写美化\" class=\"headerlink\" title=\"撰写美化\"></a>撰写美化</h3><ul>\n<li>学会使用模板(也称为母版)<br>右击一张slide，然后选择layout<br><a href=\"http://jingyan.baidu.com/article/9989c746605468f648ecfe81.html\">百度经验-怎样使用幻灯片模板</a></li>\n<li>色彩运用<ul>\n<li>大块配色或主色不过三</li>\n<li>内容文字——黑色</li>\n<li>边框、背景、图片——彩色，经典背景色：#00172D，#010101，#001F3F </li>\n</ul>\n</li>\n<li>文字编排<ul>\n<li>建议统一使用黑体、微软雅黑</li>\n<li>投影用：最小24，阅读用：最小9</li>\n</ul>\n</li>\n<li>插入图表</li>\n</ul>\n<h3 id=\"演示汇报\"><a href=\"#演示汇报\" class=\"headerlink\" title=\"演示汇报\"></a>演示汇报</h3><ul>\n<li>加入动画</li>\n<li><a href=\"http://jingyan.baidu.com/article/6f2f55a1b8d5b6b5b93e6c27.html\">使用演讲者模式</a></li>\n</ul>\n<h2 id=\"干货\"><a href=\"#干货\" class=\"headerlink\" title=\"干货\"></a>干货</h2><ul>\n<li><a href=\"http://7xtj85.com1.z0.glb.clouddn.com/%E5%B7%9D%E8%97%8F%E7%BA%BF%E9%AA%91%E8%A1%8C%E4%B9%8B%E6%97%85.pptx\">按照以上步骤，我设计了一个PPT，回顾了去年5月份川藏线骑行之旅，在公司的分享活动上讲给了大家，现场效果很赞，当然我讲的也很好，真的不是我骄傲，我发现我有这个天赋，擅长讲故事，有兴趣的话，可以下载下来看看，保证你不会后悔</a></li>\n<li><a href=\"http://7xtj85.com1.z0.glb.clouddn.com/%E5%A6%82%E4%BD%95%E5%81%9APPT%28Thomas%E7%9A%84%E5%88%86%E4%BA%AB%29.pptx\">如何做好PPT：公司主管分享给我们的，本篇文章的提纲就来自于这里</a></li>\n<li>最受欢迎的快捷键<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/ppt_key.png\" alt=\"最受欢迎的快捷键\"></li>\n</ul>"},{"title":"彻底理解JS闭包","description":"闭包并不是JS所独有的，在计算机科学中其是一个普遍的概念，在Python中也有闭包的概念，但闭包在Python应用不是很广泛，JS可谓是把闭包发扬光大，普照你我众猿。","toc":true,"date":"2016-05-29T05:10:28.000Z","_content":"闭包并不是JS所独有的，在计算机科学中其是一个普遍的概念，在Python中也有闭包的概念，但闭包在Python应用不是很广泛，JS可谓是把闭包发扬光大，普照你我众猿。\n<!--more-->\n\n## 闭包现象\n闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见方式，就是在一个函数内部创建另一个函数。\n```JavaScript\nfunction outer(){\n    var context = \"outer\";\n    return function inner(){\n        console.log(context);\n    }\n}\nvar fn = outer();\n//在创建inner函数时，发生了闭包，当outer被返回后，\n//在inner函数中仍然可以访问外部函数outer中的变量，\n//我们称内部函数inner闭包了外部函数outer的context变量。\n\nfn();\n//输出outer\n```\n\n## 原理\n**Hint：**先认真看上一篇文章<深刻理解JS的作用域链>，理解了作用域链再来看闭包都是分分钟的事。\n\n根据作用域链的创建规则，当执行`var fn = outer();`语句时，会创建一个outer函数对应的变量对象。\n然后返回了一个函数inner，inner函数在**创建的时候**（注意还没执行），会事先创建一条作用域链，然后将作用域链的引用赋给inner函数的`内部属性[[Scope]]`，\n**重要的是**上面创建的这条作用域链中的首元结点指向了outer函数对应的变量对象。\n\n**总结：闭包从字面意思理解，即为封闭包含，\n因为内部函数在被创建时，其作用域链对外部函数对应的变量对象存在一个引用，\n而JS采用引用计数的方法进行内存管理，\n所以当外部函数被执行完毕后，其对应的变量对象不会被回收，\n这样就发生了闭包，在外部函数执行完毕后，我们在内部函数中仍然可以访问外部函数作用域中的变量。**\n\n## 闭包的应用\n- 模仿块级作用域\n- 定义函数的public接口，public方法在JS中被称为特权方法\n\n## 一点思考\n越看JS越觉得JS是一门奇葩语言，你说我搞个继承还要通过原型去实现，定义类的public接口还要通过闭包去实现，直接下面这样不好吗，清楚明了？\n```C++\nclass CSubClass : public CBaseClass\n{\npublic:\n    CSubClass():CBaseClass(){};\n    ~CSubClass(void){};\n    void PublicMethod(){};\n\nprotected:\n    virtual BOOL handle_event (HELEMENT he, BEHAVIOR_EVENT_PARAMS& params); \nprivate:\n    std::wstring m_wstrTargetId;\n};\n```\nJS硬要搞的这么奇葩，更多的时候我们应该把精力放在如何设计类上面，包括如何从实际生活中抽象出一个类，这个类要隐藏什么信息，该把什么暴露出来，而且类的接口应该展现出一致的抽象层次；这个类和其他类应该是什么样的关系，按照耦合关系的强弱，分为依赖、关联、聚合、组合、实现、继承；等等。说了这么多，我只有一个感觉JS的命太好了，这个当年10天之内被设计出来的语言，谁也没有想到现如今统一了浏览器，只能怪Java的Applet不给力，然而语言只不过是工具，技术是相通的，重在应用，更多的时候我们不会一个东西，不是对语言本身不了解，更多的时候是对业务不了解，不知道自己要解决什么问题。\n\n","source":"_posts/彻底理解JS闭包.md","raw":"---\ntitle: 彻底理解JS闭包\ncategories: JavaScript\ntags: [JavaScript, 闭包, 前端开发, Scope chain]\ndescription: 闭包并不是JS所独有的，在计算机科学中其是一个普遍的概念，在Python中也有闭包的概念，但闭包在Python应用不是很广泛，JS可谓是把闭包发扬光大，普照你我众猿。\ntoc: true\ndate: 2016-05-29 13:10:28\n---\n闭包并不是JS所独有的，在计算机科学中其是一个普遍的概念，在Python中也有闭包的概念，但闭包在Python应用不是很广泛，JS可谓是把闭包发扬光大，普照你我众猿。\n<!--more-->\n\n## 闭包现象\n闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见方式，就是在一个函数内部创建另一个函数。\n```JavaScript\nfunction outer(){\n    var context = \"outer\";\n    return function inner(){\n        console.log(context);\n    }\n}\nvar fn = outer();\n//在创建inner函数时，发生了闭包，当outer被返回后，\n//在inner函数中仍然可以访问外部函数outer中的变量，\n//我们称内部函数inner闭包了外部函数outer的context变量。\n\nfn();\n//输出outer\n```\n\n## 原理\n**Hint：**先认真看上一篇文章<深刻理解JS的作用域链>，理解了作用域链再来看闭包都是分分钟的事。\n\n根据作用域链的创建规则，当执行`var fn = outer();`语句时，会创建一个outer函数对应的变量对象。\n然后返回了一个函数inner，inner函数在**创建的时候**（注意还没执行），会事先创建一条作用域链，然后将作用域链的引用赋给inner函数的`内部属性[[Scope]]`，\n**重要的是**上面创建的这条作用域链中的首元结点指向了outer函数对应的变量对象。\n\n**总结：闭包从字面意思理解，即为封闭包含，\n因为内部函数在被创建时，其作用域链对外部函数对应的变量对象存在一个引用，\n而JS采用引用计数的方法进行内存管理，\n所以当外部函数被执行完毕后，其对应的变量对象不会被回收，\n这样就发生了闭包，在外部函数执行完毕后，我们在内部函数中仍然可以访问外部函数作用域中的变量。**\n\n## 闭包的应用\n- 模仿块级作用域\n- 定义函数的public接口，public方法在JS中被称为特权方法\n\n## 一点思考\n越看JS越觉得JS是一门奇葩语言，你说我搞个继承还要通过原型去实现，定义类的public接口还要通过闭包去实现，直接下面这样不好吗，清楚明了？\n```C++\nclass CSubClass : public CBaseClass\n{\npublic:\n    CSubClass():CBaseClass(){};\n    ~CSubClass(void){};\n    void PublicMethod(){};\n\nprotected:\n    virtual BOOL handle_event (HELEMENT he, BEHAVIOR_EVENT_PARAMS& params); \nprivate:\n    std::wstring m_wstrTargetId;\n};\n```\nJS硬要搞的这么奇葩，更多的时候我们应该把精力放在如何设计类上面，包括如何从实际生活中抽象出一个类，这个类要隐藏什么信息，该把什么暴露出来，而且类的接口应该展现出一致的抽象层次；这个类和其他类应该是什么样的关系，按照耦合关系的强弱，分为依赖、关联、聚合、组合、实现、继承；等等。说了这么多，我只有一个感觉JS的命太好了，这个当年10天之内被设计出来的语言，谁也没有想到现如今统一了浏览器，只能怪Java的Applet不给力，然而语言只不过是工具，技术是相通的，重在应用，更多的时候我们不会一个东西，不是对语言本身不了解，更多的时候是对业务不了解，不知道自己要解决什么问题。\n\n","slug":"彻底理解JS闭包","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrpq0010526r7pdktk6n","content":"<p>闭包并不是JS所独有的，在计算机科学中其是一个普遍的概念，在Python中也有闭包的概念，但闭包在Python应用不是很广泛，JS可谓是把闭包发扬光大，普照你我众猿。<br><a id=\"more\"></a></p>\n<h2 id=\"闭包现象\"><a href=\"#闭包现象\" class=\"headerlink\" title=\"闭包现象\"></a>闭包现象</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见方式，就是在一个函数内部创建另一个函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outer</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"string\">\"outer\"</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(context);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> fn = outer();</div><div class=\"line\"><span class=\"comment\">//在创建inner函数时，发生了闭包，当outer被返回后，</span></div><div class=\"line\"><span class=\"comment\">//在inner函数中仍然可以访问外部函数outer中的变量，</span></div><div class=\"line\"><span class=\"comment\">//我们称内部函数inner闭包了外部函数outer的context变量。</span></div><div class=\"line\"></div><div class=\"line\">fn();</div><div class=\"line\"><span class=\"comment\">//输出outer</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><strong>Hint：</strong>先认真看上一篇文章&lt;深刻理解JS的作用域链&gt;，理解了作用域链再来看闭包都是分分钟的事。</p>\n<p>根据作用域链的创建规则，当执行<code>var fn = outer();</code>语句时，会创建一个outer函数对应的变量对象。<br>然后返回了一个函数inner，inner函数在<strong>创建的时候</strong>（注意还没执行），会事先创建一条作用域链，然后将作用域链的引用赋给inner函数的<code>内部属性[[Scope]]</code>，<br><strong>重要的是</strong>上面创建的这条作用域链中的首元结点指向了outer函数对应的变量对象。</p>\n<p><strong>总结：闭包从字面意思理解，即为封闭包含，<br>因为内部函数在被创建时，其作用域链对外部函数对应的变量对象存在一个引用，<br>而JS采用引用计数的方法进行内存管理，<br>所以当外部函数被执行完毕后，其对应的变量对象不会被回收，<br>这样就发生了闭包，在外部函数执行完毕后，我们在内部函数中仍然可以访问外部函数作用域中的变量。</strong></p>\n<h2 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h2><ul>\n<li>模仿块级作用域</li>\n<li>定义函数的public接口，public方法在JS中被称为特权方法</li>\n</ul>\n<h2 id=\"一点思考\"><a href=\"#一点思考\" class=\"headerlink\" title=\"一点思考\"></a>一点思考</h2><p>越看JS越觉得JS是一门奇葩语言，你说我搞个继承还要通过原型去实现，定义类的public接口还要通过闭包去实现，直接下面这样不好吗，清楚明了？<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> CSubClass : <span class=\"keyword\">public</span> CBaseClass</div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    CSubClass():CBaseClass()&#123;&#125;;</div><div class=\"line\">    ~CSubClass(<span class=\"keyword\">void</span>)&#123;&#125;;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PublicMethod</span><span class=\"params\">()</span></span>&#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">protected</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> BOOL <span class=\"title\">handle_event</span> <span class=\"params\">(HELEMENT he, BEHAVIOR_EVENT_PARAMS&amp; params)</span></span>; </div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">std</span>::wstring m_wstrTargetId;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>JS硬要搞的这么奇葩，更多的时候我们应该把精力放在如何设计类上面，包括如何从实际生活中抽象出一个类，这个类要隐藏什么信息，该把什么暴露出来，而且类的接口应该展现出一致的抽象层次；这个类和其他类应该是什么样的关系，按照耦合关系的强弱，分为依赖、关联、聚合、组合、实现、继承；等等。说了这么多，我只有一个感觉JS的命太好了，这个当年10天之内被设计出来的语言，谁也没有想到现如今统一了浏览器，只能怪Java的Applet不给力，然而语言只不过是工具，技术是相通的，重在应用，更多的时候我们不会一个东西，不是对语言本身不了解，更多的时候是对业务不了解，不知道自己要解决什么问题。</p>\n","excerpt":"<p>闭包并不是JS所独有的，在计算机科学中其是一个普遍的概念，在Python中也有闭包的概念，但闭包在Python应用不是很广泛，JS可谓是把闭包发扬光大，普照你我众猿。<br>","more":"</p>\n<h2 id=\"闭包现象\"><a href=\"#闭包现象\" class=\"headerlink\" title=\"闭包现象\"></a>闭包现象</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见方式，就是在一个函数内部创建另一个函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outer</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"string\">\"outer\"</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(context);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> fn = outer();</div><div class=\"line\"><span class=\"comment\">//在创建inner函数时，发生了闭包，当outer被返回后，</span></div><div class=\"line\"><span class=\"comment\">//在inner函数中仍然可以访问外部函数outer中的变量，</span></div><div class=\"line\"><span class=\"comment\">//我们称内部函数inner闭包了外部函数outer的context变量。</span></div><div class=\"line\"></div><div class=\"line\">fn();</div><div class=\"line\"><span class=\"comment\">//输出outer</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><strong>Hint：</strong>先认真看上一篇文章&lt;深刻理解JS的作用域链&gt;，理解了作用域链再来看闭包都是分分钟的事。</p>\n<p>根据作用域链的创建规则，当执行<code>var fn = outer();</code>语句时，会创建一个outer函数对应的变量对象。<br>然后返回了一个函数inner，inner函数在<strong>创建的时候</strong>（注意还没执行），会事先创建一条作用域链，然后将作用域链的引用赋给inner函数的<code>内部属性[[Scope]]</code>，<br><strong>重要的是</strong>上面创建的这条作用域链中的首元结点指向了outer函数对应的变量对象。</p>\n<p><strong>总结：闭包从字面意思理解，即为封闭包含，<br>因为内部函数在被创建时，其作用域链对外部函数对应的变量对象存在一个引用，<br>而JS采用引用计数的方法进行内存管理，<br>所以当外部函数被执行完毕后，其对应的变量对象不会被回收，<br>这样就发生了闭包，在外部函数执行完毕后，我们在内部函数中仍然可以访问外部函数作用域中的变量。</strong></p>\n<h2 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h2><ul>\n<li>模仿块级作用域</li>\n<li>定义函数的public接口，public方法在JS中被称为特权方法</li>\n</ul>\n<h2 id=\"一点思考\"><a href=\"#一点思考\" class=\"headerlink\" title=\"一点思考\"></a>一点思考</h2><p>越看JS越觉得JS是一门奇葩语言，你说我搞个继承还要通过原型去实现，定义类的public接口还要通过闭包去实现，直接下面这样不好吗，清楚明了？<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> CSubClass : <span class=\"keyword\">public</span> CBaseClass</div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    CSubClass():CBaseClass()&#123;&#125;;</div><div class=\"line\">    ~CSubClass(<span class=\"keyword\">void</span>)&#123;&#125;;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PublicMethod</span><span class=\"params\">()</span></span>&#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">protected</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> BOOL <span class=\"title\">handle_event</span> <span class=\"params\">(HELEMENT he, BEHAVIOR_EVENT_PARAMS&amp; params)</span></span>; </div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">std</span>::wstring m_wstrTargetId;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>JS硬要搞的这么奇葩，更多的时候我们应该把精力放在如何设计类上面，包括如何从实际生活中抽象出一个类，这个类要隐藏什么信息，该把什么暴露出来，而且类的接口应该展现出一致的抽象层次；这个类和其他类应该是什么样的关系，按照耦合关系的强弱，分为依赖、关联、聚合、组合、实现、继承；等等。说了这么多，我只有一个感觉JS的命太好了，这个当年10天之内被设计出来的语言，谁也没有想到现如今统一了浏览器，只能怪Java的Applet不给力，然而语言只不过是工具，技术是相通的，重在应用，更多的时候我们不会一个东西，不是对语言本身不了解，更多的时候是对业务不了解，不知道自己要解决什么问题。</p>"},{"title":"我为什么选择做前端","toc":true,"date":"2016-05-19T01:37:05.000Z","description":["一枚立志成为大后端程序猿的前端转型之旅"],"_content":"一枚立志成为大后端程序猿的前端转型之旅\n<!--more-->\n## 前端工程师是怎样一种职业 ##\n\n个人感觉前端工程师（front-end engineer，简称FE，下文将用FE来代称）是黑客与画家的完美融合，其最具有成为增长黑客的潜质，FE这个职业简直完全是为我而生。\n\nFE的特点（以下内容是参考一个前端大牛的一篇文章，感觉直击心底，在此先行谢过）\n\n- FE是最接近用户的程序猿\n- FE需要具有优秀的软件开发能力\n- FE需要有较高的沟通能力和理解能力\n- 职业延伸性好\n\n下面将分别介绍\n\n### FE是最接近用户的程序猿 ###\n\n![作为前端工程师最核心的价值或者说是责任，就是将大伙的所有心血和努力最终要完美地呈现给用户。](http://7xtj85.com1.z0.glb.clouddn.com/image/jpg/Front_end.png)\n\n作为FE最核心的价值或者说是责任，就是将大伙的所有心血和努力最终要完美地呈现给用户。\n\n- FE是用户体验的把控者，在产品经理构想出原型，UI设计出交互细节后，FE就要用双手一行一行敲出那些代码。其次FE需要对用户体验有较深的理解，举个例子：比如页面上有一个超链接，字体比较小的情况下，用户可能会一下点不中，因为链接的可点击区域是紧贴着文字边缘的。前端可以通过很简单的方法来扩大这个链接的可点击区域，使得用户更容易点中，这就是用户体验。\n- 懂得用户体验的FE，需要有一点强迫症，不能容忍px级别的瑕疵，需要对美有所领悟，需要执着地追求美，需要有品味，有思想，有大局观，最好还能懂点心理学，会让他的作品与用户沟通，能够touch到用户心中那一块柔软的区域，所以**FE是最接近User的工程师，与User可以说是零距离接触**。\n\n### FE需要具有优秀的软件开发能力 ###\n\n- FE需要完成用户端的业务逻辑，JS是FE需要掌握的编程语言，这要求FE要有软件开发的基础，要具有良好的编码规范；要了解计算机的基础原理，要掌握HTPP；要有架构能力，整合使用现有的优秀框架；了解MVC、MVVM等设计模式。\n- 众所周知，IT行业的知识更新换代很快，这要求程序猿具有快速学习能力。这对前端更是如此，前端现在处于一个百花齐放百家争鸣的阶段，新技术日新月异，这要求一个合格的FE能够保持持续的学习能力，能够对新技术有敏锐的嗅觉，活到老，学到老，说的就是前端工程师。\n\n### FE需要有较高的沟通能力和理解能力 ###\n\n大多数人对程序猿的印象就是情商低、不善言谈。但前端工程师应该是个例外，这是由工作性质决定的。\n\n- 从工作流程来看，FE处于设计师的下游，他要接设计稿，转化为网页。同时又是后端工程师的上游，需要把用户产生的数据提交到服务端。横向来看，他又与产品经理有着密切接触，因为他可能随时和产品经理探讨交互的细节。**这样一个连接着团队中的其他成员的角色，需要他既是一个粘合剂，又是一个润滑剂。**\n\n- **前端工程师需要有较高的沟通能力和理解能力**。我们经常开玩笑说“<strong>设计师活在童话故事里</strong>”，因为有时候他们设计的页面根本不符合常规，无法实现。这个时候你就需要耐心的给设计MM讲原理、讲原因，并且告诉她设计需要遵循哪些基本规范。对于<strong>产品经理</strong>的思想，你要能把握到位，**你得理解他比划了半天到底是想要做什么**。与<strong>后端工程师</strong>打交道的时候，你又得马上化身编程达人，跟他们聊数据类型，聊面向对象，聊设计模式。\n\n你需要能随时切换角色，切换你的表达方式和谈话内容。所以，你得是一只高情商的程序员。\n\n### 职业延伸性好 ###\n\n一方面现在用javascript已经可以开发windows应用、ios应用、android应用，可以编写智能电视上的应用。另一方面，由于nodejs的横空出世，javascript这门语言竟然神奇的有了服务端的能力。但个人认为前端转后端的可能性几乎为零，所谓的全栈工程师完全是扯(我有偏见，并且绝对不客观，也绝对不会为本说辞负责，所以你可以直接把我无视掉。如果你觉得我说的哪点不对，你过来揍我啊)，后端要积累到足够多的项目经验，才能够成为一个靠谱的后端工程师，后端是大后期，后端要懂的东西，太多了，后端并不是语法，而是牵涉到算法，架构，性能，业务，选型等等跟前端几乎没有任何关系的知识。\n\n## 总结 ##\n\n**本文于2016.5.19凌晨2点51分定稿**\n\n- 前端的门槛低，但要成为一名专业的前端工程师，需要掌握的东西太多了。除了前端技术外，个人认为**前端更重要的是综合能力**，包括我上面谈到的有品味、有思想、有较高的沟通能力和理解能力等等。毕竟你要通过代码与用户产生接触，给用户带来愉悦感。\n- 由于之前写过一个小的OS，对黑漆漆的控制台情有独钟，总是感觉前端没有什么技术含量，不就是写写网页嘛，第一次听说前端这个概念还是毕业时，宿舍一哥们在找前端相关的工作才了解到的，当时我们都是在使劲的刷算法和数据结构，问他前端不需要面试这些，他说不需要，从那时起我就深深的鄙视起了前端，现在看来是大错特错了，当然此次转型，可能要放弃自己以前在Linux上的积累了，我的大后端就这样和我分道扬镳了，哎，算了，**当断则断，不破不立，**成大事者不纠结（吐，此处你可以忽略不计）。\n- 从4.8开始准备跳槽到现在，我又犹豫了一个月左右，此刻终于找到找到了自己喜欢干的职业（应该叫事业），我觉得这不是浪费时间\n- 最后送给自己一句话：**当你已经下定决心，准备前行的时候，剩下的就只有坚持了。**\n\t热爱生命 \n\t汪国真 \n\t我不去想是否能够成功 \n\t既然选择了远方 \n\t便只顾风雨兼程 \n\t我不去想能否赢得爱情 \n\t既然钟情于玫瑰 \n\t就勇敢地吐露真诚 \n\t我不去想身后会不会袭来寒风冷雨 \n\t既然目标是地平线 \n\t留给世界的只能是背影 \n\t我不去想未来是平坦还是泥泞 \n\t只要热爱生命 \n\t一切\n\t都在意料之中\n\n","source":"_posts/我为什么选择做前端.md","raw":"---\ntitle: 我为什么选择做前端\ntoc: true\ndate: 2016-05-19 09:37:05\ncategories: 不务正业\ntags: [职业发展, 前端开发]\ndescription: [一枚立志成为大后端程序猿的前端转型之旅]\n---\n一枚立志成为大后端程序猿的前端转型之旅\n<!--more-->\n## 前端工程师是怎样一种职业 ##\n\n个人感觉前端工程师（front-end engineer，简称FE，下文将用FE来代称）是黑客与画家的完美融合，其最具有成为增长黑客的潜质，FE这个职业简直完全是为我而生。\n\nFE的特点（以下内容是参考一个前端大牛的一篇文章，感觉直击心底，在此先行谢过）\n\n- FE是最接近用户的程序猿\n- FE需要具有优秀的软件开发能力\n- FE需要有较高的沟通能力和理解能力\n- 职业延伸性好\n\n下面将分别介绍\n\n### FE是最接近用户的程序猿 ###\n\n![作为前端工程师最核心的价值或者说是责任，就是将大伙的所有心血和努力最终要完美地呈现给用户。](http://7xtj85.com1.z0.glb.clouddn.com/image/jpg/Front_end.png)\n\n作为FE最核心的价值或者说是责任，就是将大伙的所有心血和努力最终要完美地呈现给用户。\n\n- FE是用户体验的把控者，在产品经理构想出原型，UI设计出交互细节后，FE就要用双手一行一行敲出那些代码。其次FE需要对用户体验有较深的理解，举个例子：比如页面上有一个超链接，字体比较小的情况下，用户可能会一下点不中，因为链接的可点击区域是紧贴着文字边缘的。前端可以通过很简单的方法来扩大这个链接的可点击区域，使得用户更容易点中，这就是用户体验。\n- 懂得用户体验的FE，需要有一点强迫症，不能容忍px级别的瑕疵，需要对美有所领悟，需要执着地追求美，需要有品味，有思想，有大局观，最好还能懂点心理学，会让他的作品与用户沟通，能够touch到用户心中那一块柔软的区域，所以**FE是最接近User的工程师，与User可以说是零距离接触**。\n\n### FE需要具有优秀的软件开发能力 ###\n\n- FE需要完成用户端的业务逻辑，JS是FE需要掌握的编程语言，这要求FE要有软件开发的基础，要具有良好的编码规范；要了解计算机的基础原理，要掌握HTPP；要有架构能力，整合使用现有的优秀框架；了解MVC、MVVM等设计模式。\n- 众所周知，IT行业的知识更新换代很快，这要求程序猿具有快速学习能力。这对前端更是如此，前端现在处于一个百花齐放百家争鸣的阶段，新技术日新月异，这要求一个合格的FE能够保持持续的学习能力，能够对新技术有敏锐的嗅觉，活到老，学到老，说的就是前端工程师。\n\n### FE需要有较高的沟通能力和理解能力 ###\n\n大多数人对程序猿的印象就是情商低、不善言谈。但前端工程师应该是个例外，这是由工作性质决定的。\n\n- 从工作流程来看，FE处于设计师的下游，他要接设计稿，转化为网页。同时又是后端工程师的上游，需要把用户产生的数据提交到服务端。横向来看，他又与产品经理有着密切接触，因为他可能随时和产品经理探讨交互的细节。**这样一个连接着团队中的其他成员的角色，需要他既是一个粘合剂，又是一个润滑剂。**\n\n- **前端工程师需要有较高的沟通能力和理解能力**。我们经常开玩笑说“<strong>设计师活在童话故事里</strong>”，因为有时候他们设计的页面根本不符合常规，无法实现。这个时候你就需要耐心的给设计MM讲原理、讲原因，并且告诉她设计需要遵循哪些基本规范。对于<strong>产品经理</strong>的思想，你要能把握到位，**你得理解他比划了半天到底是想要做什么**。与<strong>后端工程师</strong>打交道的时候，你又得马上化身编程达人，跟他们聊数据类型，聊面向对象，聊设计模式。\n\n你需要能随时切换角色，切换你的表达方式和谈话内容。所以，你得是一只高情商的程序员。\n\n### 职业延伸性好 ###\n\n一方面现在用javascript已经可以开发windows应用、ios应用、android应用，可以编写智能电视上的应用。另一方面，由于nodejs的横空出世，javascript这门语言竟然神奇的有了服务端的能力。但个人认为前端转后端的可能性几乎为零，所谓的全栈工程师完全是扯(我有偏见，并且绝对不客观，也绝对不会为本说辞负责，所以你可以直接把我无视掉。如果你觉得我说的哪点不对，你过来揍我啊)，后端要积累到足够多的项目经验，才能够成为一个靠谱的后端工程师，后端是大后期，后端要懂的东西，太多了，后端并不是语法，而是牵涉到算法，架构，性能，业务，选型等等跟前端几乎没有任何关系的知识。\n\n## 总结 ##\n\n**本文于2016.5.19凌晨2点51分定稿**\n\n- 前端的门槛低，但要成为一名专业的前端工程师，需要掌握的东西太多了。除了前端技术外，个人认为**前端更重要的是综合能力**，包括我上面谈到的有品味、有思想、有较高的沟通能力和理解能力等等。毕竟你要通过代码与用户产生接触，给用户带来愉悦感。\n- 由于之前写过一个小的OS，对黑漆漆的控制台情有独钟，总是感觉前端没有什么技术含量，不就是写写网页嘛，第一次听说前端这个概念还是毕业时，宿舍一哥们在找前端相关的工作才了解到的，当时我们都是在使劲的刷算法和数据结构，问他前端不需要面试这些，他说不需要，从那时起我就深深的鄙视起了前端，现在看来是大错特错了，当然此次转型，可能要放弃自己以前在Linux上的积累了，我的大后端就这样和我分道扬镳了，哎，算了，**当断则断，不破不立，**成大事者不纠结（吐，此处你可以忽略不计）。\n- 从4.8开始准备跳槽到现在，我又犹豫了一个月左右，此刻终于找到找到了自己喜欢干的职业（应该叫事业），我觉得这不是浪费时间\n- 最后送给自己一句话：**当你已经下定决心，准备前行的时候，剩下的就只有坚持了。**\n\t热爱生命 \n\t汪国真 \n\t我不去想是否能够成功 \n\t既然选择了远方 \n\t便只顾风雨兼程 \n\t我不去想能否赢得爱情 \n\t既然钟情于玫瑰 \n\t就勇敢地吐露真诚 \n\t我不去想身后会不会袭来寒风冷雨 \n\t既然目标是地平线 \n\t留给世界的只能是背影 \n\t我不去想未来是平坦还是泥泞 \n\t只要热爱生命 \n\t一切\n\t都在意料之中\n\n","slug":"我为什么选择做前端","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrpr0012526rwhszr082","content":"<p>一枚立志成为大后端程序猿的前端转型之旅<br><a id=\"more\"></a></p>\n<h2 id=\"前端工程师是怎样一种职业\"><a href=\"#前端工程师是怎样一种职业\" class=\"headerlink\" title=\"前端工程师是怎样一种职业\"></a>前端工程师是怎样一种职业</h2><p>个人感觉前端工程师（front-end engineer，简称FE，下文将用FE来代称）是黑客与画家的完美融合，其最具有成为增长黑客的潜质，FE这个职业简直完全是为我而生。</p>\n<p>FE的特点（以下内容是参考一个前端大牛的一篇文章，感觉直击心底，在此先行谢过）</p>\n<ul>\n<li>FE是最接近用户的程序猿</li>\n<li>FE需要具有优秀的软件开发能力</li>\n<li>FE需要有较高的沟通能力和理解能力</li>\n<li>职业延伸性好</li>\n</ul>\n<p>下面将分别介绍</p>\n<h3 id=\"FE是最接近用户的程序猿\"><a href=\"#FE是最接近用户的程序猿\" class=\"headerlink\" title=\"FE是最接近用户的程序猿\"></a>FE是最接近用户的程序猿</h3><p><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/image/jpg/Front_end.png\" alt=\"作为前端工程师最核心的价值或者说是责任，就是将大伙的所有心血和努力最终要完美地呈现给用户。\"></p>\n<p>作为FE最核心的价值或者说是责任，就是将大伙的所有心血和努力最终要完美地呈现给用户。</p>\n<ul>\n<li>FE是用户体验的把控者，在产品经理构想出原型，UI设计出交互细节后，FE就要用双手一行一行敲出那些代码。其次FE需要对用户体验有较深的理解，举个例子：比如页面上有一个超链接，字体比较小的情况下，用户可能会一下点不中，因为链接的可点击区域是紧贴着文字边缘的。前端可以通过很简单的方法来扩大这个链接的可点击区域，使得用户更容易点中，这就是用户体验。</li>\n<li>懂得用户体验的FE，需要有一点强迫症，不能容忍px级别的瑕疵，需要对美有所领悟，需要执着地追求美，需要有品味，有思想，有大局观，最好还能懂点心理学，会让他的作品与用户沟通，能够touch到用户心中那一块柔软的区域，所以<strong>FE是最接近User的工程师，与User可以说是零距离接触</strong>。</li>\n</ul>\n<h3 id=\"FE需要具有优秀的软件开发能力\"><a href=\"#FE需要具有优秀的软件开发能力\" class=\"headerlink\" title=\"FE需要具有优秀的软件开发能力\"></a>FE需要具有优秀的软件开发能力</h3><ul>\n<li>FE需要完成用户端的业务逻辑，JS是FE需要掌握的编程语言，这要求FE要有软件开发的基础，要具有良好的编码规范；要了解计算机的基础原理，要掌握HTPP；要有架构能力，整合使用现有的优秀框架；了解MVC、MVVM等设计模式。</li>\n<li>众所周知，IT行业的知识更新换代很快，这要求程序猿具有快速学习能力。这对前端更是如此，前端现在处于一个百花齐放百家争鸣的阶段，新技术日新月异，这要求一个合格的FE能够保持持续的学习能力，能够对新技术有敏锐的嗅觉，活到老，学到老，说的就是前端工程师。</li>\n</ul>\n<h3 id=\"FE需要有较高的沟通能力和理解能力\"><a href=\"#FE需要有较高的沟通能力和理解能力\" class=\"headerlink\" title=\"FE需要有较高的沟通能力和理解能力\"></a>FE需要有较高的沟通能力和理解能力</h3><p>大多数人对程序猿的印象就是情商低、不善言谈。但前端工程师应该是个例外，这是由工作性质决定的。</p>\n<ul>\n<li><p>从工作流程来看，FE处于设计师的下游，他要接设计稿，转化为网页。同时又是后端工程师的上游，需要把用户产生的数据提交到服务端。横向来看，他又与产品经理有着密切接触，因为他可能随时和产品经理探讨交互的细节。<strong>这样一个连接着团队中的其他成员的角色，需要他既是一个粘合剂，又是一个润滑剂。</strong></p>\n</li>\n<li><p><strong>前端工程师需要有较高的沟通能力和理解能力</strong>。我们经常开玩笑说“<strong>设计师活在童话故事里</strong>”，因为有时候他们设计的页面根本不符合常规，无法实现。这个时候你就需要耐心的给设计MM讲原理、讲原因，并且告诉她设计需要遵循哪些基本规范。对于<strong>产品经理</strong>的思想，你要能把握到位，<strong>你得理解他比划了半天到底是想要做什么</strong>。与<strong>后端工程师</strong>打交道的时候，你又得马上化身编程达人，跟他们聊数据类型，聊面向对象，聊设计模式。</p>\n</li>\n</ul>\n<p>你需要能随时切换角色，切换你的表达方式和谈话内容。所以，你得是一只高情商的程序员。</p>\n<h3 id=\"职业延伸性好\"><a href=\"#职业延伸性好\" class=\"headerlink\" title=\"职业延伸性好\"></a>职业延伸性好</h3><p>一方面现在用javascript已经可以开发windows应用、ios应用、android应用，可以编写智能电视上的应用。另一方面，由于nodejs的横空出世，javascript这门语言竟然神奇的有了服务端的能力。但个人认为前端转后端的可能性几乎为零，所谓的全栈工程师完全是扯(我有偏见，并且绝对不客观，也绝对不会为本说辞负责，所以你可以直接把我无视掉。如果你觉得我说的哪点不对，你过来揍我啊)，后端要积累到足够多的项目经验，才能够成为一个靠谱的后端工程师，后端是大后期，后端要懂的东西，太多了，后端并不是语法，而是牵涉到算法，架构，性能，业务，选型等等跟前端几乎没有任何关系的知识。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>本文于2016.5.19凌晨2点51分定稿</strong></p>\n<ul>\n<li>前端的门槛低，但要成为一名专业的前端工程师，需要掌握的东西太多了。除了前端技术外，个人认为<strong>前端更重要的是综合能力</strong>，包括我上面谈到的有品味、有思想、有较高的沟通能力和理解能力等等。毕竟你要通过代码与用户产生接触，给用户带来愉悦感。</li>\n<li>由于之前写过一个小的OS，对黑漆漆的控制台情有独钟，总是感觉前端没有什么技术含量，不就是写写网页嘛，第一次听说前端这个概念还是毕业时，宿舍一哥们在找前端相关的工作才了解到的，当时我们都是在使劲的刷算法和数据结构，问他前端不需要面试这些，他说不需要，从那时起我就深深的鄙视起了前端，现在看来是大错特错了，当然此次转型，可能要放弃自己以前在Linux上的积累了，我的大后端就这样和我分道扬镳了，哎，算了，<strong>当断则断，不破不立，</strong>成大事者不纠结（吐，此处你可以忽略不计）。</li>\n<li>从4.8开始准备跳槽到现在，我又犹豫了一个月左右，此刻终于找到找到了自己喜欢干的职业（应该叫事业），我觉得这不是浪费时间</li>\n<li>最后送给自己一句话：<strong>当你已经下定决心，准备前行的时候，剩下的就只有坚持了。</strong><br>  热爱生命<br>  汪国真<br>  我不去想是否能够成功<br>  既然选择了远方<br>  便只顾风雨兼程<br>  我不去想能否赢得爱情<br>  既然钟情于玫瑰<br>  就勇敢地吐露真诚<br>  我不去想身后会不会袭来寒风冷雨<br>  既然目标是地平线<br>  留给世界的只能是背影<br>  我不去想未来是平坦还是泥泞<br>  只要热爱生命<br>  一切<br>  都在意料之中</li>\n</ul>\n","excerpt":"<p>一枚立志成为大后端程序猿的前端转型之旅<br>","more":"</p>\n<h2 id=\"前端工程师是怎样一种职业\"><a href=\"#前端工程师是怎样一种职业\" class=\"headerlink\" title=\"前端工程师是怎样一种职业\"></a>前端工程师是怎样一种职业</h2><p>个人感觉前端工程师（front-end engineer，简称FE，下文将用FE来代称）是黑客与画家的完美融合，其最具有成为增长黑客的潜质，FE这个职业简直完全是为我而生。</p>\n<p>FE的特点（以下内容是参考一个前端大牛的一篇文章，感觉直击心底，在此先行谢过）</p>\n<ul>\n<li>FE是最接近用户的程序猿</li>\n<li>FE需要具有优秀的软件开发能力</li>\n<li>FE需要有较高的沟通能力和理解能力</li>\n<li>职业延伸性好</li>\n</ul>\n<p>下面将分别介绍</p>\n<h3 id=\"FE是最接近用户的程序猿\"><a href=\"#FE是最接近用户的程序猿\" class=\"headerlink\" title=\"FE是最接近用户的程序猿\"></a>FE是最接近用户的程序猿</h3><p><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/image/jpg/Front_end.png\" alt=\"作为前端工程师最核心的价值或者说是责任，就是将大伙的所有心血和努力最终要完美地呈现给用户。\"></p>\n<p>作为FE最核心的价值或者说是责任，就是将大伙的所有心血和努力最终要完美地呈现给用户。</p>\n<ul>\n<li>FE是用户体验的把控者，在产品经理构想出原型，UI设计出交互细节后，FE就要用双手一行一行敲出那些代码。其次FE需要对用户体验有较深的理解，举个例子：比如页面上有一个超链接，字体比较小的情况下，用户可能会一下点不中，因为链接的可点击区域是紧贴着文字边缘的。前端可以通过很简单的方法来扩大这个链接的可点击区域，使得用户更容易点中，这就是用户体验。</li>\n<li>懂得用户体验的FE，需要有一点强迫症，不能容忍px级别的瑕疵，需要对美有所领悟，需要执着地追求美，需要有品味，有思想，有大局观，最好还能懂点心理学，会让他的作品与用户沟通，能够touch到用户心中那一块柔软的区域，所以<strong>FE是最接近User的工程师，与User可以说是零距离接触</strong>。</li>\n</ul>\n<h3 id=\"FE需要具有优秀的软件开发能力\"><a href=\"#FE需要具有优秀的软件开发能力\" class=\"headerlink\" title=\"FE需要具有优秀的软件开发能力\"></a>FE需要具有优秀的软件开发能力</h3><ul>\n<li>FE需要完成用户端的业务逻辑，JS是FE需要掌握的编程语言，这要求FE要有软件开发的基础，要具有良好的编码规范；要了解计算机的基础原理，要掌握HTPP；要有架构能力，整合使用现有的优秀框架；了解MVC、MVVM等设计模式。</li>\n<li>众所周知，IT行业的知识更新换代很快，这要求程序猿具有快速学习能力。这对前端更是如此，前端现在处于一个百花齐放百家争鸣的阶段，新技术日新月异，这要求一个合格的FE能够保持持续的学习能力，能够对新技术有敏锐的嗅觉，活到老，学到老，说的就是前端工程师。</li>\n</ul>\n<h3 id=\"FE需要有较高的沟通能力和理解能力\"><a href=\"#FE需要有较高的沟通能力和理解能力\" class=\"headerlink\" title=\"FE需要有较高的沟通能力和理解能力\"></a>FE需要有较高的沟通能力和理解能力</h3><p>大多数人对程序猿的印象就是情商低、不善言谈。但前端工程师应该是个例外，这是由工作性质决定的。</p>\n<ul>\n<li><p>从工作流程来看，FE处于设计师的下游，他要接设计稿，转化为网页。同时又是后端工程师的上游，需要把用户产生的数据提交到服务端。横向来看，他又与产品经理有着密切接触，因为他可能随时和产品经理探讨交互的细节。<strong>这样一个连接着团队中的其他成员的角色，需要他既是一个粘合剂，又是一个润滑剂。</strong></p>\n</li>\n<li><p><strong>前端工程师需要有较高的沟通能力和理解能力</strong>。我们经常开玩笑说“<strong>设计师活在童话故事里</strong>”，因为有时候他们设计的页面根本不符合常规，无法实现。这个时候你就需要耐心的给设计MM讲原理、讲原因，并且告诉她设计需要遵循哪些基本规范。对于<strong>产品经理</strong>的思想，你要能把握到位，<strong>你得理解他比划了半天到底是想要做什么</strong>。与<strong>后端工程师</strong>打交道的时候，你又得马上化身编程达人，跟他们聊数据类型，聊面向对象，聊设计模式。</p>\n</li>\n</ul>\n<p>你需要能随时切换角色，切换你的表达方式和谈话内容。所以，你得是一只高情商的程序员。</p>\n<h3 id=\"职业延伸性好\"><a href=\"#职业延伸性好\" class=\"headerlink\" title=\"职业延伸性好\"></a>职业延伸性好</h3><p>一方面现在用javascript已经可以开发windows应用、ios应用、android应用，可以编写智能电视上的应用。另一方面，由于nodejs的横空出世，javascript这门语言竟然神奇的有了服务端的能力。但个人认为前端转后端的可能性几乎为零，所谓的全栈工程师完全是扯(我有偏见，并且绝对不客观，也绝对不会为本说辞负责，所以你可以直接把我无视掉。如果你觉得我说的哪点不对，你过来揍我啊)，后端要积累到足够多的项目经验，才能够成为一个靠谱的后端工程师，后端是大后期，后端要懂的东西，太多了，后端并不是语法，而是牵涉到算法，架构，性能，业务，选型等等跟前端几乎没有任何关系的知识。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>本文于2016.5.19凌晨2点51分定稿</strong></p>\n<ul>\n<li>前端的门槛低，但要成为一名专业的前端工程师，需要掌握的东西太多了。除了前端技术外，个人认为<strong>前端更重要的是综合能力</strong>，包括我上面谈到的有品味、有思想、有较高的沟通能力和理解能力等等。毕竟你要通过代码与用户产生接触，给用户带来愉悦感。</li>\n<li>由于之前写过一个小的OS，对黑漆漆的控制台情有独钟，总是感觉前端没有什么技术含量，不就是写写网页嘛，第一次听说前端这个概念还是毕业时，宿舍一哥们在找前端相关的工作才了解到的，当时我们都是在使劲的刷算法和数据结构，问他前端不需要面试这些，他说不需要，从那时起我就深深的鄙视起了前端，现在看来是大错特错了，当然此次转型，可能要放弃自己以前在Linux上的积累了，我的大后端就这样和我分道扬镳了，哎，算了，<strong>当断则断，不破不立，</strong>成大事者不纠结（吐，此处你可以忽略不计）。</li>\n<li>从4.8开始准备跳槽到现在，我又犹豫了一个月左右，此刻终于找到找到了自己喜欢干的职业（应该叫事业），我觉得这不是浪费时间</li>\n<li>最后送给自己一句话：<strong>当你已经下定决心，准备前行的时候，剩下的就只有坚持了。</strong><br>  热爱生命<br>  汪国真<br>  我不去想是否能够成功<br>  既然选择了远方<br>  便只顾风雨兼程<br>  我不去想能否赢得爱情<br>  既然钟情于玫瑰<br>  就勇敢地吐露真诚<br>  我不去想身后会不会袭来寒风冷雨<br>  既然目标是地平线<br>  留给世界的只能是背影<br>  我不去想未来是平坦还是泥泞<br>  只要热爱生命<br>  一切<br>  都在意料之中</li>\n</ul>"},{"title":"理解JS中的原型","description":"动态语言和静态语言有很大的不同，比如在C++中定义类时，并不分配内存，而在动态语言中定义类时，却会分配内存。","toc":true,"date":"2016-05-26T06:55:10.000Z","_content":"<!--more-->\n动态语言和静态语言有很大的不同，比如在C++中定义类时，并不分配内存，而在动态语言中定义类时，却会分配内存。\n- 比如在JS中**定义**了一个函数时，将会为该函数创建一个**prototype**属性，这个属性指向该函数的原型对象；JS中万物皆对象，一个对象要么是函数的实例，要么是原型的实例。\n- 比如在Python中定义了一个类时，将会创建一个**类型对象**（类其实是能够创建出类实例的对象，类本身也是实例，而且是metaclass元类的实例）；Python中所有的东西都是对象，其要么是类的实例，要么是**metaclass元类**的实例。\n\n原型对象中的属性被**所有实例所共享**，这类似于C++中的静态成员，静态成员属于类本身，而不是属于对象，但是被类的所有实例所共有。\n\n## 创建一个空函数\n```JavaScript\nfunction Person() {};\n```\n像这样创建一个空函数，js解析为以下三步：\n1. 创建一个Object对象（有constructor属性及[[Prototype]]属性）;\n2. 创建一个函数（有name、prototype属性），再通过prototype属性引用刚才创建的对象;\n3. 创建变量Person，同时把函数的引用赋值给变量Person\n![如图可以表示为](http://7xtj85.com1.z0.glb.clouddn.com/prototype.png)\n\n## 实例化一个对象\n我们用上面这个Person函数去实例化一个对象时，js解析又是怎样呢？比如：\n```JavaScript\nvar angela = new Person();\n```\n实例化出来的对象，js解析也分为下面三步：\n1. 新建一个对象并赋值给变量angela：var angela = {};\n2. 把这个对象的[[Prototype]]属性指向函数Person的原型对象：angela.[[Prototype]] = Person.prototype\n3. 调用函数Person，同时把this指向刚创建的对象angela，对这个对象进行初始化：Person.apply(angela,arguments)\n![如图可表示为](http://7xtj85.com1.z0.glb.clouddn.com/prototype1.png)\n**总结：**构造函数、原型和实例之间的关系，每个构造函数包含一个指向原型对象的指针prototype，原型对象都包含一个指向构造函数的指针constructor，而实例都包含一个指向原型对象的内部指针\\__proto__（有的地方称为[[prototype]]）。\n\n## 重写prototype对象\n在上面两个例子的基础上，再进行如下操作\n```JavaScript\nPerson.prototype = {\n    name: \"bruce\",\n    age: 23\n};\n```\n- 上面使用的语法将会**完全重写默认的prototype对象**，其会直接导致Person的prototype对象里面没有了constructor属性，constructor属性只能从Person.prototype.__proto__.constructor继承过来(Person.prototype的原型对象为Object原型对象)，即constructor将指向**Object构造函数**\n- 把原型对象修改为另外一个对象就等于，切断了构造函数Person和**最初的原型对象**之间的联系。\n但是实例angela和最初的原型对象之间的联系不变。\n**注：**实例中的\\__proto__指针仅指向原型，而不指向构造函数。\n\n## 搜索一个属性\n- 每当代码读取某个对象的属性时，首先会在对象实例本身中**搜索**，如果在实例中找到了该属性，则返回该属性。如果没有找到，则继续在**\\__proto__**指向的原型对象中**搜索**，如果找到了该属性，则返回该属性。如此继续下去。\n也就是说当为对象实例添加了一个属性时，这个属性就会**屏蔽**原型对象中保存的**同名属性**。\n- `hasOwnProperty`方法可以检测一个属性是存在于实例中，还是存在于原型中，只有给定属性存在于实例中，才会返回true。\n\n## prototye属性\n- JS中万物皆对象,通常来说，javascript中的对象就是一个指向原型对象的指针和一个自身的属性列表。\nprototype属性本质上它就是一个普通的指针,其之所以特别，是因为javascript时**读取属性时的遍历机制决定的**。\n只有**构造函数才具有prototype属性**，且只有以下对象才是构造函数：\n5种基本引用类型（Object、Array、Date、RegExp、Function）、3种包装类型（Boolean、Number、String）、Function的实例\njavascript创建对象时采用了写时复制的理念，当调用构造函数创建一个实例后，该实例内部将包含一个指针（内部属性,下图中暂时称为inobj），指向构造函数的原型对象。\n![调用构造函数创建一个实例](http://7xtj85.com1.z0.glb.clouddn.com/1593745-54254e96f4a43db7.jpg)\n- 而普通对象是没有prototype属性的，在chrome上对象有一个\\__proto__属性指向对象的原型，但是\n在其他浏览器上这个属性对外完全不可见，要取得普通对象的原型对象，可以调用Object.getPrototypeOf(instance),便可取得实例instance的原型。\n\n**总结：**JS中的每个对象都包含一个指向其原型对象的指针，这个指针在构造函数是**prototype属性**，可以直接访问；在普通对象中是\\__proto__属性，不可以直接访问。\n\n## 原型链\n- 让一个函数的原型对象等于另外一个类型的实例，而这个实例的原型对象又等于另外一个类型的实例，如此层层递进，就构成了`实例与原型之间`的**一条链条**，这就是所谓原型链的概念。\n若A继承自B，B又继承自C，则这条原型链为：`A的实例->A的原型对象->B的原型对象->C的原型对象->Object的原型对象->null`\n- 所有引用类型的prototype指针默认都指向Object的原型对象，所有函数的默认原型对象的\\__proto\\__指针都指向Object的原型对象。\n- 原型链是JS实现继承的主要方法。\n- 如果实例A的\\__proto__指针指向类型B的**原型对象**，可以直接指向，也可以间接指向（即A->C->B），则**称A是B的实例**。\n- instanceof操作符\n```\nA instanceof B\n//如果类型B的原型对象出现在实例A的原型链中，则返回true\n```\n- 作用域链和原型链\n作用域链用来查找对象\n原型链用来查找对象的属性\n\n## 参考资料\n1. [公司一位大牛关于prototype的总结](http://www.jianshu.com/p/c8f29b62fec8)\n2. [理解js中的原型继承](http://fungwan.me/2015/01/05/js%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/)\n","source":"_posts/理解JS中的原型.md","raw":"---\ntitle: 理解JS中的原型\ncategories: JavaScript\ntags: [JavaScript, Prototype, 前端开发]\ndescription: 动态语言和静态语言有很大的不同，比如在C++中定义类时，并不分配内存，而在动态语言中定义类时，却会分配内存。\ntoc: true\ndate: 2016-05-26 14:55:10\n---\n<!--more-->\n动态语言和静态语言有很大的不同，比如在C++中定义类时，并不分配内存，而在动态语言中定义类时，却会分配内存。\n- 比如在JS中**定义**了一个函数时，将会为该函数创建一个**prototype**属性，这个属性指向该函数的原型对象；JS中万物皆对象，一个对象要么是函数的实例，要么是原型的实例。\n- 比如在Python中定义了一个类时，将会创建一个**类型对象**（类其实是能够创建出类实例的对象，类本身也是实例，而且是metaclass元类的实例）；Python中所有的东西都是对象，其要么是类的实例，要么是**metaclass元类**的实例。\n\n原型对象中的属性被**所有实例所共享**，这类似于C++中的静态成员，静态成员属于类本身，而不是属于对象，但是被类的所有实例所共有。\n\n## 创建一个空函数\n```JavaScript\nfunction Person() {};\n```\n像这样创建一个空函数，js解析为以下三步：\n1. 创建一个Object对象（有constructor属性及[[Prototype]]属性）;\n2. 创建一个函数（有name、prototype属性），再通过prototype属性引用刚才创建的对象;\n3. 创建变量Person，同时把函数的引用赋值给变量Person\n![如图可以表示为](http://7xtj85.com1.z0.glb.clouddn.com/prototype.png)\n\n## 实例化一个对象\n我们用上面这个Person函数去实例化一个对象时，js解析又是怎样呢？比如：\n```JavaScript\nvar angela = new Person();\n```\n实例化出来的对象，js解析也分为下面三步：\n1. 新建一个对象并赋值给变量angela：var angela = {};\n2. 把这个对象的[[Prototype]]属性指向函数Person的原型对象：angela.[[Prototype]] = Person.prototype\n3. 调用函数Person，同时把this指向刚创建的对象angela，对这个对象进行初始化：Person.apply(angela,arguments)\n![如图可表示为](http://7xtj85.com1.z0.glb.clouddn.com/prototype1.png)\n**总结：**构造函数、原型和实例之间的关系，每个构造函数包含一个指向原型对象的指针prototype，原型对象都包含一个指向构造函数的指针constructor，而实例都包含一个指向原型对象的内部指针\\__proto__（有的地方称为[[prototype]]）。\n\n## 重写prototype对象\n在上面两个例子的基础上，再进行如下操作\n```JavaScript\nPerson.prototype = {\n    name: \"bruce\",\n    age: 23\n};\n```\n- 上面使用的语法将会**完全重写默认的prototype对象**，其会直接导致Person的prototype对象里面没有了constructor属性，constructor属性只能从Person.prototype.__proto__.constructor继承过来(Person.prototype的原型对象为Object原型对象)，即constructor将指向**Object构造函数**\n- 把原型对象修改为另外一个对象就等于，切断了构造函数Person和**最初的原型对象**之间的联系。\n但是实例angela和最初的原型对象之间的联系不变。\n**注：**实例中的\\__proto__指针仅指向原型，而不指向构造函数。\n\n## 搜索一个属性\n- 每当代码读取某个对象的属性时，首先会在对象实例本身中**搜索**，如果在实例中找到了该属性，则返回该属性。如果没有找到，则继续在**\\__proto__**指向的原型对象中**搜索**，如果找到了该属性，则返回该属性。如此继续下去。\n也就是说当为对象实例添加了一个属性时，这个属性就会**屏蔽**原型对象中保存的**同名属性**。\n- `hasOwnProperty`方法可以检测一个属性是存在于实例中，还是存在于原型中，只有给定属性存在于实例中，才会返回true。\n\n## prototye属性\n- JS中万物皆对象,通常来说，javascript中的对象就是一个指向原型对象的指针和一个自身的属性列表。\nprototype属性本质上它就是一个普通的指针,其之所以特别，是因为javascript时**读取属性时的遍历机制决定的**。\n只有**构造函数才具有prototype属性**，且只有以下对象才是构造函数：\n5种基本引用类型（Object、Array、Date、RegExp、Function）、3种包装类型（Boolean、Number、String）、Function的实例\njavascript创建对象时采用了写时复制的理念，当调用构造函数创建一个实例后，该实例内部将包含一个指针（内部属性,下图中暂时称为inobj），指向构造函数的原型对象。\n![调用构造函数创建一个实例](http://7xtj85.com1.z0.glb.clouddn.com/1593745-54254e96f4a43db7.jpg)\n- 而普通对象是没有prototype属性的，在chrome上对象有一个\\__proto__属性指向对象的原型，但是\n在其他浏览器上这个属性对外完全不可见，要取得普通对象的原型对象，可以调用Object.getPrototypeOf(instance),便可取得实例instance的原型。\n\n**总结：**JS中的每个对象都包含一个指向其原型对象的指针，这个指针在构造函数是**prototype属性**，可以直接访问；在普通对象中是\\__proto__属性，不可以直接访问。\n\n## 原型链\n- 让一个函数的原型对象等于另外一个类型的实例，而这个实例的原型对象又等于另外一个类型的实例，如此层层递进，就构成了`实例与原型之间`的**一条链条**，这就是所谓原型链的概念。\n若A继承自B，B又继承自C，则这条原型链为：`A的实例->A的原型对象->B的原型对象->C的原型对象->Object的原型对象->null`\n- 所有引用类型的prototype指针默认都指向Object的原型对象，所有函数的默认原型对象的\\__proto\\__指针都指向Object的原型对象。\n- 原型链是JS实现继承的主要方法。\n- 如果实例A的\\__proto__指针指向类型B的**原型对象**，可以直接指向，也可以间接指向（即A->C->B），则**称A是B的实例**。\n- instanceof操作符\n```\nA instanceof B\n//如果类型B的原型对象出现在实例A的原型链中，则返回true\n```\n- 作用域链和原型链\n作用域链用来查找对象\n原型链用来查找对象的属性\n\n## 参考资料\n1. [公司一位大牛关于prototype的总结](http://www.jianshu.com/p/c8f29b62fec8)\n2. [理解js中的原型继承](http://fungwan.me/2015/01/05/js%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/)\n","slug":"理解JS中的原型","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrpt0015526r9nea4rc8","content":"<a id=\"more\"></a>\n<p>动态语言和静态语言有很大的不同，比如在C++中定义类时，并不分配内存，而在动态语言中定义类时，却会分配内存。</p>\n<ul>\n<li>比如在JS中<strong>定义</strong>了一个函数时，将会为该函数创建一个<strong>prototype</strong>属性，这个属性指向该函数的原型对象；JS中万物皆对象，一个对象要么是函数的实例，要么是原型的实例。</li>\n<li>比如在Python中定义了一个类时，将会创建一个<strong>类型对象</strong>（类其实是能够创建出类实例的对象，类本身也是实例，而且是metaclass元类的实例）；Python中所有的东西都是对象，其要么是类的实例，要么是<strong>metaclass元类</strong>的实例。</li>\n</ul>\n<p>原型对象中的属性被<strong>所有实例所共享</strong>，这类似于C++中的静态成员，静态成员属于类本身，而不是属于对象，但是被类的所有实例所共有。</p>\n<h2 id=\"创建一个空函数\"><a href=\"#创建一个空函数\" class=\"headerlink\" title=\"创建一个空函数\"></a>创建一个空函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div></pre></td></tr></table></figure>\n<p>像这样创建一个空函数，js解析为以下三步：</p>\n<ol>\n<li>创建一个Object对象（有constructor属性及[[Prototype]]属性）;</li>\n<li>创建一个函数（有name、prototype属性），再通过prototype属性引用刚才创建的对象;</li>\n<li>创建变量Person，同时把函数的引用赋值给变量Person<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/prototype.png\" alt=\"如图可以表示为\"></li>\n</ol>\n<h2 id=\"实例化一个对象\"><a href=\"#实例化一个对象\" class=\"headerlink\" title=\"实例化一个对象\"></a>实例化一个对象</h2><p>我们用上面这个Person函数去实例化一个对象时，js解析又是怎样呢？比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> angela = <span class=\"keyword\">new</span> Person();</div></pre></td></tr></table></figure></p>\n<p>实例化出来的对象，js解析也分为下面三步：</p>\n<ol>\n<li>新建一个对象并赋值给变量angela：var angela = {};</li>\n<li>把这个对象的[[Prototype]]属性指向函数Person的原型对象：angela.[[Prototype]] = Person.prototype</li>\n<li>调用函数Person，同时把this指向刚创建的对象angela，对这个对象进行初始化：Person.apply(angela,arguments)<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/prototype1.png\" alt=\"如图可表示为\"><br><strong>总结：</strong>构造函数、原型和实例之间的关系，每个构造函数包含一个指向原型对象的指针prototype，原型对象都包含一个指向构造函数的指针constructor，而实例都包含一个指向原型对象的内部指针__proto__（有的地方称为[[prototype]]）。</li>\n</ol>\n<h2 id=\"重写prototype对象\"><a href=\"#重写prototype对象\" class=\"headerlink\" title=\"重写prototype对象\"></a>重写prototype对象</h2><p>在上面两个例子的基础上，再进行如下操作<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person.prototype = &#123;</div><div class=\"line\">    name: <span class=\"string\">\"bruce\"</span>,</div><div class=\"line\">    age: <span class=\"number\">23</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>上面使用的语法将会<strong>完全重写默认的prototype对象</strong>，其会直接导致Person的prototype对象里面没有了constructor属性，constructor属性只能从Person.prototype.<strong>proto</strong>.constructor继承过来(Person.prototype的原型对象为Object原型对象)，即constructor将指向<strong>Object构造函数</strong></li>\n<li>把原型对象修改为另外一个对象就等于，切断了构造函数Person和<strong>最初的原型对象</strong>之间的联系。<br>但是实例angela和最初的原型对象之间的联系不变。<br><strong>注：</strong>实例中的__proto__指针仅指向原型，而不指向构造函数。</li>\n</ul>\n<h2 id=\"搜索一个属性\"><a href=\"#搜索一个属性\" class=\"headerlink\" title=\"搜索一个属性\"></a>搜索一个属性</h2><ul>\n<li>每当代码读取某个对象的属性时，首先会在对象实例本身中<strong>搜索</strong>，如果在实例中找到了该属性，则返回该属性。如果没有找到，则继续在<strong>__proto__</strong>指向的原型对象中<strong>搜索</strong>，如果找到了该属性，则返回该属性。如此继续下去。<br>也就是说当为对象实例添加了一个属性时，这个属性就会<strong>屏蔽</strong>原型对象中保存的<strong>同名属性</strong>。</li>\n<li><code>hasOwnProperty</code>方法可以检测一个属性是存在于实例中，还是存在于原型中，只有给定属性存在于实例中，才会返回true。</li>\n</ul>\n<h2 id=\"prototye属性\"><a href=\"#prototye属性\" class=\"headerlink\" title=\"prototye属性\"></a>prototye属性</h2><ul>\n<li>JS中万物皆对象,通常来说，javascript中的对象就是一个指向原型对象的指针和一个自身的属性列表。<br>prototype属性本质上它就是一个普通的指针,其之所以特别，是因为javascript时<strong>读取属性时的遍历机制决定的</strong>。<br>只有<strong>构造函数才具有prototype属性</strong>，且只有以下对象才是构造函数：<br>5种基本引用类型（Object、Array、Date、RegExp、Function）、3种包装类型（Boolean、Number、String）、Function的实例<br>javascript创建对象时采用了写时复制的理念，当调用构造函数创建一个实例后，该实例内部将包含一个指针（内部属性,下图中暂时称为inobj），指向构造函数的原型对象。<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/1593745-54254e96f4a43db7.jpg\" alt=\"调用构造函数创建一个实例\"></li>\n<li>而普通对象是没有prototype属性的，在chrome上对象有一个__proto__属性指向对象的原型，但是<br>在其他浏览器上这个属性对外完全不可见，要取得普通对象的原型对象，可以调用Object.getPrototypeOf(instance),便可取得实例instance的原型。</li>\n</ul>\n<p><strong>总结：</strong>JS中的每个对象都包含一个指向其原型对象的指针，这个指针在构造函数是<strong>prototype属性</strong>，可以直接访问；在普通对象中是__proto__属性，不可以直接访问。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><ul>\n<li>让一个函数的原型对象等于另外一个类型的实例，而这个实例的原型对象又等于另外一个类型的实例，如此层层递进，就构成了<code>实例与原型之间</code>的<strong>一条链条</strong>，这就是所谓原型链的概念。<br>若A继承自B，B又继承自C，则这条原型链为：<code>A的实例-&gt;A的原型对象-&gt;B的原型对象-&gt;C的原型对象-&gt;Object的原型对象-&gt;null</code></li>\n<li>所有引用类型的prototype指针默认都指向Object的原型对象，所有函数的默认原型对象的__proto__指针都指向Object的原型对象。</li>\n<li>原型链是JS实现继承的主要方法。</li>\n<li>如果实例A的__proto__指针指向类型B的<strong>原型对象</strong>，可以直接指向，也可以间接指向（即A-&gt;C-&gt;B），则<strong>称A是B的实例</strong>。</li>\n<li><p>instanceof操作符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">A <span class=\"keyword\">instanceof</span> B</div><div class=\"line\"><span class=\"comment\">//如果类型B的原型对象出现在实例A的原型链中，则返回true</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>作用域链和原型链<br>作用域链用来查找对象<br>原型链用来查找对象的属性</p>\n</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"http://www.jianshu.com/p/c8f29b62fec8\" target=\"_blank\" rel=\"external\">公司一位大牛关于prototype的总结</a></li>\n<li><a href=\"http://fungwan.me/2015/01/05/js%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/\" target=\"_blank\" rel=\"external\">理解js中的原型继承</a></li>\n</ol>\n","excerpt":"","more":"<p>动态语言和静态语言有很大的不同，比如在C++中定义类时，并不分配内存，而在动态语言中定义类时，却会分配内存。</p>\n<ul>\n<li>比如在JS中<strong>定义</strong>了一个函数时，将会为该函数创建一个<strong>prototype</strong>属性，这个属性指向该函数的原型对象；JS中万物皆对象，一个对象要么是函数的实例，要么是原型的实例。</li>\n<li>比如在Python中定义了一个类时，将会创建一个<strong>类型对象</strong>（类其实是能够创建出类实例的对象，类本身也是实例，而且是metaclass元类的实例）；Python中所有的东西都是对象，其要么是类的实例，要么是<strong>metaclass元类</strong>的实例。</li>\n</ul>\n<p>原型对象中的属性被<strong>所有实例所共享</strong>，这类似于C++中的静态成员，静态成员属于类本身，而不是属于对象，但是被类的所有实例所共有。</p>\n<h2 id=\"创建一个空函数\"><a href=\"#创建一个空函数\" class=\"headerlink\" title=\"创建一个空函数\"></a>创建一个空函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div></pre></td></tr></table></figure>\n<p>像这样创建一个空函数，js解析为以下三步：</p>\n<ol>\n<li>创建一个Object对象（有constructor属性及[[Prototype]]属性）;</li>\n<li>创建一个函数（有name、prototype属性），再通过prototype属性引用刚才创建的对象;</li>\n<li>创建变量Person，同时把函数的引用赋值给变量Person<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/prototype.png\" alt=\"如图可以表示为\"></li>\n</ol>\n<h2 id=\"实例化一个对象\"><a href=\"#实例化一个对象\" class=\"headerlink\" title=\"实例化一个对象\"></a>实例化一个对象</h2><p>我们用上面这个Person函数去实例化一个对象时，js解析又是怎样呢？比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> angela = <span class=\"keyword\">new</span> Person();</div></pre></td></tr></table></figure></p>\n<p>实例化出来的对象，js解析也分为下面三步：</p>\n<ol>\n<li>新建一个对象并赋值给变量angela：var angela = {};</li>\n<li>把这个对象的[[Prototype]]属性指向函数Person的原型对象：angela.[[Prototype]] = Person.prototype</li>\n<li>调用函数Person，同时把this指向刚创建的对象angela，对这个对象进行初始化：Person.apply(angela,arguments)<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/prototype1.png\" alt=\"如图可表示为\"><br><strong>总结：</strong>构造函数、原型和实例之间的关系，每个构造函数包含一个指向原型对象的指针prototype，原型对象都包含一个指向构造函数的指针constructor，而实例都包含一个指向原型对象的内部指针__proto__（有的地方称为[[prototype]]）。</li>\n</ol>\n<h2 id=\"重写prototype对象\"><a href=\"#重写prototype对象\" class=\"headerlink\" title=\"重写prototype对象\"></a>重写prototype对象</h2><p>在上面两个例子的基础上，再进行如下操作<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person.prototype = &#123;</div><div class=\"line\">    name: <span class=\"string\">\"bruce\"</span>,</div><div class=\"line\">    age: <span class=\"number\">23</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>上面使用的语法将会<strong>完全重写默认的prototype对象</strong>，其会直接导致Person的prototype对象里面没有了constructor属性，constructor属性只能从Person.prototype.<strong>proto</strong>.constructor继承过来(Person.prototype的原型对象为Object原型对象)，即constructor将指向<strong>Object构造函数</strong></li>\n<li>把原型对象修改为另外一个对象就等于，切断了构造函数Person和<strong>最初的原型对象</strong>之间的联系。<br>但是实例angela和最初的原型对象之间的联系不变。<br><strong>注：</strong>实例中的__proto__指针仅指向原型，而不指向构造函数。</li>\n</ul>\n<h2 id=\"搜索一个属性\"><a href=\"#搜索一个属性\" class=\"headerlink\" title=\"搜索一个属性\"></a>搜索一个属性</h2><ul>\n<li>每当代码读取某个对象的属性时，首先会在对象实例本身中<strong>搜索</strong>，如果在实例中找到了该属性，则返回该属性。如果没有找到，则继续在<strong>__proto__</strong>指向的原型对象中<strong>搜索</strong>，如果找到了该属性，则返回该属性。如此继续下去。<br>也就是说当为对象实例添加了一个属性时，这个属性就会<strong>屏蔽</strong>原型对象中保存的<strong>同名属性</strong>。</li>\n<li><code>hasOwnProperty</code>方法可以检测一个属性是存在于实例中，还是存在于原型中，只有给定属性存在于实例中，才会返回true。</li>\n</ul>\n<h2 id=\"prototye属性\"><a href=\"#prototye属性\" class=\"headerlink\" title=\"prototye属性\"></a>prototye属性</h2><ul>\n<li>JS中万物皆对象,通常来说，javascript中的对象就是一个指向原型对象的指针和一个自身的属性列表。<br>prototype属性本质上它就是一个普通的指针,其之所以特别，是因为javascript时<strong>读取属性时的遍历机制决定的</strong>。<br>只有<strong>构造函数才具有prototype属性</strong>，且只有以下对象才是构造函数：<br>5种基本引用类型（Object、Array、Date、RegExp、Function）、3种包装类型（Boolean、Number、String）、Function的实例<br>javascript创建对象时采用了写时复制的理念，当调用构造函数创建一个实例后，该实例内部将包含一个指针（内部属性,下图中暂时称为inobj），指向构造函数的原型对象。<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/1593745-54254e96f4a43db7.jpg\" alt=\"调用构造函数创建一个实例\"></li>\n<li>而普通对象是没有prototype属性的，在chrome上对象有一个__proto__属性指向对象的原型，但是<br>在其他浏览器上这个属性对外完全不可见，要取得普通对象的原型对象，可以调用Object.getPrototypeOf(instance),便可取得实例instance的原型。</li>\n</ul>\n<p><strong>总结：</strong>JS中的每个对象都包含一个指向其原型对象的指针，这个指针在构造函数是<strong>prototype属性</strong>，可以直接访问；在普通对象中是__proto__属性，不可以直接访问。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><ul>\n<li>让一个函数的原型对象等于另外一个类型的实例，而这个实例的原型对象又等于另外一个类型的实例，如此层层递进，就构成了<code>实例与原型之间</code>的<strong>一条链条</strong>，这就是所谓原型链的概念。<br>若A继承自B，B又继承自C，则这条原型链为：<code>A的实例-&gt;A的原型对象-&gt;B的原型对象-&gt;C的原型对象-&gt;Object的原型对象-&gt;null</code></li>\n<li>所有引用类型的prototype指针默认都指向Object的原型对象，所有函数的默认原型对象的__proto__指针都指向Object的原型对象。</li>\n<li>原型链是JS实现继承的主要方法。</li>\n<li>如果实例A的__proto__指针指向类型B的<strong>原型对象</strong>，可以直接指向，也可以间接指向（即A-&gt;C-&gt;B），则<strong>称A是B的实例</strong>。</li>\n<li><p>instanceof操作符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">A <span class=\"keyword\">instanceof</span> B</div><div class=\"line\"><span class=\"comment\">//如果类型B的原型对象出现在实例A的原型链中，则返回true</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>作用域链和原型链<br>作用域链用来查找对象<br>原型链用来查找对象的属性</p>\n</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"http://www.jianshu.com/p/c8f29b62fec8\">公司一位大牛关于prototype的总结</a></li>\n<li><a href=\"http://fungwan.me/2015/01/05/js%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/\">理解js中的原型继承</a></li>\n</ol>"},{"title":"深刻理解JS的作用域链","description":"作用域链的概念对理解闭包至关重要","toc":true,"date":"2016-05-28T15:47:42.000Z","_content":"作用域链的概念对理解闭包至关重要\n<!--more-->\n## 先来一个例子\n\n```JavaScript\nvar scope = \"global\";\nfunction CheckScope(){\n    var scope = \"local\";\n    return scope;\n}\nCheckScope();\n//结果为local\n```\n1.当代码进入Global Execution Context后，会创建Global VO\n![](http://7xtj85.com1.z0.glb.clouddn.com/global%20EC.png)\n2.当代码执行到`CheckScope();`语句的时候，进入CheckScope Execution Context；根据上一篇文章<执行环境>的介绍，这里会创建CheckScope VO，并设置CheckScope Execution Context的`[[Scope]]属性`\n![](http://7xtj85.com1.z0.glb.clouddn.com/local_ECS.png)\n\n## 作用域链的创建规则\n### 当定义一个函数时\n在函数内部会创建一个`[[Scope]]属性`，这个属性指向一条作用域链。\n也就是说在定义函数时，会**事先创建**一条作用域链。\n这从chrome中可以看出来，如下图所示，`<function scope>即为我说的[[Scope]]属性`\n![](http://7xtj85.com1.z0.glb.clouddn.com/test.png)\n而这条事先就创建好的作用域链的创建规则也是很重要的，有以下几点：\n- JS中只有**两种类型**的作用域：全局作用域、函数作用域，所以在作用域链上的对象，**只可能**是window对象或者函数执行环境所对应的变量对象，**但是with语句是一个例外**，其可以临时在作用域链的前端临时增加一个**普通对象**。\n\n```JavaScript\nvar o = {\n    bruceZhou: 'bruceZhou',\n    fn: function(){\n        console.log(fn)\n        console.log(bruceZhou);\n    }\n}\no.fn();\n//ERROR报错\n//因为在执行匿名函数时，其作用域链为匿名函数所对应的变量对象--->window对象\n//所以会找不到fn和bruceZhou的定义\n\n//最重要的是其作用域链不包括对象o，对象o只负责保存fn\n//在JS中只有全局作用域、函数作用域，并没有对象作用域这一说\n//如果要在fn内部访问对象o，可以引用this或者使用with语句\n```\n\n- 一个函数被定义时，在确定其`[[Scope]]属性`时，JS解释器执行如下的规则：从函数内部向外遍历，每当**碰到一个`function {...}`时**，就将其对应的变量对象添加至作用域链中去，如此下去，直到window对象，然后将作用域链的引用赋给`[[Scope]]属性`。\n\n### 当调用这个函数时\n解释器会先创建一个新的变量对象，\n然后将这个变量对象的添加至上面那个作用域链的栈顶，\n此后将函数内部的`[[Scope]]属性`直接赋值给执行环境的`[[Scope]]属性`。\n\n### 当函数执行完之后\n1.对应的函数执行环境肯定会被销毁\n2.函数内部属性[[Scope]]指向的作用链的栈顶肯定会被pop，以解除对该执行函数所对应的变量对象的引用，\n3.**但该执行函数所对应的变量对象却不一定会被销毁，**\n因为可能还有其他东西引用着这个变量对象，这时就会发生闭包现象。\n\n## 作用域链的数据结构\n作用域即变量对象，**作用域链是一个由变量对象组成的带头结点的单向链表，其主要作用就是用来进行变量查找。而[[Scope]]属性是一个指向这个链表头结点的指针。**\n\n### 带头结点的单链表\n1.结点的存储结构（用C语言来表示）\n```C\ntypedef struct _tNODE{\n    VariableObject *pVO;\n    //指向一个变量对象，即指向一个作用域\n    struct _tNODE *next;\n    //指向下一个结点\n}tNODE, *tPNODE;\n```\n\n2.猜想\n我猜想作用域链的数据大概如下，是一个链栈，只是为了说明问题，不保证准确性，当然我也是不会为它负责的。\n![](http://7xtj85.com1.z0.glb.clouddn.com/scope%20chainpng.png)\n\n","source":"_posts/深刻理解JS的作用域链.md","raw":"---\ntitle: 深刻理解JS的作用域链\ncategories: JavaScript\ntags: [JavaScript, Scope chain, 前端开发, 闭包]\ndescription: 作用域链的概念对理解闭包至关重要\ntoc: true\ndate: 2016-05-28 23:47:42\n---\n作用域链的概念对理解闭包至关重要\n<!--more-->\n## 先来一个例子\n\n```JavaScript\nvar scope = \"global\";\nfunction CheckScope(){\n    var scope = \"local\";\n    return scope;\n}\nCheckScope();\n//结果为local\n```\n1.当代码进入Global Execution Context后，会创建Global VO\n![](http://7xtj85.com1.z0.glb.clouddn.com/global%20EC.png)\n2.当代码执行到`CheckScope();`语句的时候，进入CheckScope Execution Context；根据上一篇文章<执行环境>的介绍，这里会创建CheckScope VO，并设置CheckScope Execution Context的`[[Scope]]属性`\n![](http://7xtj85.com1.z0.glb.clouddn.com/local_ECS.png)\n\n## 作用域链的创建规则\n### 当定义一个函数时\n在函数内部会创建一个`[[Scope]]属性`，这个属性指向一条作用域链。\n也就是说在定义函数时，会**事先创建**一条作用域链。\n这从chrome中可以看出来，如下图所示，`<function scope>即为我说的[[Scope]]属性`\n![](http://7xtj85.com1.z0.glb.clouddn.com/test.png)\n而这条事先就创建好的作用域链的创建规则也是很重要的，有以下几点：\n- JS中只有**两种类型**的作用域：全局作用域、函数作用域，所以在作用域链上的对象，**只可能**是window对象或者函数执行环境所对应的变量对象，**但是with语句是一个例外**，其可以临时在作用域链的前端临时增加一个**普通对象**。\n\n```JavaScript\nvar o = {\n    bruceZhou: 'bruceZhou',\n    fn: function(){\n        console.log(fn)\n        console.log(bruceZhou);\n    }\n}\no.fn();\n//ERROR报错\n//因为在执行匿名函数时，其作用域链为匿名函数所对应的变量对象--->window对象\n//所以会找不到fn和bruceZhou的定义\n\n//最重要的是其作用域链不包括对象o，对象o只负责保存fn\n//在JS中只有全局作用域、函数作用域，并没有对象作用域这一说\n//如果要在fn内部访问对象o，可以引用this或者使用with语句\n```\n\n- 一个函数被定义时，在确定其`[[Scope]]属性`时，JS解释器执行如下的规则：从函数内部向外遍历，每当**碰到一个`function {...}`时**，就将其对应的变量对象添加至作用域链中去，如此下去，直到window对象，然后将作用域链的引用赋给`[[Scope]]属性`。\n\n### 当调用这个函数时\n解释器会先创建一个新的变量对象，\n然后将这个变量对象的添加至上面那个作用域链的栈顶，\n此后将函数内部的`[[Scope]]属性`直接赋值给执行环境的`[[Scope]]属性`。\n\n### 当函数执行完之后\n1.对应的函数执行环境肯定会被销毁\n2.函数内部属性[[Scope]]指向的作用链的栈顶肯定会被pop，以解除对该执行函数所对应的变量对象的引用，\n3.**但该执行函数所对应的变量对象却不一定会被销毁，**\n因为可能还有其他东西引用着这个变量对象，这时就会发生闭包现象。\n\n## 作用域链的数据结构\n作用域即变量对象，**作用域链是一个由变量对象组成的带头结点的单向链表，其主要作用就是用来进行变量查找。而[[Scope]]属性是一个指向这个链表头结点的指针。**\n\n### 带头结点的单链表\n1.结点的存储结构（用C语言来表示）\n```C\ntypedef struct _tNODE{\n    VariableObject *pVO;\n    //指向一个变量对象，即指向一个作用域\n    struct _tNODE *next;\n    //指向下一个结点\n}tNODE, *tPNODE;\n```\n\n2.猜想\n我猜想作用域链的数据大概如下，是一个链栈，只是为了说明问题，不保证准确性，当然我也是不会为它负责的。\n![](http://7xtj85.com1.z0.glb.clouddn.com/scope%20chainpng.png)\n\n","slug":"深刻理解JS的作用域链","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrpv0018526ran1banth","content":"<p>作用域链的概念对理解闭包至关重要<br><a id=\"more\"></a></p>\n<h2 id=\"先来一个例子\"><a href=\"#先来一个例子\" class=\"headerlink\" title=\"先来一个例子\"></a>先来一个例子</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">\"global\"</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">CheckScope</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">\"local\"</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> scope;</div><div class=\"line\">&#125;</div><div class=\"line\">CheckScope();</div><div class=\"line\"><span class=\"comment\">//结果为local</span></div></pre></td></tr></table></figure>\n<p>1.当代码进入Global Execution Context后，会创建Global VO<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/global%20EC.png\" alt=\"\"><br>2.当代码执行到<code>CheckScope();</code>语句的时候，进入CheckScope Execution Context；根据上一篇文章&lt;执行环境&gt;的介绍，这里会创建CheckScope VO，并设置CheckScope Execution Context的<code>[[Scope]]属性</code><br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/local_ECS.png\" alt=\"\"></p>\n<h2 id=\"作用域链的创建规则\"><a href=\"#作用域链的创建规则\" class=\"headerlink\" title=\"作用域链的创建规则\"></a>作用域链的创建规则</h2><h3 id=\"当定义一个函数时\"><a href=\"#当定义一个函数时\" class=\"headerlink\" title=\"当定义一个函数时\"></a>当定义一个函数时</h3><p>在函数内部会创建一个<code>[[Scope]]属性</code>，这个属性指向一条作用域链。<br>也就是说在定义函数时，会<strong>事先创建</strong>一条作用域链。<br>这从chrome中可以看出来，如下图所示，<code>&lt;function scope&gt;即为我说的[[Scope]]属性</code><br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/test.png\" alt=\"\"><br>而这条事先就创建好的作用域链的创建规则也是很重要的，有以下几点：</p>\n<ul>\n<li>JS中只有<strong>两种类型</strong>的作用域：全局作用域、函数作用域，所以在作用域链上的对象，<strong>只可能</strong>是window对象或者函数执行环境所对应的变量对象，<strong>但是with语句是一个例外</strong>，其可以临时在作用域链的前端临时增加一个<strong>普通对象</strong>。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">    bruceZhou: <span class=\"string\">'bruceZhou'</span>,</div><div class=\"line\">    fn: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(fn)</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(bruceZhou);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">o.fn();</div><div class=\"line\"><span class=\"comment\">//ERROR报错</span></div><div class=\"line\"><span class=\"comment\">//因为在执行匿名函数时，其作用域链为匿名函数所对应的变量对象---&gt;window对象</span></div><div class=\"line\"><span class=\"comment\">//所以会找不到fn和bruceZhou的定义</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//最重要的是其作用域链不包括对象o，对象o只负责保存fn</span></div><div class=\"line\"><span class=\"comment\">//在JS中只有全局作用域、函数作用域，并没有对象作用域这一说</span></div><div class=\"line\"><span class=\"comment\">//如果要在fn内部访问对象o，可以引用this或者使用with语句</span></div></pre></td></tr></table></figure>\n<ul>\n<li>一个函数被定义时，在确定其<code>[[Scope]]属性</code>时，JS解释器执行如下的规则：从函数内部向外遍历，每当<strong>碰到一个<code>function {...}</code>时</strong>，就将其对应的变量对象添加至作用域链中去，如此下去，直到window对象，然后将作用域链的引用赋给<code>[[Scope]]属性</code>。</li>\n</ul>\n<h3 id=\"当调用这个函数时\"><a href=\"#当调用这个函数时\" class=\"headerlink\" title=\"当调用这个函数时\"></a>当调用这个函数时</h3><p>解释器会先创建一个新的变量对象，<br>然后将这个变量对象的添加至上面那个作用域链的栈顶，<br>此后将函数内部的<code>[[Scope]]属性</code>直接赋值给执行环境的<code>[[Scope]]属性</code>。</p>\n<h3 id=\"当函数执行完之后\"><a href=\"#当函数执行完之后\" class=\"headerlink\" title=\"当函数执行完之后\"></a>当函数执行完之后</h3><p>1.对应的函数执行环境肯定会被销毁<br>2.函数内部属性[[Scope]]指向的作用链的栈顶肯定会被pop，以解除对该执行函数所对应的变量对象的引用，<br>3.<strong>但该执行函数所对应的变量对象却不一定会被销毁，</strong><br>因为可能还有其他东西引用着这个变量对象，这时就会发生闭包现象。</p>\n<h2 id=\"作用域链的数据结构\"><a href=\"#作用域链的数据结构\" class=\"headerlink\" title=\"作用域链的数据结构\"></a>作用域链的数据结构</h2><p>作用域即变量对象，<strong>作用域链是一个由变量对象组成的带头结点的单向链表，其主要作用就是用来进行变量查找。而[[Scope]]属性是一个指向这个链表头结点的指针。</strong></p>\n<h3 id=\"带头结点的单链表\"><a href=\"#带头结点的单链表\" class=\"headerlink\" title=\"带头结点的单链表\"></a>带头结点的单链表</h3><p>1.结点的存储结构（用C语言来表示）<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"number\">_</span>tNODE&#123;</div><div class=\"line\">    VariableObject *pVO;</div><div class=\"line\">    <span class=\"comment\">//指向一个变量对象，即指向一个作用域</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"number\">_</span>tNODE *next;</div><div class=\"line\">    <span class=\"comment\">//指向下一个结点</span></div><div class=\"line\">&#125;tNODE, *tPNODE;</div></pre></td></tr></table></figure></p>\n<p>2.猜想<br>我猜想作用域链的数据大概如下，是一个链栈，只是为了说明问题，不保证准确性，当然我也是不会为它负责的。<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/scope%20chainpng.png\" alt=\"\"></p>\n","excerpt":"<p>作用域链的概念对理解闭包至关重要<br>","more":"</p>\n<h2 id=\"先来一个例子\"><a href=\"#先来一个例子\" class=\"headerlink\" title=\"先来一个例子\"></a>先来一个例子</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">\"global\"</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">CheckScope</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">\"local\"</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> scope;</div><div class=\"line\">&#125;</div><div class=\"line\">CheckScope();</div><div class=\"line\"><span class=\"comment\">//结果为local</span></div></pre></td></tr></table></figure>\n<p>1.当代码进入Global Execution Context后，会创建Global VO<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/global%20EC.png\" alt=\"\"><br>2.当代码执行到<code>CheckScope();</code>语句的时候，进入CheckScope Execution Context；根据上一篇文章&lt;执行环境&gt;的介绍，这里会创建CheckScope VO，并设置CheckScope Execution Context的<code>[[Scope]]属性</code><br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/local_ECS.png\" alt=\"\"></p>\n<h2 id=\"作用域链的创建规则\"><a href=\"#作用域链的创建规则\" class=\"headerlink\" title=\"作用域链的创建规则\"></a>作用域链的创建规则</h2><h3 id=\"当定义一个函数时\"><a href=\"#当定义一个函数时\" class=\"headerlink\" title=\"当定义一个函数时\"></a>当定义一个函数时</h3><p>在函数内部会创建一个<code>[[Scope]]属性</code>，这个属性指向一条作用域链。<br>也就是说在定义函数时，会<strong>事先创建</strong>一条作用域链。<br>这从chrome中可以看出来，如下图所示，<code>&lt;function scope&gt;即为我说的[[Scope]]属性</code><br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/test.png\" alt=\"\"><br>而这条事先就创建好的作用域链的创建规则也是很重要的，有以下几点：</p>\n<ul>\n<li>JS中只有<strong>两种类型</strong>的作用域：全局作用域、函数作用域，所以在作用域链上的对象，<strong>只可能</strong>是window对象或者函数执行环境所对应的变量对象，<strong>但是with语句是一个例外</strong>，其可以临时在作用域链的前端临时增加一个<strong>普通对象</strong>。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">    bruceZhou: <span class=\"string\">'bruceZhou'</span>,</div><div class=\"line\">    fn: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(fn)</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(bruceZhou);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">o.fn();</div><div class=\"line\"><span class=\"comment\">//ERROR报错</span></div><div class=\"line\"><span class=\"comment\">//因为在执行匿名函数时，其作用域链为匿名函数所对应的变量对象---&gt;window对象</span></div><div class=\"line\"><span class=\"comment\">//所以会找不到fn和bruceZhou的定义</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//最重要的是其作用域链不包括对象o，对象o只负责保存fn</span></div><div class=\"line\"><span class=\"comment\">//在JS中只有全局作用域、函数作用域，并没有对象作用域这一说</span></div><div class=\"line\"><span class=\"comment\">//如果要在fn内部访问对象o，可以引用this或者使用with语句</span></div></pre></td></tr></table></figure>\n<ul>\n<li>一个函数被定义时，在确定其<code>[[Scope]]属性</code>时，JS解释器执行如下的规则：从函数内部向外遍历，每当<strong>碰到一个<code>function {...}</code>时</strong>，就将其对应的变量对象添加至作用域链中去，如此下去，直到window对象，然后将作用域链的引用赋给<code>[[Scope]]属性</code>。</li>\n</ul>\n<h3 id=\"当调用这个函数时\"><a href=\"#当调用这个函数时\" class=\"headerlink\" title=\"当调用这个函数时\"></a>当调用这个函数时</h3><p>解释器会先创建一个新的变量对象，<br>然后将这个变量对象的添加至上面那个作用域链的栈顶，<br>此后将函数内部的<code>[[Scope]]属性</code>直接赋值给执行环境的<code>[[Scope]]属性</code>。</p>\n<h3 id=\"当函数执行完之后\"><a href=\"#当函数执行完之后\" class=\"headerlink\" title=\"当函数执行完之后\"></a>当函数执行完之后</h3><p>1.对应的函数执行环境肯定会被销毁<br>2.函数内部属性[[Scope]]指向的作用链的栈顶肯定会被pop，以解除对该执行函数所对应的变量对象的引用，<br>3.<strong>但该执行函数所对应的变量对象却不一定会被销毁，</strong><br>因为可能还有其他东西引用着这个变量对象，这时就会发生闭包现象。</p>\n<h2 id=\"作用域链的数据结构\"><a href=\"#作用域链的数据结构\" class=\"headerlink\" title=\"作用域链的数据结构\"></a>作用域链的数据结构</h2><p>作用域即变量对象，<strong>作用域链是一个由变量对象组成的带头结点的单向链表，其主要作用就是用来进行变量查找。而[[Scope]]属性是一个指向这个链表头结点的指针。</strong></p>\n<h3 id=\"带头结点的单链表\"><a href=\"#带头结点的单链表\" class=\"headerlink\" title=\"带头结点的单链表\"></a>带头结点的单链表</h3><p>1.结点的存储结构（用C语言来表示）<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"number\">_</span>tNODE&#123;</div><div class=\"line\">    VariableObject *pVO;</div><div class=\"line\">    <span class=\"comment\">//指向一个变量对象，即指向一个作用域</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"number\">_</span>tNODE *next;</div><div class=\"line\">    <span class=\"comment\">//指向下一个结点</span></div><div class=\"line\">&#125;tNODE, *tPNODE;</div></pre></td></tr></table></figure></p>\n<p>2.猜想<br>我猜想作用域链的数据大概如下，是一个链栈，只是为了说明问题，不保证准确性，当然我也是不会为它负责的。<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/scope%20chainpng.png\" alt=\"\"></p>"},{"title":"理解JS的执行环境","description":"执行环境（Execution context，EC）或执行上下文，是JS中一个极为重要的概念","toc":true,"date":"2016-05-25T07:15:36.000Z","_content":"执行环境（Execution context，EC）或执行上下文，是JS中一个极为重要的概念\n<!--more-->\n## EC的组成\n当JavaScript代码执行的时候，会进入不同的执行上下文，这些执行上下文会构成了一个**执行上下文栈**（Execution context stack，ECS）。\n![EC的组成](http://7xtj85.com1.z0.glb.clouddn.com/Execution%20Context.png)\n- 变量对象（Variable object，VO）: 变量对象即包含变量的对象，除了我们无法访问它外，和普通对象没什么区别。\n- `[[Scope]]`属性:作用域即变量对象，**作用域链是一个由变量对象组成的带头结点的单向链表，其主要作用就是用来进行变量查找。而[[Scope]]属性是一个指向这个链表头节点的指针。**\n- this: 指向一个环境对象，注意是一个对象，而且是一个**普通对象**，而不是一个执行环境。\n\n## 产生EC的两个阶段\n当一段JS代码执行的时候，JS解释器会通过两个阶段去产生一个EC\n1. 创建阶段（当函数被调用，但是开始执行函数内部代码之前）\n 1. 创建变量对象VO\n 2. 设置`[[Scope]]`属性的值\n 3. 设置this的值\n2. 激活/代码执行阶段\n**初始化变量对象**，即设置变量的值、函数的引用，然后解释/执行代码。\n\n## 创建变量对象VO\n1. 根据函数的参数，创建并初始化arguments object\n2. 扫描函数内部代码，查找函数声明（function declaration）\n - 对于所有找到的函数声明，将函数名和函数引用存入VO中\n - 如果VO中已经有同名函数、同名变量，那么就进行`覆盖`\n```JavaScript\n//函数声明\nfunction f(){}\n```\n3. 扫描函数内部代码，查找变量声明（Variable declaration）\n - 对于所有找到的变量声明，将变量名存入VO中，并初始化为undefined\n - 如果变量名跟已经声明的形参或函数相同，则`什么也不做`\n```JavaScript\n//变量声明，必须通过var关键字声明\nvar example = 'example'\n```\n**注：\n1.**步骤2和3也称为声明提升（`declaration hoisting`）\n2.当函数和变量同名时，函数的优先级要高一点\n3.没有使用var声明的变量（这种变量是全局的声明方式，只是给Global添加了一个属性，并不在VO中）\n4.函数表达式（与函数声明相对）不包含在VO之中\n\n\n## 执行环境的分类\n- 全局执行环境\n在浏览器中，其指`window对象`，是JS代码开始运行时的默认环境。\n全局执行环境的变量对象**始终都是**作用域链中的最后一个对象。\n- 函数执行环境\n当某个函数被调用时，会**先创建**一个执行环境及相应的作用域链。**然后**使用arguments和其他命名参数的值来**初始化**执行环境的变量对象。\n\n注：上面的分类也说明了JS中只有**两种作用域**（作用域即变量对象）：全局作用域、函数作用域，并没有块级作用域，更没有对象作用域(见最后的例子，但是with语句是一个例外，其可以临时在作用域链的前端增加一个普通对象)\n\n## this\n见文章：JS中的this\n\n## 参考资料\n[JavaScript的执行上下文, 五星级好文](http://www.cnblogs.com/wilber2013/p/4909430.html)\n[JavaScript中的this](http://www.cnblogs.com/wilber2013/p/4909505.html)\n[理解JavaScript中的作用域链](http://www.cnblogs.com/wilber2013/p/4909459.html)\n[Scope chain](http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/)\n[JavaScript高级程序设计](https://book.douban.com/subject/10546125/)\n","source":"_posts/理解JS的执行环境.md","raw":"---\ntitle: 理解JS的执行环境\ncategories: JavaScript\ntags: [JavaScript, 前端开发]\ndescription: 执行环境（Execution context，EC）或执行上下文，是JS中一个极为重要的概念\ntoc: true\ndate: 2016-05-25 15:15:36\n---\n执行环境（Execution context，EC）或执行上下文，是JS中一个极为重要的概念\n<!--more-->\n## EC的组成\n当JavaScript代码执行的时候，会进入不同的执行上下文，这些执行上下文会构成了一个**执行上下文栈**（Execution context stack，ECS）。\n![EC的组成](http://7xtj85.com1.z0.glb.clouddn.com/Execution%20Context.png)\n- 变量对象（Variable object，VO）: 变量对象即包含变量的对象，除了我们无法访问它外，和普通对象没什么区别。\n- `[[Scope]]`属性:作用域即变量对象，**作用域链是一个由变量对象组成的带头结点的单向链表，其主要作用就是用来进行变量查找。而[[Scope]]属性是一个指向这个链表头节点的指针。**\n- this: 指向一个环境对象，注意是一个对象，而且是一个**普通对象**，而不是一个执行环境。\n\n## 产生EC的两个阶段\n当一段JS代码执行的时候，JS解释器会通过两个阶段去产生一个EC\n1. 创建阶段（当函数被调用，但是开始执行函数内部代码之前）\n 1. 创建变量对象VO\n 2. 设置`[[Scope]]`属性的值\n 3. 设置this的值\n2. 激活/代码执行阶段\n**初始化变量对象**，即设置变量的值、函数的引用，然后解释/执行代码。\n\n## 创建变量对象VO\n1. 根据函数的参数，创建并初始化arguments object\n2. 扫描函数内部代码，查找函数声明（function declaration）\n - 对于所有找到的函数声明，将函数名和函数引用存入VO中\n - 如果VO中已经有同名函数、同名变量，那么就进行`覆盖`\n```JavaScript\n//函数声明\nfunction f(){}\n```\n3. 扫描函数内部代码，查找变量声明（Variable declaration）\n - 对于所有找到的变量声明，将变量名存入VO中，并初始化为undefined\n - 如果变量名跟已经声明的形参或函数相同，则`什么也不做`\n```JavaScript\n//变量声明，必须通过var关键字声明\nvar example = 'example'\n```\n**注：\n1.**步骤2和3也称为声明提升（`declaration hoisting`）\n2.当函数和变量同名时，函数的优先级要高一点\n3.没有使用var声明的变量（这种变量是全局的声明方式，只是给Global添加了一个属性，并不在VO中）\n4.函数表达式（与函数声明相对）不包含在VO之中\n\n\n## 执行环境的分类\n- 全局执行环境\n在浏览器中，其指`window对象`，是JS代码开始运行时的默认环境。\n全局执行环境的变量对象**始终都是**作用域链中的最后一个对象。\n- 函数执行环境\n当某个函数被调用时，会**先创建**一个执行环境及相应的作用域链。**然后**使用arguments和其他命名参数的值来**初始化**执行环境的变量对象。\n\n注：上面的分类也说明了JS中只有**两种作用域**（作用域即变量对象）：全局作用域、函数作用域，并没有块级作用域，更没有对象作用域(见最后的例子，但是with语句是一个例外，其可以临时在作用域链的前端增加一个普通对象)\n\n## this\n见文章：JS中的this\n\n## 参考资料\n[JavaScript的执行上下文, 五星级好文](http://www.cnblogs.com/wilber2013/p/4909430.html)\n[JavaScript中的this](http://www.cnblogs.com/wilber2013/p/4909505.html)\n[理解JavaScript中的作用域链](http://www.cnblogs.com/wilber2013/p/4909459.html)\n[Scope chain](http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/)\n[JavaScript高级程序设计](https://book.douban.com/subject/10546125/)\n","slug":"理解JS的执行环境","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrpz001b526rfgfrr0fy","content":"<p>执行环境（Execution context，EC）或执行上下文，是JS中一个极为重要的概念<br><a id=\"more\"></a></p>\n<h2 id=\"EC的组成\"><a href=\"#EC的组成\" class=\"headerlink\" title=\"EC的组成\"></a>EC的组成</h2><p>当JavaScript代码执行的时候，会进入不同的执行上下文，这些执行上下文会构成了一个<strong>执行上下文栈</strong>（Execution context stack，ECS）。<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/Execution%20Context.png\" alt=\"EC的组成\"></p>\n<ul>\n<li>变量对象（Variable object，VO）: 变量对象即包含变量的对象，除了我们无法访问它外，和普通对象没什么区别。</li>\n<li><code>[[Scope]]</code>属性:作用域即变量对象，<strong>作用域链是一个由变量对象组成的带头结点的单向链表，其主要作用就是用来进行变量查找。而[[Scope]]属性是一个指向这个链表头节点的指针。</strong></li>\n<li>this: 指向一个环境对象，注意是一个对象，而且是一个<strong>普通对象</strong>，而不是一个执行环境。</li>\n</ul>\n<h2 id=\"产生EC的两个阶段\"><a href=\"#产生EC的两个阶段\" class=\"headerlink\" title=\"产生EC的两个阶段\"></a>产生EC的两个阶段</h2><p>当一段JS代码执行的时候，JS解释器会通过两个阶段去产生一个EC</p>\n<ol>\n<li>创建阶段（当函数被调用，但是开始执行函数内部代码之前）<ol>\n<li>创建变量对象VO</li>\n<li>设置<code>[[Scope]]</code>属性的值</li>\n<li>设置this的值</li>\n</ol>\n</li>\n<li>激活/代码执行阶段<br><strong>初始化变量对象</strong>，即设置变量的值、函数的引用，然后解释/执行代码。</li>\n</ol>\n<h2 id=\"创建变量对象VO\"><a href=\"#创建变量对象VO\" class=\"headerlink\" title=\"创建变量对象VO\"></a>创建变量对象VO</h2><ol>\n<li>根据函数的参数，创建并初始化arguments object</li>\n<li><p>扫描函数内部代码，查找函数声明（function declaration）</p>\n<ul>\n<li>对于所有找到的函数声明，将函数名和函数引用存入VO中</li>\n<li>如果VO中已经有同名函数、同名变量，那么就进行<code>覆盖</code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//函数声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>扫描函数内部代码，查找变量声明（Variable declaration）</p>\n<ul>\n<li>对于所有找到的变量声明，将变量名存入VO中，并初始化为undefined</li>\n<li>如果变量名跟已经声明的形参或函数相同，则<code>什么也不做</code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//变量声明，必须通过var关键字声明</span></div><div class=\"line\"><span class=\"keyword\">var</span> example = <span class=\"string\">'example'</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>注：<br>1.</strong>步骤2和3也称为声明提升（<code>declaration hoisting</code>）<br>2.当函数和变量同名时，函数的优先级要高一点<br>3.没有使用var声明的变量（这种变量是全局的声明方式，只是给Global添加了一个属性，并不在VO中）<br>4.函数表达式（与函数声明相对）不包含在VO之中</p>\n<h2 id=\"执行环境的分类\"><a href=\"#执行环境的分类\" class=\"headerlink\" title=\"执行环境的分类\"></a>执行环境的分类</h2><ul>\n<li>全局执行环境<br>在浏览器中，其指<code>window对象</code>，是JS代码开始运行时的默认环境。<br>全局执行环境的变量对象<strong>始终都是</strong>作用域链中的最后一个对象。</li>\n<li>函数执行环境<br>当某个函数被调用时，会<strong>先创建</strong>一个执行环境及相应的作用域链。<strong>然后</strong>使用arguments和其他命名参数的值来<strong>初始化</strong>执行环境的变量对象。</li>\n</ul>\n<p>注：上面的分类也说明了JS中只有<strong>两种作用域</strong>（作用域即变量对象）：全局作用域、函数作用域，并没有块级作用域，更没有对象作用域(见最后的例子，但是with语句是一个例外，其可以临时在作用域链的前端增加一个普通对象)</p>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><p>见文章：JS中的this</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://www.cnblogs.com/wilber2013/p/4909430.html\" target=\"_blank\" rel=\"external\">JavaScript的执行上下文, 五星级好文</a><br><a href=\"http://www.cnblogs.com/wilber2013/p/4909505.html\" target=\"_blank\" rel=\"external\">JavaScript中的this</a><br><a href=\"http://www.cnblogs.com/wilber2013/p/4909459.html\" target=\"_blank\" rel=\"external\">理解JavaScript中的作用域链</a><br><a href=\"http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/\" target=\"_blank\" rel=\"external\">Scope chain</a><br><a href=\"https://book.douban.com/subject/10546125/\" target=\"_blank\" rel=\"external\">JavaScript高级程序设计</a></p>\n","excerpt":"<p>执行环境（Execution context，EC）或执行上下文，是JS中一个极为重要的概念<br>","more":"</p>\n<h2 id=\"EC的组成\"><a href=\"#EC的组成\" class=\"headerlink\" title=\"EC的组成\"></a>EC的组成</h2><p>当JavaScript代码执行的时候，会进入不同的执行上下文，这些执行上下文会构成了一个<strong>执行上下文栈</strong>（Execution context stack，ECS）。<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/Execution%20Context.png\" alt=\"EC的组成\"></p>\n<ul>\n<li>变量对象（Variable object，VO）: 变量对象即包含变量的对象，除了我们无法访问它外，和普通对象没什么区别。</li>\n<li><code>[[Scope]]</code>属性:作用域即变量对象，<strong>作用域链是一个由变量对象组成的带头结点的单向链表，其主要作用就是用来进行变量查找。而[[Scope]]属性是一个指向这个链表头节点的指针。</strong></li>\n<li>this: 指向一个环境对象，注意是一个对象，而且是一个<strong>普通对象</strong>，而不是一个执行环境。</li>\n</ul>\n<h2 id=\"产生EC的两个阶段\"><a href=\"#产生EC的两个阶段\" class=\"headerlink\" title=\"产生EC的两个阶段\"></a>产生EC的两个阶段</h2><p>当一段JS代码执行的时候，JS解释器会通过两个阶段去产生一个EC</p>\n<ol>\n<li>创建阶段（当函数被调用，但是开始执行函数内部代码之前）<ol>\n<li>创建变量对象VO</li>\n<li>设置<code>[[Scope]]</code>属性的值</li>\n<li>设置this的值</li>\n</ol>\n</li>\n<li>激活/代码执行阶段<br><strong>初始化变量对象</strong>，即设置变量的值、函数的引用，然后解释/执行代码。</li>\n</ol>\n<h2 id=\"创建变量对象VO\"><a href=\"#创建变量对象VO\" class=\"headerlink\" title=\"创建变量对象VO\"></a>创建变量对象VO</h2><ol>\n<li>根据函数的参数，创建并初始化arguments object</li>\n<li><p>扫描函数内部代码，查找函数声明（function declaration）</p>\n<ul>\n<li>对于所有找到的函数声明，将函数名和函数引用存入VO中</li>\n<li>如果VO中已经有同名函数、同名变量，那么就进行<code>覆盖</code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//函数声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>扫描函数内部代码，查找变量声明（Variable declaration）</p>\n<ul>\n<li>对于所有找到的变量声明，将变量名存入VO中，并初始化为undefined</li>\n<li>如果变量名跟已经声明的形参或函数相同，则<code>什么也不做</code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//变量声明，必须通过var关键字声明</span></div><div class=\"line\"><span class=\"keyword\">var</span> example = <span class=\"string\">'example'</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>注：<br>1.</strong>步骤2和3也称为声明提升（<code>declaration hoisting</code>）<br>2.当函数和变量同名时，函数的优先级要高一点<br>3.没有使用var声明的变量（这种变量是全局的声明方式，只是给Global添加了一个属性，并不在VO中）<br>4.函数表达式（与函数声明相对）不包含在VO之中</p>\n<h2 id=\"执行环境的分类\"><a href=\"#执行环境的分类\" class=\"headerlink\" title=\"执行环境的分类\"></a>执行环境的分类</h2><ul>\n<li>全局执行环境<br>在浏览器中，其指<code>window对象</code>，是JS代码开始运行时的默认环境。<br>全局执行环境的变量对象<strong>始终都是</strong>作用域链中的最后一个对象。</li>\n<li>函数执行环境<br>当某个函数被调用时，会<strong>先创建</strong>一个执行环境及相应的作用域链。<strong>然后</strong>使用arguments和其他命名参数的值来<strong>初始化</strong>执行环境的变量对象。</li>\n</ul>\n<p>注：上面的分类也说明了JS中只有<strong>两种作用域</strong>（作用域即变量对象）：全局作用域、函数作用域，并没有块级作用域，更没有对象作用域(见最后的例子，但是with语句是一个例外，其可以临时在作用域链的前端增加一个普通对象)</p>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><p>见文章：JS中的this</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://www.cnblogs.com/wilber2013/p/4909430.html\">JavaScript的执行上下文, 五星级好文</a><br><a href=\"http://www.cnblogs.com/wilber2013/p/4909505.html\">JavaScript中的this</a><br><a href=\"http://www.cnblogs.com/wilber2013/p/4909459.html\">理解JavaScript中的作用域链</a><br><a href=\"http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/\">Scope chain</a><br><a href=\"https://book.douban.com/subject/10546125/\">JavaScript高级程序设计</a></p>"},{"title":"用单例模式来采集GA数据","toc":true,"date":"2016-05-19T09:49:29.000Z","description":["单例模式在项目中的运用"],"_content":"单例模式在项目中的运用\n<!--more-->\n## GA简介 ##\n\nGA是Google Analytics的简称，GA提供了非常强大的数据采集功能，我在这个博客中就引入了GA，你在这里看了我的那一篇文章，点了什么东西，我都能看到，如下图所示。\n![这个博客的GA统计数据](http://7xtj85.com1.z0.glb.clouddn.com/ga_blog.png)\n而且最重要的是，它是免费的，在网页中你只需要嵌入一小段JS脚本即可，但在C++中这样不行，但本质上来讲采集GA数据的过程是一个HTTP GET请求(可以从Chrome的开发者工具的Network面板中看到，也可以用WireShark抓包得到)。\n所以在C++只要按照相应的格式发送HTTP GET请求就行了。\n![发送GA事件](http://7xtj85.com1.z0.glb.clouddn.com/ga_request_true.png)\n![GA响应](http://7xtj85.com1.z0.glb.clouddn.com/ga_response.png)\n附：[GA开发者手册](https://developers.google.com/analytics/devguides/collection/analyticsjs/events)\n\n## C++发送GA事件 ##\n\n在项目中只用GA来追踪用户点击事件，简单来说一共有三个字段：\n- category: 对应一张UI\n- action: 对应上面这张UI中的一个button\n- label: 可以是版本号或语言等等\n\n由于项目中发送GA事件的频率很高，在很多地方都会用到，所以第一时间想到采用**单例模式(Singleton)**,Singleton有两个特点：\n- 实例化控制：保证一个类只有一个实例\n- 全局访问：提供了一个全局访问点\n\n![单例模式结构图](http://7xtj85.com1.z0.glb.clouddn.com/singleton.png)\n\n很显然单例模式用在这里很合适，核心code如下：\n```C++\nclass GAEvent\n{\npublic:\n    ~GAEvent(void);\n    static GAEvent * GetInstance()\n    /*此方法是获得本类实例的唯一全局访问点\n    注意到它是一个静态方法*/\n    {\n        if (NULL == m_instance)\n        {\n            boost::lock_guard<boost::mutex> lock(m_InstanceMutex);\n            if (NULL == m_instance)\n            /*考虑到多线程时可能会创建多个实例\n            所以采用了双重锁定来避免这个问题*/\n            {\n                m_instance  = new GAEvent();\n            }\n        }\n        return m_instance;\n    }\nprivate:\n    GAEvent(void);\n    /*构造方法为private，这就堵死了外界利用\n    new创建此类实例的可能*/\n}\nGAEvent *gaEvent = GAEvent::GetInstance();\n```\n\n###  懒汉式与饿汉式 ###\n- 懒汉式：在类被加载时就将自己实例化。\n```C++\nclass SingletonStatic  \n{  \nprivate:  \n    static const SingletonStatic* m_instance;  \n    SingletonStatic(){}  \npublic:  \n    static SingletonStatic* getInstance()  \n    {  \n        return m_instance;  \n    }  \n};  \n  \n//静态变量是在main函数调用之前就完成初始化的\nconst SingletonStatic* SingletonStatic::m_instance = new SingletonStatic; \n```\n- 饿汉式:上面的方式就是饿汉式单例类，即要在第一次引用时，才会将自己实例化。\n\n##  其它 ##\n- 在项目中调用nmap相关的方法时也用到了单例模式的地方,UI上大部分的数据都来源于nmap\n- 改进：应用解释器模式\n   **解释器模式**的应用场景：如果一种**特定类型的问题发生的频率足够高**，那么就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。\n  上面说到GA事件有三个字段：category、action、label，由于我把一个button的GA事件放到了HTML标签的id属性中，所以指定一个固定的格式很重要，而且这个问题的频率很高，最后我指定了如下格式：feedback_bad &lt;label&gt;too slow&lt;/label&gt;\n  在上述string中，category为feedback，action为bad，label为too slow","source":"_posts/用单例模式来采集GA数据.md","raw":"---\ntitle: 用单例模式来采集GA数据\ntoc: true\ndate: 2016-05-19 17:49:29\ncategories: [C++, 设计模式]\ntags: [C++, 设计模式, HTTP]\ndescription: [单例模式在项目中的运用]\n---\n单例模式在项目中的运用\n<!--more-->\n## GA简介 ##\n\nGA是Google Analytics的简称，GA提供了非常强大的数据采集功能，我在这个博客中就引入了GA，你在这里看了我的那一篇文章，点了什么东西，我都能看到，如下图所示。\n![这个博客的GA统计数据](http://7xtj85.com1.z0.glb.clouddn.com/ga_blog.png)\n而且最重要的是，它是免费的，在网页中你只需要嵌入一小段JS脚本即可，但在C++中这样不行，但本质上来讲采集GA数据的过程是一个HTTP GET请求(可以从Chrome的开发者工具的Network面板中看到，也可以用WireShark抓包得到)。\n所以在C++只要按照相应的格式发送HTTP GET请求就行了。\n![发送GA事件](http://7xtj85.com1.z0.glb.clouddn.com/ga_request_true.png)\n![GA响应](http://7xtj85.com1.z0.glb.clouddn.com/ga_response.png)\n附：[GA开发者手册](https://developers.google.com/analytics/devguides/collection/analyticsjs/events)\n\n## C++发送GA事件 ##\n\n在项目中只用GA来追踪用户点击事件，简单来说一共有三个字段：\n- category: 对应一张UI\n- action: 对应上面这张UI中的一个button\n- label: 可以是版本号或语言等等\n\n由于项目中发送GA事件的频率很高，在很多地方都会用到，所以第一时间想到采用**单例模式(Singleton)**,Singleton有两个特点：\n- 实例化控制：保证一个类只有一个实例\n- 全局访问：提供了一个全局访问点\n\n![单例模式结构图](http://7xtj85.com1.z0.glb.clouddn.com/singleton.png)\n\n很显然单例模式用在这里很合适，核心code如下：\n```C++\nclass GAEvent\n{\npublic:\n    ~GAEvent(void);\n    static GAEvent * GetInstance()\n    /*此方法是获得本类实例的唯一全局访问点\n    注意到它是一个静态方法*/\n    {\n        if (NULL == m_instance)\n        {\n            boost::lock_guard<boost::mutex> lock(m_InstanceMutex);\n            if (NULL == m_instance)\n            /*考虑到多线程时可能会创建多个实例\n            所以采用了双重锁定来避免这个问题*/\n            {\n                m_instance  = new GAEvent();\n            }\n        }\n        return m_instance;\n    }\nprivate:\n    GAEvent(void);\n    /*构造方法为private，这就堵死了外界利用\n    new创建此类实例的可能*/\n}\nGAEvent *gaEvent = GAEvent::GetInstance();\n```\n\n###  懒汉式与饿汉式 ###\n- 懒汉式：在类被加载时就将自己实例化。\n```C++\nclass SingletonStatic  \n{  \nprivate:  \n    static const SingletonStatic* m_instance;  \n    SingletonStatic(){}  \npublic:  \n    static SingletonStatic* getInstance()  \n    {  \n        return m_instance;  \n    }  \n};  \n  \n//静态变量是在main函数调用之前就完成初始化的\nconst SingletonStatic* SingletonStatic::m_instance = new SingletonStatic; \n```\n- 饿汉式:上面的方式就是饿汉式单例类，即要在第一次引用时，才会将自己实例化。\n\n##  其它 ##\n- 在项目中调用nmap相关的方法时也用到了单例模式的地方,UI上大部分的数据都来源于nmap\n- 改进：应用解释器模式\n   **解释器模式**的应用场景：如果一种**特定类型的问题发生的频率足够高**，那么就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。\n  上面说到GA事件有三个字段：category、action、label，由于我把一个button的GA事件放到了HTML标签的id属性中，所以指定一个固定的格式很重要，而且这个问题的频率很高，最后我指定了如下格式：feedback_bad &lt;label&gt;too slow&lt;/label&gt;\n  在上述string中，category为feedback，action为bad，label为too slow","slug":"用单例模式来采集GA数据","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrq2001f526rv6v2hvzz","content":"<p>单例模式在项目中的运用<br><a id=\"more\"></a></p>\n<h2 id=\"GA简介\"><a href=\"#GA简介\" class=\"headerlink\" title=\"GA简介\"></a>GA简介</h2><p>GA是Google Analytics的简称，GA提供了非常强大的数据采集功能，我在这个博客中就引入了GA，你在这里看了我的那一篇文章，点了什么东西，我都能看到，如下图所示。<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/ga_blog.png\" alt=\"这个博客的GA统计数据\"><br>而且最重要的是，它是免费的，在网页中你只需要嵌入一小段JS脚本即可，但在C++中这样不行，但本质上来讲采集GA数据的过程是一个HTTP GET请求(可以从Chrome的开发者工具的Network面板中看到，也可以用WireShark抓包得到)。<br>所以在C++只要按照相应的格式发送HTTP GET请求就行了。<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/ga_request_true.png\" alt=\"发送GA事件\"><br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/ga_response.png\" alt=\"GA响应\"><br>附：<a href=\"https://developers.google.com/analytics/devguides/collection/analyticsjs/events\" target=\"_blank\" rel=\"external\">GA开发者手册</a></p>\n<h2 id=\"C-发送GA事件\"><a href=\"#C-发送GA事件\" class=\"headerlink\" title=\"C++发送GA事件\"></a>C++发送GA事件</h2><p>在项目中只用GA来追踪用户点击事件，简单来说一共有三个字段：</p>\n<ul>\n<li>category: 对应一张UI</li>\n<li>action: 对应上面这张UI中的一个button</li>\n<li>label: 可以是版本号或语言等等</li>\n</ul>\n<p>由于项目中发送GA事件的频率很高，在很多地方都会用到，所以第一时间想到采用<strong>单例模式(Singleton)</strong>,Singleton有两个特点：</p>\n<ul>\n<li>实例化控制：保证一个类只有一个实例</li>\n<li>全局访问：提供了一个全局访问点</li>\n</ul>\n<p><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/singleton.png\" alt=\"单例模式结构图\"></p>\n<p>很显然单例模式用在这里很合适，核心code如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> GAEvent</div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    ~GAEvent(<span class=\"keyword\">void</span>);</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> GAEvent * <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span></div><div class=\"line\">    <span class=\"comment\">/*此方法是获得本类实例的唯一全局访问点</span></div><div class=\"line\">    注意到它是一个静态方法*/</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == m_instance)</div><div class=\"line\">        &#123;</div><div class=\"line\">            boost::lock_guard&lt;boost::mutex&gt; lock(m_InstanceMutex);</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == m_instance)</div><div class=\"line\">            <span class=\"comment\">/*考虑到多线程时可能会创建多个实例</span></div><div class=\"line\">            所以采用了双重锁定来避免这个问题*/</div><div class=\"line\">            &#123;</div><div class=\"line\">                m_instance  = <span class=\"keyword\">new</span> GAEvent();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> m_instance;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    GAEvent(<span class=\"keyword\">void</span>);</div><div class=\"line\">    <span class=\"comment\">/*构造方法为private，这就堵死了外界利用</span></div><div class=\"line\">    new创建此类实例的可能*/</div><div class=\"line\">&#125;</div><div class=\"line\">GAEvent *gaEvent = GAEvent::GetInstance();</div></pre></td></tr></table></figure></p>\n<h3 id=\"懒汉式与饿汉式\"><a href=\"#懒汉式与饿汉式\" class=\"headerlink\" title=\"懒汉式与饿汉式\"></a>懒汉式与饿汉式</h3><ul>\n<li><p>懒汉式：在类被加载时就将自己实例化。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> SingletonStatic  </div><div class=\"line\">&#123;  </div><div class=\"line\"><span class=\"keyword\">private</span>:  </div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> SingletonStatic* m_instance;  </div><div class=\"line\">    SingletonStatic()&#123;&#125;  </div><div class=\"line\"><span class=\"keyword\">public</span>:  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> SingletonStatic* <span class=\"title\">getInstance</span><span class=\"params\">()</span>  </span></div><div class=\"line\">    &#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> m_instance;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//静态变量是在main函数调用之前就完成初始化的</span></div><div class=\"line\"><span class=\"keyword\">const</span> SingletonStatic* SingletonStatic::m_instance = <span class=\"keyword\">new</span> SingletonStatic;</div></pre></td></tr></table></figure>\n</li>\n<li><p>饿汉式:上面的方式就是饿汉式单例类，即要在第一次引用时，才会将自己实例化。</p>\n</li>\n</ul>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><ul>\n<li>在项目中调用nmap相关的方法时也用到了单例模式的地方,UI上大部分的数据都来源于nmap</li>\n<li>改进：应用解释器模式<br> <strong>解释器模式</strong>的应用场景：如果一种<strong>特定类型的问题发生的频率足够高</strong>，那么就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。<br>上面说到GA事件有三个字段：category、action、label，由于我把一个button的GA事件放到了HTML标签的id属性中，所以指定一个固定的格式很重要，而且这个问题的频率很高，最后我指定了如下格式：feedback_bad &lt;label&gt;too slow&lt;/label&gt;<br>在上述string中，category为feedback，action为bad，label为too slow</li>\n</ul>\n","excerpt":"<p>单例模式在项目中的运用<br>","more":"</p>\n<h2 id=\"GA简介\"><a href=\"#GA简介\" class=\"headerlink\" title=\"GA简介\"></a>GA简介</h2><p>GA是Google Analytics的简称，GA提供了非常强大的数据采集功能，我在这个博客中就引入了GA，你在这里看了我的那一篇文章，点了什么东西，我都能看到，如下图所示。<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/ga_blog.png\" alt=\"这个博客的GA统计数据\"><br>而且最重要的是，它是免费的，在网页中你只需要嵌入一小段JS脚本即可，但在C++中这样不行，但本质上来讲采集GA数据的过程是一个HTTP GET请求(可以从Chrome的开发者工具的Network面板中看到，也可以用WireShark抓包得到)。<br>所以在C++只要按照相应的格式发送HTTP GET请求就行了。<br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/ga_request_true.png\" alt=\"发送GA事件\"><br><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/ga_response.png\" alt=\"GA响应\"><br>附：<a href=\"https://developers.google.com/analytics/devguides/collection/analyticsjs/events\">GA开发者手册</a></p>\n<h2 id=\"C-发送GA事件\"><a href=\"#C-发送GA事件\" class=\"headerlink\" title=\"C++发送GA事件\"></a>C++发送GA事件</h2><p>在项目中只用GA来追踪用户点击事件，简单来说一共有三个字段：</p>\n<ul>\n<li>category: 对应一张UI</li>\n<li>action: 对应上面这张UI中的一个button</li>\n<li>label: 可以是版本号或语言等等</li>\n</ul>\n<p>由于项目中发送GA事件的频率很高，在很多地方都会用到，所以第一时间想到采用<strong>单例模式(Singleton)</strong>,Singleton有两个特点：</p>\n<ul>\n<li>实例化控制：保证一个类只有一个实例</li>\n<li>全局访问：提供了一个全局访问点</li>\n</ul>\n<p><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/singleton.png\" alt=\"单例模式结构图\"></p>\n<p>很显然单例模式用在这里很合适，核心code如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> GAEvent</div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    ~GAEvent(<span class=\"keyword\">void</span>);</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> GAEvent * <span class=\"title\">GetInstance</span><span class=\"params\">()</span></div><div class=\"line\">    <span class=\"comment\">/*此方法是获得本类实例的唯一全局访问点</div><div class=\"line\">    注意到它是一个静态方法*/</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == m_instance)</div><div class=\"line\">        &#123;</div><div class=\"line\">            boost::lock_guard&lt;boost::mutex&gt; lock(m_InstanceMutex);</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == m_instance)</div><div class=\"line\">            <span class=\"comment\">/*考虑到多线程时可能会创建多个实例</div><div class=\"line\">            所以采用了双重锁定来避免这个问题*/</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                m_instance  = <span class=\"keyword\">new</span> GAEvent();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> m_instance;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    GAEvent(<span class=\"keyword\">void</span>);</div><div class=\"line\">    <span class=\"comment\">/*构造方法为private，这就堵死了外界利用</div><div class=\"line\">    new创建此类实例的可能*/</span></div><div class=\"line\">&#125;</div><div class=\"line\">GAEvent *gaEvent = GAEvent::GetInstance();</div></pre></td></tr></table></figure></p>\n<h3 id=\"懒汉式与饿汉式\"><a href=\"#懒汉式与饿汉式\" class=\"headerlink\" title=\"懒汉式与饿汉式\"></a>懒汉式与饿汉式</h3><ul>\n<li><p>懒汉式：在类被加载时就将自己实例化。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> SingletonStatic  </div><div class=\"line\">&#123;  </div><div class=\"line\"><span class=\"keyword\">private</span>:  </div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> SingletonStatic* m_instance;  </div><div class=\"line\">    SingletonStatic()&#123;&#125;  </div><div class=\"line\"><span class=\"keyword\">public</span>:  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> SingletonStatic* <span class=\"title\">getInstance</span><span class=\"params\">()</span>  </div><div class=\"line\">    </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> m_instance;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//静态变量是在main函数调用之前就完成初始化的</span></div><div class=\"line\"><span class=\"keyword\">const</span> SingletonStatic* SingletonStatic::m_instance = <span class=\"keyword\">new</span> SingletonStatic;</div></pre></td></tr></table></figure>\n</li>\n<li><p>饿汉式:上面的方式就是饿汉式单例类，即要在第一次引用时，才会将自己实例化。</p>\n</li>\n</ul>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><ul>\n<li>在项目中调用nmap相关的方法时也用到了单例模式的地方,UI上大部分的数据都来源于nmap</li>\n<li>改进：应用解释器模式<br> <strong>解释器模式</strong>的应用场景：如果一种<strong>特定类型的问题发生的频率足够高</strong>，那么就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。<br>上面说到GA事件有三个字段：category、action、label，由于我把一个button的GA事件放到了HTML标签的id属性中，所以指定一个固定的格式很重要，而且这个问题的频率很高，最后我指定了如下格式：feedback_bad &lt;label&gt;too slow&lt;/label&gt;<br>在上述string中，category为feedback，action为bad，label为too slow</li>\n</ul>"},{"title":"记趋势科技工作一年","description":"人生中遇到的每一个人，发生的每一件事都是命中注定，一路走来，感恩大家一路相伴","toc":true,"date":"2016-07-11T16:32:04.000Z","_content":"人生中遇到的每一个人，发生的每一件事都是命中注定，一路走来，感恩大家一路相伴\n<!--more-->\n## 浮生若梦，往事成风\n> 弃我去者昨日之日不可留，天下也没有不散的宴席，人生路不回头，算了，我走了，好马不吃回头草，即以成风，又何必去想，又何必留恋。\n\n![散伙饭了，555](http://7xtj85.com1.z0.glb.clouddn.com/%E6%95%A3%E4%BC%99%E9%A5%AD.jpg)\n我是去年7月6号来公司报到，16号进的项目组，是zhonglin把我从5楼领下来的，就这样来到了3楼，到今年7月11号，转眼间整整一年就过去了，只不过去年来的时候是骄阳似火，而今年走的时候是大雨磅礴，记得刚来时一切都很新鲜，我至今还记得我们西安的3个人拖着箱子走出花神庙地铁站的情境，真的是仿佛一切都在昨天。\n\n在公司一年中，我成长的很快，在技术和沟通上都有很大的提升，先是Jerry带的我，然后是大Bruce带的我，最后是斌哥带的我，特别是斌哥，经验很丰富，有带人的经验，最关键的是斌哥愿意带我们这些新人，没有斌哥带之前，我的code写的很差劲，斌哥带了我之后，是一行一行code review的，我开始说什么地方重要再review，斌哥说不管大小都要review，事实证明这个过程对我的帮助是非常巨大的，斌哥当时还跟我说了一句话，我记忆很深刻，大概是不是每个人都有机会去经历一个完整的项目过程，我也从DRS中领悟到了:小步快跑、不断试错、快速迭代的敏捷开发理念。但是最后下来，我还是把斌哥给坑了，我真的感觉最对不住的人就是斌哥了。\n\n和大家在一起整整一年了，一年时间说长不长说短不短，我一直有一个感觉，真的是没有任何人有义务给你指导，给你耐心的去讲一些东西，要说有的话这也是人和人之间的缘分，作为一个重感情的人，从某种程度上来讲，我是很感恩公司的，刚来公司试用期结束的时候，在做总结的时候我也说过同样的话，我清楚的知道公司对我有知遇之恩，所以时常感恩公司给我提供工作与学习的机会，也感激大家一年来对我的照顾，特别是斌哥和Thomas，但是我想要一行代码能影响到许多人的那种成就感，遗憾的是我在这里找不到，我为此进行了长时间的思考，花费了很多精力，最后得出了一个残酷的现实：公司没有任何问题，我也没有问题，只是不适合而已。\n\n## 路就在那里，一直向前\n> 英国人乔治是世界上第一位登上珠峰的人，《纽约时报》有一次问乔治，说：你为什么要攀登珠峰，乔治说： 因为山就在那里！随后成为了一句名言。\n\n因为路就在那里一直向前，所以生活还得继续，都说好男儿志在四方，因为人无信（自信）不立，所以理应四海为家，我还年轻，我愿意用现在这么多安逸的日子，去换一个机会，就一个机会，只为在我还年轻的时候有幸去经历一个野蛮生长、过山车般的项目（当然这只是我的奢望，这种事看缘分了，你懂的），我可能会走得很远，也可能下一步就会跌倒，但人生就像奔涌的浪花，不遇到坚硬的礁石，难以激起美丽的浪花，人生更像一盒巧克力，你永远不知道下一块会是什么味道，而冒险的意义即在于此，梦想的意义也在于此。 \n\n倘若没有梦想，那我和咸鱼又有什么区别呢，如果满足现状，至少还能多快活一会，年复一年，日复一日，但我宁愿用这么多快活的日子，就换一个机会，就一个机会，回到这里，告诉现实，你也许能使我一天饥肠辘辘，但你永远也夺不走我的梦想，我也一直坚信我不会为了任何事而流泪，除了登上纽交易所的那一刻，这就是我的梦想。\n\n而关于梦想最重要的是不要让任何人告诉你，你不能做什么，只要你有梦想，就要去追求，别人办不到，就会说你也办不到，你想要什么，就要努力的去追求，对于想做的事，倘若心中愿意，道路千万条，倘若心中不愿意，理由千万个，虽千万里，吾往矣。\n\n而我最想做的事也是最幸福的事，不是躺在床上睡到自然醒，也不是坐在家里无所事事，而是和一群志同道合充满正能量的人，一起奔跑在理想的路上，什么都经历过了，回头有一路的故事，低头有坚定的脚步，抬头有清晰的远方。和一群有梦想的人一起奔跑，就是最美好的生活方式。\n\n再过几天，我就要挥师北上，兵发紫禁城，也不要问我为什么要去，因为路就在那里，不长不短。但是可以肯定的是在人生中遇到的每一个人，发生的每一件事都是命中注定，一路走来，感恩大家一路相伴！\n\n\n\n\n\n","source":"_posts/记趋势科技工作一年.md","raw":"---\ntitle: 记趋势科技工作一年\ncategories: 胡言乱语\ntags: [趋势科技, 工作一年, 感恩]\ndescription: 人生中遇到的每一个人，发生的每一件事都是命中注定，一路走来，感恩大家一路相伴\ntoc: true\ndate: 2016-07-12 00:32:04\n---\n人生中遇到的每一个人，发生的每一件事都是命中注定，一路走来，感恩大家一路相伴\n<!--more-->\n## 浮生若梦，往事成风\n> 弃我去者昨日之日不可留，天下也没有不散的宴席，人生路不回头，算了，我走了，好马不吃回头草，即以成风，又何必去想，又何必留恋。\n\n![散伙饭了，555](http://7xtj85.com1.z0.glb.clouddn.com/%E6%95%A3%E4%BC%99%E9%A5%AD.jpg)\n我是去年7月6号来公司报到，16号进的项目组，是zhonglin把我从5楼领下来的，就这样来到了3楼，到今年7月11号，转眼间整整一年就过去了，只不过去年来的时候是骄阳似火，而今年走的时候是大雨磅礴，记得刚来时一切都很新鲜，我至今还记得我们西安的3个人拖着箱子走出花神庙地铁站的情境，真的是仿佛一切都在昨天。\n\n在公司一年中，我成长的很快，在技术和沟通上都有很大的提升，先是Jerry带的我，然后是大Bruce带的我，最后是斌哥带的我，特别是斌哥，经验很丰富，有带人的经验，最关键的是斌哥愿意带我们这些新人，没有斌哥带之前，我的code写的很差劲，斌哥带了我之后，是一行一行code review的，我开始说什么地方重要再review，斌哥说不管大小都要review，事实证明这个过程对我的帮助是非常巨大的，斌哥当时还跟我说了一句话，我记忆很深刻，大概是不是每个人都有机会去经历一个完整的项目过程，我也从DRS中领悟到了:小步快跑、不断试错、快速迭代的敏捷开发理念。但是最后下来，我还是把斌哥给坑了，我真的感觉最对不住的人就是斌哥了。\n\n和大家在一起整整一年了，一年时间说长不长说短不短，我一直有一个感觉，真的是没有任何人有义务给你指导，给你耐心的去讲一些东西，要说有的话这也是人和人之间的缘分，作为一个重感情的人，从某种程度上来讲，我是很感恩公司的，刚来公司试用期结束的时候，在做总结的时候我也说过同样的话，我清楚的知道公司对我有知遇之恩，所以时常感恩公司给我提供工作与学习的机会，也感激大家一年来对我的照顾，特别是斌哥和Thomas，但是我想要一行代码能影响到许多人的那种成就感，遗憾的是我在这里找不到，我为此进行了长时间的思考，花费了很多精力，最后得出了一个残酷的现实：公司没有任何问题，我也没有问题，只是不适合而已。\n\n## 路就在那里，一直向前\n> 英国人乔治是世界上第一位登上珠峰的人，《纽约时报》有一次问乔治，说：你为什么要攀登珠峰，乔治说： 因为山就在那里！随后成为了一句名言。\n\n因为路就在那里一直向前，所以生活还得继续，都说好男儿志在四方，因为人无信（自信）不立，所以理应四海为家，我还年轻，我愿意用现在这么多安逸的日子，去换一个机会，就一个机会，只为在我还年轻的时候有幸去经历一个野蛮生长、过山车般的项目（当然这只是我的奢望，这种事看缘分了，你懂的），我可能会走得很远，也可能下一步就会跌倒，但人生就像奔涌的浪花，不遇到坚硬的礁石，难以激起美丽的浪花，人生更像一盒巧克力，你永远不知道下一块会是什么味道，而冒险的意义即在于此，梦想的意义也在于此。 \n\n倘若没有梦想，那我和咸鱼又有什么区别呢，如果满足现状，至少还能多快活一会，年复一年，日复一日，但我宁愿用这么多快活的日子，就换一个机会，就一个机会，回到这里，告诉现实，你也许能使我一天饥肠辘辘，但你永远也夺不走我的梦想，我也一直坚信我不会为了任何事而流泪，除了登上纽交易所的那一刻，这就是我的梦想。\n\n而关于梦想最重要的是不要让任何人告诉你，你不能做什么，只要你有梦想，就要去追求，别人办不到，就会说你也办不到，你想要什么，就要努力的去追求，对于想做的事，倘若心中愿意，道路千万条，倘若心中不愿意，理由千万个，虽千万里，吾往矣。\n\n而我最想做的事也是最幸福的事，不是躺在床上睡到自然醒，也不是坐在家里无所事事，而是和一群志同道合充满正能量的人，一起奔跑在理想的路上，什么都经历过了，回头有一路的故事，低头有坚定的脚步，抬头有清晰的远方。和一群有梦想的人一起奔跑，就是最美好的生活方式。\n\n再过几天，我就要挥师北上，兵发紫禁城，也不要问我为什么要去，因为路就在那里，不长不短。但是可以肯定的是在人生中遇到的每一个人，发生的每一件事都是命中注定，一路走来，感恩大家一路相伴！\n\n\n\n\n\n","slug":"记趋势科技工作一年","published":1,"updated":"2016-07-29T10:47:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrq6001j526rwfg26j9i","content":"<p>人生中遇到的每一个人，发生的每一件事都是命中注定，一路走来，感恩大家一路相伴<br><a id=\"more\"></a></p>\n<h2 id=\"浮生若梦，往事成风\"><a href=\"#浮生若梦，往事成风\" class=\"headerlink\" title=\"浮生若梦，往事成风\"></a>浮生若梦，往事成风</h2><blockquote>\n<p>弃我去者昨日之日不可留，天下也没有不散的宴席，人生路不回头，算了，我走了，好马不吃回头草，即以成风，又何必去想，又何必留恋。</p>\n</blockquote>\n<p><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/%E6%95%A3%E4%BC%99%E9%A5%AD.jpg\" alt=\"散伙饭了，555\"><br>我是去年7月6号来公司报到，16号进的项目组，是zhonglin把我从5楼领下来的，就这样来到了3楼，到今年7月11号，转眼间整整一年就过去了，只不过去年来的时候是骄阳似火，而今年走的时候是大雨磅礴，记得刚来时一切都很新鲜，我至今还记得我们西安的3个人拖着箱子走出花神庙地铁站的情境，真的是仿佛一切都在昨天。</p>\n<p>在公司一年中，我成长的很快，在技术和沟通上都有很大的提升，先是Jerry带的我，然后是大Bruce带的我，最后是斌哥带的我，特别是斌哥，经验很丰富，有带人的经验，最关键的是斌哥愿意带我们这些新人，没有斌哥带之前，我的code写的很差劲，斌哥带了我之后，是一行一行code review的，我开始说什么地方重要再review，斌哥说不管大小都要review，事实证明这个过程对我的帮助是非常巨大的，斌哥当时还跟我说了一句话，我记忆很深刻，大概是不是每个人都有机会去经历一个完整的项目过程，我也从DRS中领悟到了:小步快跑、不断试错、快速迭代的敏捷开发理念。但是最后下来，我还是把斌哥给坑了，我真的感觉最对不住的人就是斌哥了。</p>\n<p>和大家在一起整整一年了，一年时间说长不长说短不短，我一直有一个感觉，真的是没有任何人有义务给你指导，给你耐心的去讲一些东西，要说有的话这也是人和人之间的缘分，作为一个重感情的人，从某种程度上来讲，我是很感恩公司的，刚来公司试用期结束的时候，在做总结的时候我也说过同样的话，我清楚的知道公司对我有知遇之恩，所以时常感恩公司给我提供工作与学习的机会，也感激大家一年来对我的照顾，特别是斌哥和Thomas，但是我想要一行代码能影响到许多人的那种成就感，遗憾的是我在这里找不到，我为此进行了长时间的思考，花费了很多精力，最后得出了一个残酷的现实：公司没有任何问题，我也没有问题，只是不适合而已。</p>\n<h2 id=\"路就在那里，一直向前\"><a href=\"#路就在那里，一直向前\" class=\"headerlink\" title=\"路就在那里，一直向前\"></a>路就在那里，一直向前</h2><blockquote>\n<p>英国人乔治是世界上第一位登上珠峰的人，《纽约时报》有一次问乔治，说：你为什么要攀登珠峰，乔治说： 因为山就在那里！随后成为了一句名言。</p>\n</blockquote>\n<p>因为路就在那里一直向前，所以生活还得继续，都说好男儿志在四方，因为人无信（自信）不立，所以理应四海为家，我还年轻，我愿意用现在这么多安逸的日子，去换一个机会，就一个机会，只为在我还年轻的时候有幸去经历一个野蛮生长、过山车般的项目（当然这只是我的奢望，这种事看缘分了，你懂的），我可能会走得很远，也可能下一步就会跌倒，但人生就像奔涌的浪花，不遇到坚硬的礁石，难以激起美丽的浪花，人生更像一盒巧克力，你永远不知道下一块会是什么味道，而冒险的意义即在于此，梦想的意义也在于此。 </p>\n<p>倘若没有梦想，那我和咸鱼又有什么区别呢，如果满足现状，至少还能多快活一会，年复一年，日复一日，但我宁愿用这么多快活的日子，就换一个机会，就一个机会，回到这里，告诉现实，你也许能使我一天饥肠辘辘，但你永远也夺不走我的梦想，我也一直坚信我不会为了任何事而流泪，除了登上纽交易所的那一刻，这就是我的梦想。</p>\n<p>而关于梦想最重要的是不要让任何人告诉你，你不能做什么，只要你有梦想，就要去追求，别人办不到，就会说你也办不到，你想要什么，就要努力的去追求，对于想做的事，倘若心中愿意，道路千万条，倘若心中不愿意，理由千万个，虽千万里，吾往矣。</p>\n<p>而我最想做的事也是最幸福的事，不是躺在床上睡到自然醒，也不是坐在家里无所事事，而是和一群志同道合充满正能量的人，一起奔跑在理想的路上，什么都经历过了，回头有一路的故事，低头有坚定的脚步，抬头有清晰的远方。和一群有梦想的人一起奔跑，就是最美好的生活方式。</p>\n<p>再过几天，我就要挥师北上，兵发紫禁城，也不要问我为什么要去，因为路就在那里，不长不短。但是可以肯定的是在人生中遇到的每一个人，发生的每一件事都是命中注定，一路走来，感恩大家一路相伴！</p>\n","excerpt":"<p>人生中遇到的每一个人，发生的每一件事都是命中注定，一路走来，感恩大家一路相伴<br>","more":"</p>\n<h2 id=\"浮生若梦，往事成风\"><a href=\"#浮生若梦，往事成风\" class=\"headerlink\" title=\"浮生若梦，往事成风\"></a>浮生若梦，往事成风</h2><blockquote>\n<p>弃我去者昨日之日不可留，天下也没有不散的宴席，人生路不回头，算了，我走了，好马不吃回头草，即以成风，又何必去想，又何必留恋。</p>\n</blockquote>\n<p><img src=\"http://7xtj85.com1.z0.glb.clouddn.com/%E6%95%A3%E4%BC%99%E9%A5%AD.jpg\" alt=\"散伙饭了，555\"><br>我是去年7月6号来公司报到，16号进的项目组，是zhonglin把我从5楼领下来的，就这样来到了3楼，到今年7月11号，转眼间整整一年就过去了，只不过去年来的时候是骄阳似火，而今年走的时候是大雨磅礴，记得刚来时一切都很新鲜，我至今还记得我们西安的3个人拖着箱子走出花神庙地铁站的情境，真的是仿佛一切都在昨天。</p>\n<p>在公司一年中，我成长的很快，在技术和沟通上都有很大的提升，先是Jerry带的我，然后是大Bruce带的我，最后是斌哥带的我，特别是斌哥，经验很丰富，有带人的经验，最关键的是斌哥愿意带我们这些新人，没有斌哥带之前，我的code写的很差劲，斌哥带了我之后，是一行一行code review的，我开始说什么地方重要再review，斌哥说不管大小都要review，事实证明这个过程对我的帮助是非常巨大的，斌哥当时还跟我说了一句话，我记忆很深刻，大概是不是每个人都有机会去经历一个完整的项目过程，我也从DRS中领悟到了:小步快跑、不断试错、快速迭代的敏捷开发理念。但是最后下来，我还是把斌哥给坑了，我真的感觉最对不住的人就是斌哥了。</p>\n<p>和大家在一起整整一年了，一年时间说长不长说短不短，我一直有一个感觉，真的是没有任何人有义务给你指导，给你耐心的去讲一些东西，要说有的话这也是人和人之间的缘分，作为一个重感情的人，从某种程度上来讲，我是很感恩公司的，刚来公司试用期结束的时候，在做总结的时候我也说过同样的话，我清楚的知道公司对我有知遇之恩，所以时常感恩公司给我提供工作与学习的机会，也感激大家一年来对我的照顾，特别是斌哥和Thomas，但是我想要一行代码能影响到许多人的那种成就感，遗憾的是我在这里找不到，我为此进行了长时间的思考，花费了很多精力，最后得出了一个残酷的现实：公司没有任何问题，我也没有问题，只是不适合而已。</p>\n<h2 id=\"路就在那里，一直向前\"><a href=\"#路就在那里，一直向前\" class=\"headerlink\" title=\"路就在那里，一直向前\"></a>路就在那里，一直向前</h2><blockquote>\n<p>英国人乔治是世界上第一位登上珠峰的人，《纽约时报》有一次问乔治，说：你为什么要攀登珠峰，乔治说： 因为山就在那里！随后成为了一句名言。</p>\n</blockquote>\n<p>因为路就在那里一直向前，所以生活还得继续，都说好男儿志在四方，因为人无信（自信）不立，所以理应四海为家，我还年轻，我愿意用现在这么多安逸的日子，去换一个机会，就一个机会，只为在我还年轻的时候有幸去经历一个野蛮生长、过山车般的项目（当然这只是我的奢望，这种事看缘分了，你懂的），我可能会走得很远，也可能下一步就会跌倒，但人生就像奔涌的浪花，不遇到坚硬的礁石，难以激起美丽的浪花，人生更像一盒巧克力，你永远不知道下一块会是什么味道，而冒险的意义即在于此，梦想的意义也在于此。 </p>\n<p>倘若没有梦想，那我和咸鱼又有什么区别呢，如果满足现状，至少还能多快活一会，年复一年，日复一日，但我宁愿用这么多快活的日子，就换一个机会，就一个机会，回到这里，告诉现实，你也许能使我一天饥肠辘辘，但你永远也夺不走我的梦想，我也一直坚信我不会为了任何事而流泪，除了登上纽交易所的那一刻，这就是我的梦想。</p>\n<p>而关于梦想最重要的是不要让任何人告诉你，你不能做什么，只要你有梦想，就要去追求，别人办不到，就会说你也办不到，你想要什么，就要努力的去追求，对于想做的事，倘若心中愿意，道路千万条，倘若心中不愿意，理由千万个，虽千万里，吾往矣。</p>\n<p>而我最想做的事也是最幸福的事，不是躺在床上睡到自然醒，也不是坐在家里无所事事，而是和一群志同道合充满正能量的人，一起奔跑在理想的路上，什么都经历过了，回头有一路的故事，低头有坚定的脚步，抬头有清晰的远方。和一群有梦想的人一起奔跑，就是最美好的生活方式。</p>\n<p>再过几天，我就要挥师北上，兵发紫禁城，也不要问我为什么要去，因为路就在那里，不长不短。但是可以肯定的是在人生中遇到的每一个人，发生的每一件事都是命中注定，一路走来，感恩大家一路相伴！</p>"},{"title":"Hello World","toc":true,"date":"2016-04-21T01:50:39.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntoc: true\ndate: 2016-04-21 09:50:39\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2016-07-29T10:52:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir7mqrq8001n526riz4owzc1","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cir7mqrop0002526rq7jjrgb0","category_id":"cir7mqrp5000a526r47hi7898","_id":"cir7mqrpc000j526ru8pbpp8m"},{"post_id":"cir7mqrp9000g526rozx0x431","category_id":"cir7mqrp8000e526rymqlbluu","_id":"cir7mqrph000n526rcjnq9ucl"},{"post_id":"cir7mqroy0006526rrle8nocg","category_id":"cir7mqrp8000e526rymqlbluu","_id":"cir7mqrpj000r526rizo7o1r9"},{"post_id":"cir7mqrpb000i526rwl7z799f","category_id":"cir7mqrp8000e526rymqlbluu","_id":"cir7mqrpl000u526rcngjwqpq"},{"post_id":"cir7mqrpf000m526rctu3t9t6","category_id":"cir7mqrp8000e526rymqlbluu","_id":"cir7mqrpn000x526rf6vhhwm0"},{"post_id":"cir7mqrp00007526r42vzjrpk","category_id":"cir7mqrp8000e526rymqlbluu","_id":"cir7mqrpr0011526rhw5noxgp"},{"post_id":"cir7mqrph000o526r8rlkm3r1","category_id":"cir7mqrp8000e526rymqlbluu","_id":"cir7mqrpt0013526r3xsewvi1"},{"post_id":"cir7mqroj0000526r9joaqe8x","category_id":"cir7mqrox0005526rjynxs1ll","_id":"cir7mqrpv0017526rbcm51uvk"},{"post_id":"cir7mqroj0000526r9joaqe8x","category_id":"cir7mqrpi000p526rum6t12e2","_id":"cir7mqrpx0019526r695wvrvo"},{"post_id":"cir7mqrpq0010526r7pdktk6n","category_id":"cir7mqrp8000e526rymqlbluu","_id":"cir7mqrq2001d526r42ek52oe"},{"post_id":"cir7mqrp30009526racse4yxc","category_id":"cir7mqrp8000e526rymqlbluu","_id":"cir7mqrq5001g526rubwt339r"},{"post_id":"cir7mqrpt0015526r9nea4rc8","category_id":"cir7mqrp8000e526rymqlbluu","_id":"cir7mqrq8001l526rehpfclaj"},{"post_id":"cir7mqrp5000b526redkr3702","category_id":"cir7mqrp8000e526rymqlbluu","_id":"cir7mqrqb001o526r3ae5k68m"},{"post_id":"cir7mqrpv0018526ran1banth","category_id":"cir7mqrp8000e526rymqlbluu","_id":"cir7mqrqe001s526revg5vfbs"},{"post_id":"cir7mqrpz001b526rfgfrr0fy","category_id":"cir7mqrp8000e526rymqlbluu","_id":"cir7mqrqe001u526rtyuiaoiy"},{"post_id":"cir7mqrp7000c526ruqzqhiq0","category_id":"cir7mqrp8000e526rymqlbluu","_id":"cir7mqrqg001x526rienbl25i"},{"post_id":"cir7mqrq2001f526rv6v2hvzz","category_id":"cir7mqrox0005526rjynxs1ll","_id":"cir7mqrqg001z526rl04k8m5p"},{"post_id":"cir7mqrq2001f526rv6v2hvzz","category_id":"cir7mqrpi000p526rum6t12e2","_id":"cir7mqrqi0023526rcttjjlmt"},{"post_id":"cir7mqrpj000s526rnc5ol3h6","category_id":"cir7mqrq5001h526rseio8h32","_id":"cir7mqrqi0025526rz57xf1ep"},{"post_id":"cir7mqrpl000v526r583pcd69","category_id":"cir7mqrqb001q526rjxjc0uuu","_id":"cir7mqrqi0027526ronm5fs4c"},{"post_id":"cir7mqrpr0012526rwhszr082","category_id":"cir7mqrqb001q526rjxjc0uuu","_id":"cir7mqrqi0028526r1cj5i3vb"},{"post_id":"cir7mqrq6001j526rwfg26j9i","category_id":"cir7mqrqh0021526ro309kjbt","_id":"cir7mqrqj002a526rbcqojxp5"}],"PostTag":[{"post_id":"cir7mqroj0000526r9joaqe8x","tag_id":"cir7mqrot0004526rbguu3go3","_id":"cir7mqrp9000f526r0211bgt7"},{"post_id":"cir7mqroj0000526r9joaqe8x","tag_id":"cir7mqrp30008526r6ms5plw3","_id":"cir7mqrpa000h526rhuolfnla"},{"post_id":"cir7mqrop0002526rq7jjrgb0","tag_id":"cir7mqrp8000d526r3ut636z6","_id":"cir7mqrpk000t526rl4sksbka"},{"post_id":"cir7mqrop0002526rq7jjrgb0","tag_id":"cir7mqrpd000k526rislk3lpw","_id":"cir7mqrpn000w526r1mv96vnu"},{"post_id":"cir7mqroy0006526rrle8nocg","tag_id":"cir7mqrpj000q526ryqkrigxb","_id":"cir7mqrq2001e526r2jh986d9"},{"post_id":"cir7mqroy0006526rrle8nocg","tag_id":"cir7mqrpo000z526rpci9ezbn","_id":"cir7mqrq6001i526rjjl1v18s"},{"post_id":"cir7mqroy0006526rrle8nocg","tag_id":"cir7mqrpd000k526rislk3lpw","_id":"cir7mqrq8001m526ri4017q32"},{"post_id":"cir7mqrpz001b526rfgfrr0fy","tag_id":"cir7mqrpj000q526ryqkrigxb","_id":"cir7mqrqb001p526rmzbo4eot"},{"post_id":"cir7mqrpz001b526rfgfrr0fy","tag_id":"cir7mqrpd000k526rislk3lpw","_id":"cir7mqrqe001t526rennqre2v"},{"post_id":"cir7mqrp00007526r42vzjrpk","tag_id":"cir7mqrpj000q526ryqkrigxb","_id":"cir7mqrqg001y526rxio3vy5g"},{"post_id":"cir7mqrp00007526r42vzjrpk","tag_id":"cir7mqrq8001k526r49er5fo3","_id":"cir7mqrqh0020526rz3mzn9qd"},{"post_id":"cir7mqrp00007526r42vzjrpk","tag_id":"cir7mqrpd000k526rislk3lpw","_id":"cir7mqrqi0024526r4ditywze"},{"post_id":"cir7mqrp30009526racse4yxc","tag_id":"cir7mqrpj000q526ryqkrigxb","_id":"cir7mqrqj002b526rvwzyqwzp"},{"post_id":"cir7mqrp30009526racse4yxc","tag_id":"cir7mqrqh0022526r3d7nenxe","_id":"cir7mqrqj002c526rgzrs9y68"},{"post_id":"cir7mqrp30009526racse4yxc","tag_id":"cir7mqrpd000k526rislk3lpw","_id":"cir7mqrqj002e526rada2vh20"},{"post_id":"cir7mqrp5000b526redkr3702","tag_id":"cir7mqrpj000q526ryqkrigxb","_id":"cir7mqrql002g526r1jwc5b74"},{"post_id":"cir7mqrp5000b526redkr3702","tag_id":"cir7mqrpd000k526rislk3lpw","_id":"cir7mqrql002h526r5opb6t7h"},{"post_id":"cir7mqrp7000c526ruqzqhiq0","tag_id":"cir7mqrpj000q526ryqkrigxb","_id":"cir7mqrql002k526rbyj024q4"},{"post_id":"cir7mqrp7000c526ruqzqhiq0","tag_id":"cir7mqrql002i526rfat4tlgh","_id":"cir7mqrql002l526r5g6taooa"},{"post_id":"cir7mqrp9000g526rozx0x431","tag_id":"cir7mqrpj000q526ryqkrigxb","_id":"cir7mqrqn002o526r2h7cfmnk"},{"post_id":"cir7mqrp9000g526rozx0x431","tag_id":"cir7mqrpd000k526rislk3lpw","_id":"cir7mqrqo002p526rkg0e3jxg"},{"post_id":"cir7mqrpb000i526rwl7z799f","tag_id":"cir7mqrpj000q526ryqkrigxb","_id":"cir7mqrqp002t526rajn8kw35"},{"post_id":"cir7mqrpb000i526rwl7z799f","tag_id":"cir7mqrpo000z526rpci9ezbn","_id":"cir7mqrqp002u526rvudlnngq"},{"post_id":"cir7mqrpb000i526rwl7z799f","tag_id":"cir7mqrpd000k526rislk3lpw","_id":"cir7mqrqq002w526rbcdw3qvs"},{"post_id":"cir7mqrpf000m526rctu3t9t6","tag_id":"cir7mqrpj000q526ryqkrigxb","_id":"cir7mqrqq002y526rzlajoktj"},{"post_id":"cir7mqrpf000m526rctu3t9t6","tag_id":"cir7mqrqp002v526rze2ti7yx","_id":"cir7mqrqq002z526rf98lcn0x"},{"post_id":"cir7mqrpf000m526rctu3t9t6","tag_id":"cir7mqrpd000k526rislk3lpw","_id":"cir7mqrqq0031526r3z9lsoc6"},{"post_id":"cir7mqrph000o526r8rlkm3r1","tag_id":"cir7mqrpj000q526ryqkrigxb","_id":"cir7mqrqs0033526rc7psr6x0"},{"post_id":"cir7mqrph000o526r8rlkm3r1","tag_id":"cir7mqrqp002v526rze2ti7yx","_id":"cir7mqrqs0034526rrmvzgxtf"},{"post_id":"cir7mqrph000o526r8rlkm3r1","tag_id":"cir7mqrpd000k526rislk3lpw","_id":"cir7mqrqt0036526rk9uploou"},{"post_id":"cir7mqrpj000s526rnc5ol3h6","tag_id":"cir7mqrqr0032526rwb9x42fy","_id":"cir7mqrqt0038526r47cagesl"},{"post_id":"cir7mqrpj000s526rnc5ol3h6","tag_id":"cir7mqrqs0035526ruv3azuyp","_id":"cir7mqrqt0039526rbws6fqdt"},{"post_id":"cir7mqrpl000v526r583pcd69","tag_id":"cir7mqrqt0037526regu6w2th","_id":"cir7mqrqt003b526rsgtij1et"},{"post_id":"cir7mqrpq0010526r7pdktk6n","tag_id":"cir7mqrpj000q526ryqkrigxb","_id":"cir7mqrqu003e526rkz4oxguh"},{"post_id":"cir7mqrpq0010526r7pdktk6n","tag_id":"cir7mqrqt003a526r1xjwvfho","_id":"cir7mqrqu003f526rrfcxw5ve"},{"post_id":"cir7mqrpq0010526r7pdktk6n","tag_id":"cir7mqrpd000k526rislk3lpw","_id":"cir7mqrqv003h526rm5k50ntp"},{"post_id":"cir7mqrpq0010526r7pdktk6n","tag_id":"cir7mqrqu003c526rdx5a7n14","_id":"cir7mqrqv003i526r2nngc068"},{"post_id":"cir7mqrpr0012526rwhszr082","tag_id":"cir7mqrqu003d526rlu0qlhko","_id":"cir7mqrqw003k526r9wdce7f9"},{"post_id":"cir7mqrpr0012526rwhszr082","tag_id":"cir7mqrpd000k526rislk3lpw","_id":"cir7mqrqw003l526r23sliiu7"},{"post_id":"cir7mqrpt0015526r9nea4rc8","tag_id":"cir7mqrpj000q526ryqkrigxb","_id":"cir7mqrqx003n526rt7k461ap"},{"post_id":"cir7mqrpt0015526r9nea4rc8","tag_id":"cir7mqrqh0022526r3d7nenxe","_id":"cir7mqrqx003o526rsks3fp0m"},{"post_id":"cir7mqrpt0015526r9nea4rc8","tag_id":"cir7mqrpd000k526rislk3lpw","_id":"cir7mqrr0003q526rmecpjkbn"},{"post_id":"cir7mqrpv0018526ran1banth","tag_id":"cir7mqrpj000q526ryqkrigxb","_id":"cir7mqrr0003r526ro5jdlaqn"},{"post_id":"cir7mqrpv0018526ran1banth","tag_id":"cir7mqrqu003c526rdx5a7n14","_id":"cir7mqrr1003t526rf8xnfzgu"},{"post_id":"cir7mqrpv0018526ran1banth","tag_id":"cir7mqrpd000k526rislk3lpw","_id":"cir7mqrr1003u526r94cv951b"},{"post_id":"cir7mqrpv0018526ran1banth","tag_id":"cir7mqrqt003a526r1xjwvfho","_id":"cir7mqrr1003w526r58drdyg5"},{"post_id":"cir7mqrq2001f526rv6v2hvzz","tag_id":"cir7mqrot0004526rbguu3go3","_id":"cir7mqrr1003x526rr5ig74m6"},{"post_id":"cir7mqrq2001f526rv6v2hvzz","tag_id":"cir7mqrp30008526r6ms5plw3","_id":"cir7mqrr1003y526rqj0ihteu"},{"post_id":"cir7mqrq2001f526rv6v2hvzz","tag_id":"cir7mqrqz003p526r19wvb2ww","_id":"cir7mqrr20040526ru964893j"},{"post_id":"cir7mqrq6001j526rwfg26j9i","tag_id":"cir7mqrr0003s526rmppnh248","_id":"cir7mqrr20041526rj38wapx5"},{"post_id":"cir7mqrq6001j526rwfg26j9i","tag_id":"cir7mqrr1003v526rwz2bq9um","_id":"cir7mqrr20042526r4j5od1fw"},{"post_id":"cir7mqrq6001j526rwfg26j9i","tag_id":"cir7mqrr1003z526rsrhz9flp","_id":"cir7mqrr20043526rpzui853y"}],"Tag":[{"name":"C++","_id":"cir7mqrot0004526rbguu3go3"},{"name":"设计模式","_id":"cir7mqrp30008526r6ms5plw3"},{"name":"CSS","_id":"cir7mqrp8000d526r3ut636z6"},{"name":"前端开发","_id":"cir7mqrpd000k526rislk3lpw"},{"name":"JavaScript","_id":"cir7mqrpj000q526ryqkrigxb"},{"name":"函数","_id":"cir7mqrpo000z526rpci9ezbn"},{"name":"this","_id":"cir7mqrq8001k526r49er5fo3"},{"name":"Prototype","_id":"cir7mqrqh0022526r3d7nenxe"},{"name":"前端开发， 事件","_id":"cir7mqrql002i526rfat4tlgh"},{"name":"Vue","_id":"cir7mqrqp002v526rze2ti7yx"},{"name":"代码大全2","_id":"cir7mqrqr0032526rwb9x42fy"},{"name":"编码规范","_id":"cir7mqrqs0035526ruv3azuyp"},{"name":"PPT","_id":"cir7mqrqt0037526regu6w2th"},{"name":"闭包","_id":"cir7mqrqt003a526r1xjwvfho"},{"name":"Scope chain","_id":"cir7mqrqu003c526rdx5a7n14"},{"name":"职业发展","_id":"cir7mqrqu003d526rlu0qlhko"},{"name":"HTTP","_id":"cir7mqrqz003p526r19wvb2ww"},{"name":"趋势科技","_id":"cir7mqrr0003s526rmppnh248"},{"name":"工作一年","_id":"cir7mqrr1003v526rwz2bq9um"},{"name":"感恩","_id":"cir7mqrr1003z526rsrhz9flp"}]}}